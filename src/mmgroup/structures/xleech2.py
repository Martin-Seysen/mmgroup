r"""We deal with an extraspecial group that maps to the Leech lattice mod 2

TODO: This comment is yet to be completed!

Let :math:`Q_x` be the group generated by elements :math:`x_d, x_\delta`
with :math:`d \in \mathcal{P}, \delta \in \mathcal{C}^*`. Here 
:math:`\mathcal{P}` is the Parker loop and :math:`\mathcal{C}^*` is the
Golay cocode as in :cite:`Con85`. We take the following relations in
:math:`Q_x` from and cite:`Seysen20`:


.. math::

    x_d x_e = x_{d \cdot e} x_{A(d,e)}, \,
    x_\delta x_\epsilon = x_{\delta \epsilon}, \,
    [x_d _\delta] = x_{-1}^{\langle d, \delta \rangle}, \,
    d, e \in \mathcal{P},
    \delta , \epsilon \in \mathcal{C}^* \, .

Here :math:`A(d,e)` is the associator between :math:`d` and :math:`e`,
i.e. the element of :math:`\mathcal{C}^*` corresponding to the
vector :math:`d \cap e`. 

An element of the group :math:`Q_x` is modelled as an instance of
class |XLeech2|


"""




from functools import reduce
from operator import __xor__
from numbers import Integral, Number
from random import randint

try:
    # Try importing the fast C function
    from mmgroup import mat24 
except (ImportError, ModuleNotFoundError):
    # Use the slow python function if the C function is not available
    from mmgroup.dev.mat24.mat24_ref import  Mat24
    mat24 = Mat24

from mmgroup.structures.abstract_group import AbstractGroupWord
from mmgroup.structures.abstract_group import AbstractGroup
from mmgroup.structures.abstract_mm_group import AbstractMMGroupWord
from mmgroup.structures.parity import Parity
from mmgroup.structures.parse_atoms import ihex


from mmgroup.structures.gcode import GCode, GcVector
from mmgroup.structures.cocode import Cocode
from mmgroup.structures.autpl import AutPL, AutPlGroup

from mmgroup.generators import gen_xi_mul_leech
from mmgroup.generators import gen_xi_pow_leech
from mmgroup.generators import gen_xi_scalprod_leech

ERR_RAND = "Illegal string for constricting type %s element" 

ERR_DIV4 = "%s object may be divided by 2 or 4 only"
ERR_DIV2 = "%s object may be divided by 2 only"


#######################################################################
# Import derived classed
#######################################################################

import_pending = True

def complete_import():
    """Internal function of this module

    If you need any of the objects declared above, do the following:

    if import_pending:
        complete_import()
    """
    global import_pending, SubOctad
    from mmgroup.structures.suboctad import SubOctad
    import_pending = False



#######################################################################
# Auxiliary functions
#######################################################################



def value_from_ploop(ploop):
    raise NotImplementedError





#######################################################################
# Class XLeech2
#######################################################################





class XLeech2(AbstractGroupWord):
    """This class models an element of the group :math:`Q_x`.

    The group :math:`Q_x` is an extraspecial 2 group of structure 
    :math:`2^{1+24}`. 
    
    TODO: documentation yet to be updated!!!

    The group operation is written multiplicatively. 
        
    The :math:`2^{1+24}` group elements are numbered from
    ``0`` to ``0x1ffffff``. Elements ``0`` to ``0xffffff`` are
    considered positive. The element with number  ``0x1000000 ^ i`` 
    is the negative of the element with number  ``i``.

    An element is constructed as a product :math:`x_d x_\delta`,
    where :math:`d` is in the Parker loop and :math:`\delta` is in
    the Golay cocode.

    :param ploop:

      This parameter describes the value `d` of the Parker loop 
      element  :math:`x_d`. 

    :param cocode:

      This parameter describes the value `\delta` of the Parker loop 
      element  :math:`x_\delta`. 

    :return: A Parker loop element
    :rtype:  an instance of class |PLoop|

    :raise:
        * ValueError if the input cannot converted to an element of
          the group :math:`Q_0`.
        * TypeError the ype of an input is illegal.


    Depending on its type parameter **value** is  interpreted as follows:

    .. table:: Legal types for constructor of class ``XLeech2``
      :widths: 20 80

      ===================== ================================================
      type                  Evaluates to
      ===================== ================================================
      ``int``               Here the code word with number ``value`` is
                            returned.  ``0 <= value < 0x2000000`` must hold.
                            
  
      ``list`` of ``int``   Such a list is converted to a Golay code word,
                            see class |GCode|, and the corresponding 
                            (positive) Parker loop element is returned.

      class |GCode|         The corresponding 
                            (positive) Parker loop element is returned. 

      class |PLoop|         A deep copy of parameter ``value`` is returned.

      class |GcVector|      This is converted to a Golay code word,
                            see class |GCode|, and the corresponding 
                            (positive) Parker loop element is returned.

      class |SubOctad|      The *octad* part of the |SubOctad| ``value``  
                            is  returned. 

      ``str``               Create random element depending on the string
                             | ``'r'``: Create arbitrary Parker loop element

      ===================== ================================================



    **Standard operations**

    Let ``q`` be an instance of this class. The multiplication operator 
    ``*`` implements the group operation. Division by an element means
    multiplication by its inverse, and exponentiation means repeated 
    multiplication,  with ``q**(-1)`` the inverse of  ``q``,  as usual. 

    Multiplication with the integer ``1`` or ``-1`` means the 
    multiplication with the neutral element or with the central 
    involution :math:`x_{-1}`.
     
    The opration  ``&`` denotes the scalar product of the vectors
    in the Leech lattice mod 2 obtained from an instance of this
    class, ignoring the sign.

    **Standard functions**
  
    ``abs(a)`` returns the element in the set ``{a, -a}`` which is
    positive.

    TODO: WARN NOT SUBGROUP OF Q_x0
    """
    __slots__ = "value",
 
    def __init__(self, ploop = 0, cocode = 0):
        if import_pending:
            complete_import()
        self.value = value_from_ploop(ploop) ^ Cocode(cocode).ord


    def __mul__(self, other):
        if isinstance(other, XLeech2):
            return XLeech2(gen_xi_mul_leech(self.value, other.value))
        elif isinstance(other, (PLoop, Cocode)):
            v =  value_from_ploop(other)
            return XLeech2(gen_xi_mul_leech(self.value, v))
        elif isinstance(other, AbstractMMGroupWord):
            data = other.data
            v = gen_leech2_op_word(self.value, data, len(data))
            return XLeech2(v)
        elif isinstance(other, Integral):
            if abs(other) == 1:
                return XLeech2(self.value ^ ((other & 2) << 23))
            elif other == 0:
                 return XLeech2(0)
            return NotImplemented
        else:           
            return NotImplemented

    def __imul__(self, other):
        self.value = self.__mul__(other).value
        return self

    def __rmul__(self, other):
        if isinstance(other, XLeech2):
            return XLeech2(gen_xi_mul_leech(other.value, self.value))
        elif isinstance(other, (PLoop, Cocode)):
            v =  value_from_ploop(other)
            return XLeech2(gen_xi_mul_leech(v, self.value))
        elif isinstance(other, Integral):
            if abs(other) == 1:
                return XLeech2(self.value ^ ((other & 2) << 23))
            elif other == 0:
                 return XLeech2(0)
            return NotImplemented
        else:           
            return NotImplemented


    def __pow__(self, other):
        if isinstance(other, Integral):            
            return XLeech2(gen_xi_pow_leech(self.value, other & 3))
        elif isinstance(other, XLeech2):
            ov = other.value
            v = self.value
            w = gen_xi_mul_leech(gen_xi_pow_leech(ov, 3), v)
            w = gen_xi_mul_leech(w, ov)
            return XLeech2(w)
        else:
            return NotImplemented
        


    def __truediv__(self, other):
        if isinstance(other, XLeech2):
            v = gen_xi_pow_leech(other.value, 3)
            return XLeech2(gen_xi_mul_leech(self.value, other.value))
        elif isinstance(other, (PLoop, Cocode)):
            v = gen_xi_pow_leech(value_from_ploop(other), 3)
        elif isinstance(other, Integral):
            if abs(other) == 1:
                v = (other & 2) << 23
            else:
                NotImplemented  
        else:           
            return NotImplemented
        return XLeech2(gen_xi_mul_leech(self.value, v))


    def __itruediv__(self, other):
        self.value = self.__itruediv__(other).value
        return self


                             
    def __rtruediv__(self, other):
        v = gen_xi_pow_leech(other.value, 3)
        if isinstance(other, XLeech2):
            return XLeech2(gen_xi_mul_leech(other.value, v))
        elif isinstance(other, (PLoop, Cocode)):
            v1 =  value_from_ploop(other)
            return XLeech2(gen_xi_mul_leech(v1, v))
        elif isinstance(other, Integral):
            if abs(other) == 1:
                return XLeech2(v ^ ((other & 2) << 23))
            elif other == 0:
                 return XLeech2(0)
            return NotImplemented
        else:           
            return NotImplemented
 
       
    def __and__(self, other):
        if isinstance(other, XLeech2):
            ov = other
        elif isinstance(other, XLeech2):
            ov = value_from_ploop(other) 
        else:
            return NotImplemented
        return gen_xi_scalprod_leech(self.value, ov)

    __rand__ = __and__

    def __eq__(self, other):
        return (isinstance(other, XLeech2)  
            and (self.value ^ other.value) & 0x1ffffff == 0)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __pos__(self):
        return self
        
    def __neg__(self):
        return  PLoop(self.value ^ 0x1000000)


    @property
    def ord(self):
        """Return the number of the Parker loop element.

        We have ``0 <= i < 0x2000000`` for the returned number ``i``.
        """
        return self.value & 0x1ffffff


    @property
    def sign(self):
        """Return the sign of the Parker loop element.

        This is ``1`` for a positive and ``-1`` for a negative element.
        """
        return 1 - ((self.value >> 23) & 2)


    def split(self):
        """Yet to be documented!!!!

        """
        v = self.value
        x = (v >> 12) & 0x1fff
        d = (mat24.ploop_theta(v >> 12) ^ v) & 0xfff
        return PLoop(x), Cocode(d)
 
     
    def str(self):
        v = self.value
        x = (v >> 12) & 0x1fff
        d = (mat24.ploop_theta(v >> 12) ^ v) & 0xfff
        return "XL2<x_%s*d_%s>" % (ihex(x, 3), ihex(d, 3))
    __repr__  = str






