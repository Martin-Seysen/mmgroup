"""Construct a random element of the Monster group

The main function ``iter_reandom_mm()`` in this module constructs an 
random element of the Monster group from data structures as specified 
in section **The Monster group** of the **API reference**. This function
yields the entries of a numpy array of type ``np.uint32`` containing 
internal represntation of the constructed element.

Functions or data structures in this module starting with an
underscore (``_``) should not be imported by other modules.
"""

import collections
import re
import warnings
from numbers import Integral
import numpy as np
from random import randint
from functools import partial

try:
    from mmgroup import mat24
    from mmgroup.mat24 import ploop_theta, pow_ploop, MAT24_ORDER
except:
    w = "Extension mmgroup.mat24 not found, package not functional!"
    warnings.warn(w, UserWarning)


from mmgroup.generators import rand_get_seed, gen_leech2_type
from mmgroup.generators import gen_rng_modp
from mmgroup.generators import gen_leech2_reduce_type4
from mmgroup.generators import mm_group_invert_word
from mmgroup.generators import mm_group_n_reduce_element
from mmgroup.generators import mm_group_n_clear
from mmgroup.generators import mm_group_n_mul_atom
from mmgroup.clifford12 import xsp2co1_rand_word_G_x0
from mmgroup.clifford12 import xsp2co1_rand_word_N_0


ERR_RAND_INTERN = "Internal error in generating random element of monster"

def _iter_rand_N_0(in_N_x0, even):
    r"""Return random element of subgroup :math:`N_{0}`

    The function returns a uniform distributed random element
    of the subgroup :math:`N_{x}` of the monster of structure
    :math:`2^{2+11+22}.(M_{24} \times \mbox{Sym}_3)`. The group 
    :math:`N_0` is generated by the generators with tags
    ``x, y, d, p, t``. The function uses the internal random 
    generator of the ``mmgroup`` package.

    If parameter ``in_N_x0`` is nonzero then we compute a random
    element of the subgroup :math:`N_{x0}` of index 3 in :math:`N_0` 
    generated by the generators with tags ``x, y, d, p``.

    If parameter ``even`` is nonzero then we compute a random
    element of the  subgroup :math:`N_{\mbox{even}}` of index 2
    in :math:`N_{x}`  generated by the generators with
    tags ``x, y, d, p, t``, where all generators with tag ``d``
    correspond to even Golay cocode words.

    If both, ``in_N_x0`` and ``even``, are nonzero then we compute
    a random element
    of :math:`N_{xyz0} = N_{\mbox{even}} \cap N_{x0}`.
    """
    buf = np.zeros(10, dtype = np.uint32)
    seed = rand_get_seed()
    length = xsp2co1_rand_word_N_0(buf, in_N_x0, even, seed) 
    if not 0 <= length <= 10:
        raise ValueError(ERR_RAND_INTERN)
    yield from buf[:length]
     

def _iter_rand_G_x0():
    r"""Return random element of subgroup :math:`G_{x0}`

    The function returns a uniform distributed random element
    of the subgroup :math:`G_{x0}`. The function uses the
    internal random generator of the ``mmgroup`` package.
    """
    buf = np.zeros(10, dtype = np.uint32)
    seed = rand_get_seed()
    length = xsp2co1_rand_word_G_x0(buf, seed) 
    if not 0 <= length <= 10:
        raise ValueError(ERR_RAND_INTERN)
    yield from buf[:length]



def _iter_rand_mm(quality):
    r"""Return a random element of the monster group

    The function returns a random element of the monster group.
    Here ``quality`` means a measure for the quality of the
    randimization process, where a higher value menas that
    the distribution of the elements is closer to uniform.

    If ``quality`` is an integer ``k`` then a product containing
    ``k`` powers of the triality element it generated. Here the
    default value creates an almost uniform distribution.

    In future versions the default value of parameter ``quality``
    may correspond to the generation of a truly uniform
    distribution.
    """
    a = np.zeros(10, dtype = np.uint32)
    seed = rand_get_seed()
    len_a = xsp2co1_rand_word_G_x0(a, seed) 
    if not 0 <= len_a <= 10:
        raise ValueError(ERR_RAND_INTERN)
    yield from a[:len_a]
    for k in range(quality):
        yield 0x50000001 + gen_rng_modp(2, seed)
        c = 0
        while gen_leech2_type(c) != 4:
            c = gen_rng_modp(0x1000000, seed) 
        len_a = gen_leech2_reduce_type4(c, a)
        mm_group_invert_word(a, len_a)
        if not 0 <= len_a <= 6:
            raise ValueError(ERR_RAND_INTERN)
        yield from a[:len_a]



_RAND_FUNCTIONS = {
    "M"      : (_iter_rand_mm, 18),  
    "G_x0"   : (_iter_rand_G_x0,),
    "N_0"    : (_iter_rand_N_0, 0, 0), 
    "N_x0"   : (_iter_rand_N_0, 1, 0), 
    "N_0_e"  : (_iter_rand_N_0, 0, 1), 
    "N_x0_e" : (_iter_rand_N_0, 1, 1), 
}



def iter_random_mm(s):
    if isinstance(s, Integral):
        yield from _iter_rand_mm(s)
        return
    try:
        ff = _RAND_FUNCTIONS[s]
    except KeyError:
        if isinstance(s, str):
            err = "Bad group name '%s' for tag 'r'"
            raise ValueError(err % s)
        else:
            err = "Atom for tag 'r' must be a string"
            raise TypeError(err)
    yield from ff[0](*(ff[1:]))
    
