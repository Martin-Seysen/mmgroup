"""Construct a random element of the Monster group

The main function ``iter_reandom_mm()`` in this module constructs an 
random element of the Monster group from data structures as specified 
in section **The Monster group** of the **API reference**. This function
yields the entries of a numpy array of type ``np.uint32`` containing 
internal represntation of the constructed element.
"""

import collections
import re
import warnings
from numbers import Integral
import numpy as np
from random import randint
from functools import partial

try:
    from mmgroup import mat24
    from mmgroup.mat24 import MAT24_ORDER
    from mmgroup.mat24 import m24num_rand_local
    from mmgroup.mat24 import m24num_rand_adjust_xy
except:
    w = "Extension mmgroup.mat24 not found, package not functional!"
    warnings.warn(w, UserWarning)


from mmgroup.generators import rand_get_seed, gen_leech2_type
from mmgroup.generators import gen_rng_modp
from mmgroup.generators import gen_leech2_reduce_type4
from mmgroup.generators import mm_group_invert_word
from mmgroup.generators import mm_group_n_reduce_element
from mmgroup.generators import mm_group_n_clear
from mmgroup.generators import mm_group_n_mul_atom
from mmgroup.clifford12 import xsp2co1_rand_word_G_x0
from mmgroup.clifford12 import xsp2co1_rand_word_N_0
from mmgroup.mm_op import mm_aux_index_extern_to_sparse
from mmgroup.mm_op import mm_aux_index_sparse_to_leech2
rand_mm_element = None


def import_rand_mm_element():
    global rand_mm_element
    if rand_mm_element is None:
        try:
            from mmgroup.axes import rand_mm_element
        except:
            rand_mm_element = False


r"""Bit semantics

We map the lower 8 bits of an integer to a collection of elementary
Abelian 2 groups :math:`Y_i` that are subgroups subgroup of the Monster
generated by elements of shape :math:`y_d, x_delta`, and :math:`y_d`,
:math:`d \in \mathcal{P}, \delta \in \mathcal{C}^*`. We define the
group :math:`C_i` to be the normalizer of :math:`Y_i` in the Monster.
  

=== =======================================================  === ============= 
Bit Generators of :math:`Y_i`                                Dim Name(s)
=== =======================================================  === =============
0   :math:`x_{\{2,3\}}`                                        1 'B'
1   :math:`x_{\pm \Omega}, x_\delta, x_o, y_o`,               10 'G_10'
    :math:`\delta \subset o, delta \,` even  
2   :math:`x_{\pm \Omega}, x_\delta`, :math:`\delta\,`         5 'G_5t'
    a sextet refining the standard trio :math:`T` 
3   :math:`x_{\pm \Omega}, x_\delta, \delta\,` a union of      5 'G_5l'
    two sets in :math:`\{\{2i, 2i+1\}\mid 4 \leq i < 12\}`
4   :math:`x_{\pm \Omega}, x_{\{0,1,2,3\}}`                    3 'G_3' 
5   :math:`x_{\pm \Omega}, x_{\{0,1,2,3\}},x_{\{0,1,4,5\}}`    2 'G_4'
6   :math:`x_\delta, \delta \in \{\{1,2\},\{2,3\}\}`           2 '2E_6'
8   Central involution :math:`x_{-1}` in :math:`G_{x0}`        1 'G_x0', 'G_1'
9   :math:`x_{\pm\Omega}`                                      2 'N_0', 'G_2'
=== =======================================================  === =============

Here :math:`\Omega` is the positive element in the Parker loop 
:math:`\mathcal{P}` that maps to the all-one word in the Golay code
:math:`\mathcal{C}`. :math:`o` a preimage in :math:`\mathcal{P}` of
the standard octad :math:`\{0,\ldots,7 \}` in :math:`\mathcal{C}`.
:math:`T` is the standard trio containing the octads
:math:`\{\{8i,\ldots,8i+7\} \mid i < 3 \}` in  :math:`\mathcal{C}`.
 

# Fix the set containing x_{-1},  and  \{x_{\pm \Omega}\}, and the
# following elements, depending on a bit of a given integer `r
Bit  0: MAT24_RAND_2 # fixes`also  \{2, 3\}  
Bit  1: MAT24_RAND_o # fixes \{0, \ldots,7 \}
Bit  2: MAT24_RAND_t # fixes \{\{8i,\ldots,8i+7\} \mid i < 3 \}
Bit  3: MAT24_RAND_s # fixes \{\{4i,\ldots,4i+3\} \mid i < 6 \}
Bit  4: MAT24_RAND_l # fixes \{\{2i, 2i+1\} \mid  4 \leq i < 12 \}
Bit  5: MAT24_RAND_3 # fixes \{1, 2, 3\}  
Bit  7: MAT24_RAND_d # fixes \{\{2i, 2i+1\} \mid  i < 12 \}



# Fix certain involutions
Bit  8 : # fix x_{-1}
Bit  9 : # fix set \{x_{-1}, x_{\pm \Omega}\}

Bit 12 : # fix set \{x_{-1}, x_{\pm \Omega}\} and parity of cocode word
Bit 13 : # Subgroup AutPL
Bit 14 : # Subgroup Q_x0
"""

_NO       = 0x20000000
_NOT_FULL = 0x40000000


SUBGOUP_MAP = {
   'M':       0,   
   'G_x0':    0x100,  'G_1': 0x100,
   'N_0':     0x200,  'G_2': 0x200,
   'G_3':     0x8      | _NO,
   'G_4':     0x40     | _NO,
   'G_5t':    0x4      | _NO,
   'G_5l':    0x10     | _NO,
   'G_10':    0x2      | _NO,
   'B':       0x1,
   '2E_6':    0x20     | _NO,
 #  'H+'  :    0x1,   # deprecated and erroneous in older versions!!
   'N_0_e':   0x1000,
   'N_x0':    0x300,
   'N_x0_e':  0x1300,
   'Q_x0':    0x4000    | _NO,
   'AutPL':   0x2000    | _NO,
   'AutPL_e': 0x3000    | _NO,
   'quick':  0     # for future optimizations
}



_W_EXPER = "Support for subgroup '%s' of the Monster is experimental"

def _parse_group_description(s_in):
    parts = [t.strip() for t in s_in.split('&')]
    count = 0
    flags = 0
    for s in parts:
        try:
            mask = SUBGOUP_MAP[s]
            flags |= mask
            count += bool(mask)
        except KeyError:
            ERR = "Unknown subgroup description '%s'"
            raise ValueError(ERR % s)
        if flags & _NO:
            warnings.warn(_W_EXPER % s_in, UserWarning) 
    if (flags & _NOT_FULL) and (count > 1):
        warnings.warn(_W_EXPER % s_in, UserWarning) 
    return flags


def _embded_small_into_large(flags):
    if flags & 0x1000:
        flags |= 0x200
    if flags & 0x2000:
        flags |= 0x300
    if flags & 0x4000:
        flags |= 0x300
    return flags

def _random_tag_pi(flags):
    if flags & 0x4000 == 0:
        u_rand = randint(0, MAT24_ORDER - 1)
        pi = m24num_rand_local(flags, u_rand)
        return 0x20000000 + pi

def _iter_tags_yxdp(flags):
    # tag y
    if flags & 0x6000 == 0:
        u_rand = randint(0, 0x1fff)
        y = m24num_rand_adjust_xy(flags, u_rand)
        yield 0x40000000 + y
    # tag x
    if flags & 0x2000 == 0:
        u_rand = randint(0, 0x1fff)
        x = m24num_rand_adjust_xy(flags, u_rand)
        yield 0x30000000 + x
    # tag d
    d = randint(0, 0xfff)
    if flags & 0x1000:
        d &= 0x7ff
    yield 0x10000000 + d
    # tag p
    if flags & 0x4000 == 0:
        u_rand = randint(0, MAT24_ORDER - 1)
        pi = m24num_rand_local(flags, u_rand)
        yield 0x20000000 + pi


BETA = 0x200  # Standard short vector BETA in Leech lattice mod 2

def _rand_Co_2_coset_No():
    r"""Return number of random coset of Co_2 / Co_2 \cap N_x0

    If this function returns the number c then 
    MM('c', c) is a representative of a random coset of
    Co_2 / (Co_2 \cap N_x0)
    """
    while True:
        # generate short vector v2 in Leech lattice mod 2
        ve = randint(300, 98579)  
        vs = mm_aux_index_extern_to_sparse(ve)
        v2 = mm_aux_index_sparse_to_leech2(vs) 
        # Check if v2 is orthogonal to BETA in the real Leech lattice
        v4 = v2 ^ BETA
        if gen_leech2_type(v4) == 4:
            # Return v2 + BETA if this is the case
            return v4 



def _iter_coset_G_x0(flags):
    if flags & 0x200:
        # Generator \xi is not in the subgroup
        return
    relevant_flags = flags & 0x7f
    if relevant_flags & 0x8:
        # Then we deal with in G_3' = G_3 \cap G_x0
        # Here we have |G_3' / G_3' \cap N_x0| = 3
        e = randint(0, 2)
        yield 0x60000000 + e # Append power of \xi
    elif relevant_flags & 0xfe == 0:
        # Then we deal with H = 2.B \cap G_x0 or with H = G_x0
        # Generate suitable type-4 vector in the Leech lattice mod 2
        if relevant_flags:
            # Generate a random type-4 vector c that is orthogonal
            # to the standard type-2 vector in the Leech lattice
            c = _rand_Co_2_coset_No()
        else:
            # Generate a uniform random type-4 vector
            c = 0
            while gen_leech2_type(c) != 4:
                c = randint(0, 0xffffff)
        # Append a word in G_x0 that maps Omega to c
        a = np.zeros(6, dtype = np.uint32)
        len_a = gen_leech2_reduce_type4(c, a)
        mm_group_invert_word(a, len_a)
        yield from a[:len_a]
    else:
        # For the other cases we don't have a really good strategy
        for i in range(4):
            e = randint(1,2)
            yield 0x60000000 + e         # Append nonzero power of \xi
            yield _random_tag_pi(flags)  # Append tag pi generator

# Coset representatives of G_3 / G_3 \cap G_x0. 
# A representative (e,f) means \tau**e * \xi**f.        
G3_COSETS = [(0,0), (1,0), (2,0), (1,1), (1,2), (2,2), (2,2)] 


RAND_FAST_DICT = {
   0: 'M', 1: 'B', 0x100: 'G_x0', 0x101: 'H'
}


def _iter_rand_mm_(flags, n_rounds = 0):
    # Natural embedding of small int large subgroups
    global rand_mm_element
    flags = _embded_small_into_large(flags)
    if flags & 0x101 == flags and n_rounds == 0:
        if rand_mm_element is None:
            import_rand_mm_element()
        if rand_mm_element:
            mm = rand_mm_element(RAND_FAST_DICT[flags], 'a')
            yield from mm
            return
    # A subgroup H of the monster is given by argument ``flags``
    # Generate an element of H_0 =  N_x0 \cap H 
    yield from _iter_tags_yxdp(flags)
    # Put H_1 = <<\xi> \cap H_1, H_0>. Append a coset representative
    # of  H_1 / H_0  in order to extend H_0 to H_1 
    yield from _iter_coset_G_x0(flags)
    # Put H_2 = <<\tau> \cap H_2, H_1>. Append a coset representative
    # of  H_2 / H_1 in order to extend H_1 to H_2 
    if flags & 0x100:
        # Then the triality element \tau is not in the group
        return
    elif flags & 0x208:
        # Then appending a fixed number of generators suffices
        # Append power of \tau
        yield 0x50000000 + randint(0,2)
        if flags & 8:
            # We are in G_3 and there are 3 * 7 cosets
            coset_data = G3_COSETS[randint(0, 6)]
            yield 0x50000000 + coset_data[0] # \tau
            yield 0x60000000 + coset_data[1] # \xi
    else:
        # Standard strategy for large subgroups of the Monster
        if not n_rounds or n_rounds <= 0:
            n_rounds = 5 if flags & 0x7f else 8
        for i in range(n_rounds):
            yield 0x50000000 + randint(1,3)  # \tau
            yield _random_tag_pi(flags)
            yield from _iter_coset_G_x0(flags)




def iter_random_mm(s):
    if isinstance(s, Integral):
        yield from _iter_rand_mm_(0, s)
    else:
        flags = _parse_group_description(s)
        yield from _iter_rand_mm_(flags)



