

/** @file mat24_functions.c
 File ``mat24_functions.c`` contains the C implementation of the 
 functionality of Python module ``mmgroup.mat24``

 This covers the Golay code, its cocode, the Parker loop,
 the Mathieu group Mat24, and the group of standard automorphisms
 of the Parker loop.
*/


// This is a C implementation of the functionality of Python class
// Mat24 as described in the sequel. Note that all exported funtions
// in this module are prefixed with 'mat24_'

// %%PY_DOCSTR Mat24_doc


// %%PY_DOCSTR  Mat24_doc_basis


/*************************************************************************
** External references 
*************************************************************************/




#include <stdint.h>
// #include <stdio.h>
#include <string.h>
#include "mat24_functions.h"


// %%EXPORT_KWD MAT24_API







// %%GEN h
#ifndef MAT24_FUNCTIONS_H
#define MAT24_FUNCTIONS_H

#include <stdint.h>

/** @file mat24_functions.h
  File ``mat24_functions.h`` is the header file for ``mat24_functions.c``. 
*/

/// @cond DO_NOT_DOCUMENT 

#define MAT24_DLL  // We want a DLL!!

// Generic helper definitions for shared library support
#if defined _WIN32 || defined __CYGWIN__
  #define MAT24_HELPER_DLL_IMPORT __declspec(dllimport)
  #define MAT24_HELPER_DLL_EXPORT __declspec(dllexport)
  #define MAT24_HELPER_DLL_LOCAL
#else
  #if __GNUC__ >= 4
    #define MAT24_HELPER_DLL_IMPORT __attribute__ ((visibility ("default")))
    #define MAT24_HELPER_DLL_EXPORT __attribute__ ((visibility ("default")))
    #define MAT24_HELPER_DLL_LOCAL  __attribute__ ((visibility ("hidden")))
  #else
    #define MAT24_HELPER_DLL_IMPORT
    #define MAT24_HELPER_DLL_EXPORT
    #define MAT24_HELPER_DLL_LOCAL
  #endif
#endif

// Now we use the generic helper definitions above to define MAT24_API 
// and MAT24_LOCAL.
// MAT24_API is used for the public API symbols. It either DLL imports 
// or DLL exports (or does nothing for static build). 
// MAT24_LOCAL is used for non-api symbols.

#ifdef MAT24_DLL // defined if MAT24 is compiled as a DLL
  #ifdef MAT24_DLL_EXPORTS // defined if we are building the MAT24 DLL 
                           // (instead of using it)
    #define MAT24_API MAT24_HELPER_DLL_EXPORT
  #else
    #define MAT24_API MAT24_HELPER_DLL_IMPORT
  #endif // MAT24_DLL_EXPORTS
  #define MAT24_LOCAL MAT24_HELPER_DLL_LOCAL
#else // MAT24_DLL is not defined: this means MAT24 is a static lib.
  #define MAT24_API
  #define MAT24_LOCAL
#endif // MAT24_DLL

/// @endcond

// %%GEN ch

/// @cond DO_NOT_DOCUMENT 

// %%GEN c

// %%EXPORT_TABLE p
const uint8_t MAT24_LSBIT_TABLE[32] = { 
// %%TABLE Mat24_lsbit_table, uint8
};

// %%GEN ch

/// @endcond  


// %%GEN h

/**
 @def MAT24_ORDER 
 @brief Order of Mathieu group ``Mat24``. This is equal to 244823040. 
*/
#define MAT24_ORDER 244823040 // Order of Mathieu group Mat24

/**
 @def mat24_def_lsbit24(v1) 
 @brief Macro version of function ``mat24_lsbit24``.
*/
#define mat24_def_lsbit24(v1) %{MAT24_LSBIT:v1}


/**
 @def mat24_def_lsbit24_pwr2(v1) 
 @brief Special macro version of function ``mat24_lsbit24``.

 This is faster than ``mat24_def_lsbit24``, but here
 ``v1`` must be  power of two. 
*/
#define mat24_def_lsbit24_pwr2(v1)  %{MAT24_LSBIT:v1,1}

/**
  @def mat24_def_octad_to_gcode(o)
  @brief Eqivalent to ``mat24_def_octad_to_gcode(o)``

  ``mat24_def_octad_to_gcode(o)`` returns the  number 
  of the Golay code word corresponding to octad ``o``. 
  Parameter ``o`` is not checked.
*/
#define mat24_def_octad_to_gcode(o) (MAT24_OCT_DEC_TABLE[o])


/**
  @def  mat24_def_gcode_to_octad(v)
  @brief Eqivalent to ``mat24_def_gcode_to_octad(v)``

  ``mat24_def_gcode_to_octad(v)`` returns the  number of the
  octad corresponding to Golay code vector ``v``, with ``v``
  in ``gcode``. It returns garbage if ``v`` is not an octad. 
*/
#define mat24_def_gcode_to_octad(v) \
  ((MAT24_OCT_ENC_TABLE[v & 0x7ff] >> 1) \
    + 3 * ((v & 0x7ff) >> 3) - %{Mat24_oct_enc_offset})



/**
  @def  mat24_def_not_nonstrict_octad(v)
  @brief Check if ``v`` (or its complement) is an octad.

  Returns 0 if ``v`` (or its complement) is an 
  octad and 1 otherwise.

  Vector ``v`` must be given in ``gcode`` representation
*/
#define mat24_def_not_nonstrict_octad(v) \
    (((MAT24_OCT_ENC_TABLE[(v) & 0x7ff] + 2) & 0x100) >> 8)

/// @cond DO_NOT_DOCUMENT 
//  Do not document C functions in the header file!

// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


/*************************************************************************
*** Some general bit operations
*************************************************************************/





/**
 @brief Return position of least significant bit of an integer.

 The function returns the minimum of the number 24 and the position of the
 least significant bit of `v1`. It uses a De Bruijn sequence.
*/
// %%EXPORT p
uint32_t mat24_lsbit24(uint32_t v1)
{
    // This is a modification of
    // http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup
    // which returns 24 if v1 & 0xffffff is zero.
    // return MAT24_LSBIT_TABLE[(((v1 & -v1) * 0x077CB531L) >> 26) & 0x1f];
    return %{MAT24_LSBIT:v1};
}



/**
 @brief Returns the bit weight of the lowest 24 bits of ``v1``.      
*/ 
// %%EXPORT p
uint32_t mat24_bw24(uint32_t v1)
{
   v1 = (v1 & 0x555555) + ((v1 & 0xaaaaaa) >> 1); 
   v1 = (v1 & 0x333333) + ((v1 & 0xcccccc) >> 2);
   v1 = (v1 + (v1 >> 4)) & 0xf0f0f;
   return (v1 + (v1 >> 8) + (v1 >> 16)) & 0x1f; 
}    



/*************************************************************************
*** Conversion between bit vectors of GF(2)**24
*************************************************************************/

/**
 @brief Stores the positions of 1-bits of a bit vector to an array.
 
 Let ``w`` be the bit weight of the bit vector ``v1 & 0xffffff``, 
 i.e. number of bits of ``v1``  at positions ``< 24`` equal  to one. 
 Then the ordered bit positions where the corrsponding bit of ``v1`` 
 is 1 are stored in ``a_out[0],...,a_out[w-1]``. 

 Then ``(v1 & 0xffffff)`` has ``24 - w`` zero bits. The 
 ordered  list of the positions of these zero bits is stored in 
``a_out[w],...,a_out[23]``. 
 
 The function returns the bit weight ``w``.
*/
// %%EXPORT p
uint32_t mat24_vect_to_bit_list(uint32_t v1, uint8_t *a_out)
{
    uint_fast32_t w, i, j;

    // put w = bit_weight(v1 & 0xffffff)
    w = (v1 & 0x555555) + ((v1 & 0xaaaaaa) >> 1);
    w = (w & 0x333333) + ((w & 0xcccccc) >> 2);
    w = (w + (w >> 4)) & 0xf0f0f;
    w = (w + (w >> 8) + (w >> 16)) & 0x1f; 
  
    // Separate bits:
    // i is the position and  o  is the value of the current bit of
    // the input vector v being processed (0 coded as 0, 1 coded as 8).
    // j & 0x1f is the position of the next index of the output vector 
    // where to write the position i in case o = 0.
    // (j >> 8) & 0x1f is the position of the next index of the output 
    // vector where to write the position i in case o != 0.
    v1 <<= 3;  // bit 0 of v1 is now at bit position 3
    j = w;    // start writing to pos. 0 if o = 0, to pos. w if o != 0
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = v1 & 8;   // o = value of current bit of v1
        a_out[(j >> o) & 0x1f] = (uint8_t)i;  // write index i to the
                                     // appropriate output position
        j += 1 << o;                 // update both output positions
        v1 >>= 1;                    // process next bit of v1
    }
    return w;
}



/**
 @brief Extract the bits of 24-bit vector ``v1`` given by the mask ``u_mask``
 
 If ``u_mask`` has bits equal to one at positions ``i_0, i_1, ..., i_k``
 (in ascending order) then the bit of ``v1`` at position ``i_j`` is copied 
 to the bit at position ``j`` of the return value for ``j = 0,...,k``.
*/
// %%EXPORT p
uint32_t mat24_extract_b24(uint32_t v1, uint32_t u_mask)
{
    uint_fast32_t res = 0, sh = 0, i;
    v1 &= u_mask;
    for (i = 0; i < 24; ++i) {
        res |= ((v1 >> i) & 1) << sh;
        sh += (u_mask >> i) & 1;
    } 
    return res;
}

/**
 @brief Spread bits of 24-bit vector ``v1`` according to the mask ``u_mask``
 
 If ``u_mask`` has bits equal to one at positions ``i_0, i_1, ..., i_k``
 (in ascending order) then the bit of ``v1`` at position ``i`` is copied 
 to the bit at position ``i_j`` of the return value for ``j = 0,...,k``.
*/
// %%EXPORT p
uint32_t mat24_spread_b24(uint32_t v1, uint32_t u_mask)
{
    uint_fast32_t res = 0, sh = 0, i;
    for (i = 0; i < 24; ++i) {
        res |= (((v1 >> sh) & 1) << i) & u_mask;
        sh += (u_mask >> i) & 1;
    } 
    return res;
}


/*************************************************************************
*** Conversion between representations of GF(2)**24, Golay code, etc.
*************************************************************************/


/// @cond DO_NOT_DOCUMENT 

// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE0[256] = {
// %%TABLE Mat24_enc_table0, uint32
};

// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE1[256] = {
// %%TABLE Mat24_enc_table1, uint32
};

// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE2[256] = {
// %%TABLE Mat24_enc_table2, uint32
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE0[256] = {
// %%TABLE Mat24_dec_table0, uint32
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE1[256] = {
// %%TABLE Mat24_dec_table1, uint32
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE2[256] = {
// %%TABLE Mat24_dec_table2, uint32
};



// The following table MAT24_BASIS contains the used basis of the 
// Golay cocode (12 bit vectors of type uint32_t) followed by the 
// used basis of the Golay code (12 bit vectors).

// %%EXPORT_TABLE p
const uint32_t MAT24_BASIS[24] = { 
// %%TABLE Mat24_basis, uint32
};

// %%EXPORT_TABLE p
const uint32_t MAT24_RECIP_BASIS[24+8] = { 
// %%TABLE Mat24_recip_basis, uint32
};

// %%EXPORT_TABLE p
const uint16_t MAT24_SYNDROME_TABLE[0x800] = { 
// %%TABLE Mat24_syndrome_table, uint16
};

/// @endcond 




/**
  @brief Table for converting ``octad`` to ``gcode`` representation

  The public macro ``mat24_def_octad_to_gcode`` uses this table
*/
// %%EXPORT_TABLE p
const uint16_t MAT24_OCT_DEC_TABLE[759] = { 
// %%TABLE Mat24_oct_dec_table, uint16
};

/**
 @brief Table for converting ``gcode`` to ``octad`` representation

 The public macro ``mat24_def_gcode_to_octad`` uses this table
*/
// %%EXPORT_TABLE p
const uint8_t MAT24_OCT_ENC_TABLE[2048] = { 
// %%TABLE Mat24_oct_enc_table, uint8
};


/** 
 @brief Table containing data about the Golay code.

 For ``0 <= d < 0x800`` entry ``d``  contains the following
 information the code word ``d``, with ``d`` in ``gcode``
 representation.

   Bit 11,...,0:   ``mat24_ploop_theta(d)``

   Bit 14,...,12:  Bit weight of code word ``d`` in ``GF(2)**24`` divided by 4

   Bit 15:         reserved

 We have ``d**2 = (-1)**<Bit 12 of entry d>`` for ``d`` in the Parker loop.
*/
// %%EXPORT_TABLE
const uint16_t MAT24_THETA_TABLE[] = { 
// %%TABLE Mat24_theta_table, uint16
};


/** 
  @brief Convert bit vector ``v1`` in ``GF(2)^24`` from ``vector``
  to ``vintern`` representation.
*/
// %%EXPORT p
uint32_t mat24_vect_to_vintern(uint32_t v1)
{
    return  MAT24_ENC_TABLE0[v1 & 0xff]
          ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
}


/** 
  @brief Convert bit vector ``v1`` in ``GF(2)^24`` from ``vintern``
  to ``vector`` representation.
*/
// %%EXPORT p
uint32_t mat24_vintern_to_vect(uint32_t v1)
{
    return  MAT24_DEC_TABLE0[v1 & 0xff]
           ^ MAT24_DEC_TABLE1[(v1 >> 8) & 0xff]
           ^ MAT24_DEC_TABLE2[(v1 >> 16) & 0xff];
}

/** 
  @brief Return Golay cocode element corresponding to a bit vector
  in ``GF(2)^24``.

  This amounts to reducing the vector ``v1`` (given in ``vector``
  representation) modulo the Golay code. 
  The function returns the cocode element corresponding to ``v1``
  in ``cocode`` representation.
*/
// %%EXPORT p
uint32_t mat24_vect_to_cocode(uint32_t v1)
{
    return  (MAT24_ENC_TABLE0[v1 & 0xff]
          ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff]) & 0xfff;
}

/** 
  @brief Convert Golay code element number ``v1`` to a vector in ``GF(2)^24``

  Input ``v1`` is a Golay code element in ``gcode`` representation. 
  The function returns the bit vector corresponding to ``v1``
  in ``vector`` representation.
*/
// %%EXPORT p
uint32_t mat24_gcode_to_vect(uint32_t v1)
{
    return  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff];
}

/** 
  @brief Return a vector in ``GF(2)^24`` corresponding to cocode element

  Here ``c1`` is the number of a cocode element in ``cocode`` 
  representation. One of ``2**12`` possible preimages of ``c1`` in
  ``GF(2)^24``  is returned in ``vector`` representation.
*/
// %%EXPORT p
uint32_t mat24_cocode_to_vect(uint32_t c1)
{
    return mat24_vintern_to_vect(c1);
}

/** 
  @brief Return a vector in ``GF(2)^24`` as a Golay code element.

  If the vector ``v1`` (given in ``vector`` representation) is in
  the Golay code then the function returns the number of that
  Golay code word. Thus the return value is in ``gcode``
  representation.

  If ``v1`` is not in the Golay code then the function
  returns ``(uint32_t)(-1)``.
*/
// %%EXPORT p
uint32_t mat24_vect_to_gcode(uint32_t v1)
{
    uint_fast32_t  cn =  mat24_vect_to_vintern(v1);
    return cn & 0xfff ? (uint32_t)(-1)   : cn >> 12;
}



/** 
  @brief Return a Golay code vector as an octad.

  If ``u_strict`` is even then the function acts as follows:

  If the Golay code vector ``v1`` (given in ``gcode`` representation) 
  is  an octad or a complement of an octad then the function returns 
  the number of that octad. Thus the return value is in ``octad``
  representation. Then we have ``0 <= octad(v1, strict) < 759``.

  If ``v1`` is not a (possibly complemented) octad then the 
  function returns ``(uint32_t)(-1)``.

  If ``u_strict`` is odd then the function returns ``(uint32_t)(-1)`` 
  also in case of a complemented octad ``v1``.
*/
// %%EXPORT p
uint32_t mat24_gcode_to_octad(uint32_t v1, uint32_t u_strict)
{
    uint_fast32_t y;
    u_strict = (u_strict & 1) + 0x100;
    v1 &= 0xfff;
    y = MAT24_OCT_ENC_TABLE[v1 & 0x7ff];
    if (((y ^ ((v1 >> 11) & 1)) + 2) & u_strict) return  (uint32_t)(-1);
    return (y >> 1) + 3 * ((v1 & 0x7ff) >> 3) - %{Mat24_oct_enc_offset};
}


/** 
  @brief Return a vector in ``GF(2)^24`` as an octad.

  If ``u_strict`` is even then the function acts as follows:

  If the vector ``v1`` (given in ``vector`` representation) is 
  an octad or a complement of an octad then the function returns 
  the number of that octad. Thus the return value is in ``octad``
  representation. Then we have `` 0 <= octad(v1, strict) < 759``.

  If ``v1`` is not a (possibly complemented) octad then the 
  function returns ``(uint32_t)(-1)``.

  If ``u_strict`` is odd then the function returns ``(uint32_t)(-1)`` 
  also in case of a complemented octad ``v1``.
*/
// %%EXPORT p
uint32_t mat24_vect_to_octad(uint32_t v1, uint32_t u_strict)
{
    uint_fast32_t y, err;
    u_strict = (u_strict & 1) + 0x100;
    err = MAT24_ENC_TABLE0[v1 & 0xff]
             ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
             ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
    v1 = err >> 12;
    err &= 0xfff;
    y = MAT24_OCT_ENC_TABLE[v1 & 0x7ff];
    err |=  (((y ^ ((v1 >> 11) & 1)) + 2) & u_strict);
    if (err) return  (uint32_t)(-1);
    return (y >> 1) + 3 * ((v1 & 0x7ff) >> 3) - %{Mat24_oct_enc_offset};
}


/** 
  @brief Convert an octad to a Golay code vector.

  Given an octad ``u_octad`` (in ``octad`` representation), the
  function returns the number of the corresponding Golay code
  number in ``gcode`` representation. 

  There are  759 octads. The  function returns ``(uint32_t)(-1)``
  in case  ``u_octad >= 759``.
*/
// %%EXPORT p
uint32_t mat24_octad_to_gcode(uint32_t u_octad)
{   
    return u_octad < 759 ? MAT24_OCT_DEC_TABLE[u_octad] & 0xfff 
                         : (uint32_t)(-1);
}


/** 
  @brief Convert an octad to a bit vector in ``GF(2)^24``.

  Given an octad ``u_octad`` (in ``octad`` representation), the
  function returns bit vector corresponding to that octad
  in ``vector`` representation. 

  There are  759 octads. The  function returns ``(uint32_t)(-1)``
  in case  ``u_octad >= 759``.
*/
// %%EXPORT p
uint32_t mat24_octad_to_vect(uint32_t u_octad)
{
    uint_fast32_t u;
    if (u_octad >= 759) return (uint32_t)(-1);
    u = MAT24_OCT_DEC_TABLE[u_octad] & 0xfff;
    return  MAT24_DEC_TABLE1[(u << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(u >> 4) & 0xff];
}


/*************************************************************************
*** Golay code syndomes and weights
*************************************************************************/

/** 
  @brief Return Golay code syndrome of cocode element  ``c1``.

  Here ``c1`` is a cocode element in ``cocode``  representation. 
  mat24_cocode_syndrome(c1, u_tetrad) is equivalent to 
  mat24_syndrome(mat24_cocode_to_vect(c1), u_tetrad).

  The function returns a Golay code syndrome as described in the 
  documentation of function  mat24_syndrome().   
*/
// %%EXPORT p
uint32_t mat24_cocode_syndrome(uint32_t c1, uint32_t u_tetrad)
{
        uint_fast32_t  y, syn, bad; 
        if (u_tetrad > 24) return (uint32_t)(-1L);
        bad = (u_tetrad + 8) >> 5;       // bad = (u_tetrad >= 24)
        u_tetrad -= bad;                 // change 24 to 23
        y = 0 - (((c1 >> 11) + 1) & 1);  // y = 0 if c1 is odd else -1
        bad &= y;                        // bad  &= (weight(c1) even)
        c1 ^= MAT24_RECIP_BASIS[u_tetrad & 31] & y;
            // if even: flip bit 'u_tetrad' in cocode repr. 'c1'
        y  &=  1 << u_tetrad;            // y = 1 << u_tetrad if even
        syn = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ];
        syn = (1 << (syn & 31)) | (1 << ((syn >> 5) & 31))   
                               | (1 << ((syn >> 10) & 31));
        // Now syn is the syndrome of the odd word c1. Thus syn has
        // odd parity. Bit 24 of syn is set if weight(syn) == 1.
        bad &= ((syn & (y | 0x1000000)) - 1) >> 25; 
            // bad &= weight(syn) > 1 and y & syn == 0
        syn ^= y;                        // the final syndrome
        return (syn & 0xffffff) | (0 - (bad & 1));
            // clear high bits, return syndrome of ok, else -1
}


/** 
  @brief Return Golay code syndrome of word ``v1``.

  Here ``v1`` is an arbitrary word in ``GF(2)**24`` in ``vector``
  representation. The function returns a Golay code syndrome of 
  ``v1`` (of minimum possible bit weight) as a bit vector in 
  ``vector`` representation. 

  Such a syndrome is unique if it has weight less than 4. In that
  case the unique syndrome is returned.

  If the minimum weight of the syndrome is four then the six
  possible syndroms form a partition of the the underlying set
  of 24 elements. In this case we return the syndrome of bit 
  weight four where the bit at position ``u_tetrad`` is  set.
  Therefore parameter ``u_tetrad`` must satisfy
  `` 0 <= u_tetrad <= 24``; otherwise the function fails.

  If the minimum weight of the sydrome is at most three,
  parameter ``u_tetrad`` must satisfy `` 0 <= u_tetrad < 24``; 
  otherwise the function fails.

  The function returns ``(uint32_t)(-1)`` in case of failure.
*/
// %%EXPORT p
uint32_t mat24_syndrome(uint32_t v1, uint32_t u_tetrad)
{
        uint_fast32_t as_cocode;

        as_cocode = MAT24_ENC_TABLE0[v1 & 0xff]
                  ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
                  ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
                  // This is  mat24_vect_to_vintern(v1)
        return  mat24_cocode_syndrome(as_cocode, u_tetrad);
}



/** 
  @brief Returns bit weight of Golay code word ``v1`` divided by 4

  Here ``0 <= v1 < 4096`` is the number of a Golay code word,
  i.e. ``v1`` is given in ``gcode`` representation.
*/
// %%EXPORT p
uint32_t mat24_gcode_weight(uint32_t v1)
{
   register uint_fast32_t  t = 0 - ((v1 >> 11) & 1);
   return (((MAT24_THETA_TABLE[v1 & 0x7ff] >> 12) & 7) ^ t) 
                 + (t & 7);  
}


/** 
  @brief Store bit positions of Golay code ``v1`` in array ``a_out`` 

  Here ``0 <= v1 < 4096`` is the number of a Golay code word,  i.e. 
  ``v1`` is given in ``gcode`` representation. The Golay code word 
  ``v1`` is stored in the array referred by ``a_out`` as an ordered 
  list of the positions of the bits being set in the word ``v1``.

  That array must have physical length at least 24. The function 
  returns the actual length of the returned array, which is equal 
  to the bit weight of the word ``v1``.
*/
// %%EXPORT p
uint32_t mat24_gcode_to_bit_list(uint32_t v1, uint8_t *a_out)
{
   v1 = MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff];
   return mat24_vect_to_bit_list(v1, a_out);
}

/** 
  @brief Return the minimum possible weight of the cocode vector ``c1``

  Here ``c1`` is a cocode element in ``cocode`` representation.
*/ 
// %%EXPORT p
uint32_t mat24_cocode_weight(uint32_t c1)

{
        uint_fast32_t  y, syn, w; 
        y = 0 - (((c1 >> 11) + 1) & 1);    // y = 0 if c1 is odd else -1
        c1 ^= MAT24_RECIP_BASIS[0] & y;
            // if even: flip bit 0 in cocode repr. 'c1'
        syn = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ];
        w = 3 - (((syn + 0x2000) >> 15) << 1);
           // weight of odd syndrome (syn >= 0x6000 iff weight == 1)
        w -= y;                         // weight of complete syndrome
        y &= (((syn & 31) - 1) >> 5) & 1;
           // y = 1 if bit 0 has been counted twice in syndrome
           // (syn & 31 == 0 iff bit 0 is set in syndrome)
        w -= y << 1;                    // correct if counted twice 
        return w;
}


/** 
  @brief Store Golay code syndrome of cocode word ``c1`` in an array

  Here ``c1`` is an cocode word in cocode representation. The function 
  stores the sorted  bit positions of the syndrome of ``c1`` in the 
  array referred by ``a_out`` and returns the actual length of that
  array, which is the weight of the syndrome. The array referred by 
  ``a_out`` must have physical length at least 4. 

  Such a syndrome is unique if it has weight less than 4. In that
  case the unique syndrome is returned.

  If the minimum weight of the syndrome is four then the six
  possible syndroms form a partition of the the underlying set
  of 24 elements. In this case we return the syndrome of bit 
  weight four where the bit at position ``u_tetrad`` is  set.
  Therefore parameter ``u_tetrad`` must satisfy
  `` 0 <= u_tetrad < 24``; otherwise the function fails.

  If the minimum weight of the sydrome is at most three,
  parameter ``u_tetrad`` must satisfy `` 0 <= u_tetrad < 24``; 
  otherwise the function fails.

  The function returns ``(uint32_t)(-1)`` in case of failure.
*/
// %%EXPORT p
uint32_t mat24_cocode_to_bit_list(uint32_t c1, uint32_t u_tetrad, uint8_t *a_out)
{
        uint_fast32_t  syn, bad, len, i, tmp, a[6]; 
        if (u_tetrad > 24) return (uint32_t)(-1L);
        if ((c1 & 0x800) == 0) {             // case even cocode word
            bad = u_tetrad == 24;       
            u_tetrad -= bad;                 // change 24 to 23
            c1 ^= MAT24_RECIP_BASIS[u_tetrad & 31];
                          // flip bit 'u_tetrad' in cocode repr. 'c1'
            syn = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ];
            a[3] = a[4] = a[5] = 24;      
            a[0] =  syn & 31; 
            a[1] =  (syn >> 5) & 31; 
            len = a[1] == 24 ? 2 : 4;
            a[2] =  (syn >> 10) & 31; 
            a[len-1] = u_tetrad;
            i = len - 1;
            while (i > 0 && a[i] < a[i-1]) {
                tmp = a[i]; a[i] = a[i-1]; a[i-1] = tmp;
                --i;
            }
            if (i > 0 &&  a[i] == a[i-1]) {
                 a[i-1] = a[i+1]; a[i] = a[i+2]; len -= 2;
            }
            a_out[0] = (uint8_t)a[0]; a_out[1] = (uint8_t)a[1]; 
            a_out[2] = (uint8_t)a[2]; a_out[3] = (uint8_t)a[3]; 
            return  (bad && len == 4) ? (uint32_t)(-1) : len;
        } else{                             // case odd cocode word
            syn = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ];
            a_out[0] =  (uint8_t)(syn & 31); 
            a_out[1] =  (uint8_t)((syn >> 5) & 31); 
            len = a_out[1] == 24 ? 1 : 3;            
            a_out[2] =  (uint8_t)((syn >> 10) & 31);
            a_out[3] = 24; 
            return len;
        }
}


/** 
  @brief Store a cocode word ``c1`` in array ``a_out`` as a sextet

  Here ``c1`` is an cocode word in cocode representation. That 
  cocode word must correspond to a syndrome of length four, i.e.
  the syndrome must be a tetrad. Otherwise the function fails.

  The function stores the six tetrads that make up the sextet ``c1`` 
  in ``a_out[4*i],...,a_out[4*i+3]`` for ``i = 0,...,5``. The 
  (ordered) tetrads are stored in lexical order. 

  The function returns ``(uint32_t)(-1)`` if ``c1`` has not
  minimum weight 4.
*/
// %%EXPORT p
uint32_t mat24_cocode_to_sextet(uint32_t c1, uint8_t *a_out)
{
    uint_fast32_t c2, syn, v, i;
    if (c1 & 0x800) return (uint32_t)(-1L);
    c2 =  c1 ^ MAT24_RECIP_BASIS[0];
    syn = MAT24_SYNDROME_TABLE[c2 & 0x7ff];
    if ((syn & 31) == 0) return (uint32_t)(-1L);
    a_out[0] = 0;
    a_out[1] = syn & 31; 
    a_out[2] = (syn >> 5) & 31; 
    a_out[3] = (syn >> 10) & 31; 
    v = 0xffffff;
    for (i = 4; i < 24; i += 4) {
        v ^= (1 << a_out[i-4]) ^ (1 << a_out[i-3]) 
           ^ (1 << a_out[i-2]) ^ (1 << a_out[i-1]);
        a_out[i] = mat24_def_lsbit24(v); 
        c2 =  c1 ^ MAT24_RECIP_BASIS[a_out[i]];
        syn = MAT24_SYNDROME_TABLE[c2 & 0x7ff];
        a_out[i+1] = syn & 31; 
        a_out[i+2] = (syn >> 5) & 31; 
        a_out[i+3] = (syn >> 10) & 31; 
    }
    return 0;
}



/*************************************************************************
*** Scalar product of Golay code and cocode
*************************************************************************/

/** 
  @brief Return scalar product of Golay code and cocode vector

  ``v1`` is a Golay code vector in 'gcode' representation, ``c1``
  is a cocode vector in cocode representation.

  Actually the function returns the bit parity of ``v1 & c1 & 0xfff``.
  
*/
// %%EXPORT p
uint32_t mat24_scalar_prod(uint32_t v1, uint32_t c1)
{
    v1 &= c1;
    v1 ^= v1 >> 6;  v1 ^= v1 >> 3;
    return (0x96 >> (v1 & 7)) & 1;
}



/*************************************************************************
*** Conversion from and to suboctads
*************************************************************************/
/** 
  @brief Convert even suboctad of octad  to cocode representation
  
  The function converts a suboctad ``u_sub`` (in ``suboctad`` 
  representation) of an octad ``v1`` (in ``gcode`` representation) 
  to a cocode element. It returns that cocode element in ``cocode``
  representation.

  Each octad ``v1`` has 64 even subsets, when each subset of ``v1``
  is identified with its complement in ``v1``. These subsets are 
  called suboctads. Let ``b_0, ..., b_7 `` be the elements of the 
  octad ``v1`` in natural order. Then the even subset ``(b_0 , b_i)``
  has suboctad number ``2**(i-1)`` for ``i = 1,...,6``. Combining 
  suboctads by symmetric difference corresponds to combining their 
  numbers by ``xor``. The empty subocatad has number zero. This yields 
  a one-to-one correspondence between the integers ``0,...,63`` and
  the suboctads of a fixed octad ``v1``, when identifying a suboctad 
  with its complement. 
 
  The function returns the suboctad of ``v1`` with number ``u_sub``
  in ``cocode`` representation. Octad ``v1`` must be given in 
  ``gcode`` representation. If ``v1`` is a complement 
  of an octad ``o`` the ``o`` is taken instead of ``v1``.
 
  The function fails if ``v1`` does not represent an octad.
  It returns ``(uint32_t)(-1)`` in case of failure.
*/
// %%EXPORT p
uint32_t mat24_suboctad_to_cocode(uint32_t u_sub, uint32_t v1)
{
    uint_fast32_t oct, l;
    // Let oct = vector of v1 in 'vect' representation
    oct =  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
                       ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff]; 
    // Let  l =  weight(v1)/4
    l = mat24_gcode_weight(v1);
    // Complement ``oct`` if weight(v1) == 16, 
    // abort if that weight is not 8 or 16
    if (l == 4) oct ^= 0xffffff;
    else if (l != 2) return (uint32_t)(-1);
    // Put l = parity of u_sub
    l =  (0x96 >> ((u_sub ^ (u_sub >> 3)) & 7)) & 1;  
    // Let u_sub be a vector representing the suboctad of w with No u_sub
    u_sub = l + ((u_sub & 0x3f) << 1); 
    u_sub = mat24_spread_b24(u_sub, oct);
    // Finally, convert that vector to cocode representation
    return  (MAT24_ENC_TABLE0[u_sub & 0xff]
          ^ MAT24_ENC_TABLE1[(u_sub >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(u_sub >> 16) & 0xff]) & 0xfff;
}

/** 
  @brief Convert cocode element ``c1`` to suboctad of octad ``v1``

  The function converts a cocode element ``c1`` (in ``cocode`` 
  representation) of an octad ``v1`` (in ``gcode`` representation) 
  to a suboctad. 

  This is an inverse of function mat24_suboctad_to_cocode().
  The function returns the suboctad number corresponding to the
  cocode element ``c1``, if ``v1`` is an octad and ``c1`` is an 
  even subset of ``v1``. See documentation of function 
  mat24_suboctad_to_cocode() for the numbering of the suboctads.
 
  The function fails if ``v1`` is not a octad or ``c1`` cannot be
  represented as an even subset of ``v1``. If ``v1`` is a complement 
  of an octad ``o`` the ``o`` is taken instead of ``v1``.
  The function returns ``(uint32_t)(-1)`` in case of failure.
*/

// %%EXPORT p
uint32_t mat24_cocode_to_suboctad(uint32_t c1, uint32_t v1)

{
    uint_fast32_t syn, oct, l;
    // Let oct = vector of v1 in 'vect' representation
    oct =  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
                       ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff]; 
    // Let  l =  weight(v1)/4
    l = mat24_gcode_weight(v1);
    // Complement ``oct`` if weight(v1) == 16, 
    // abort if that weight is not 8 or 16
    if (l == 4) oct ^= 0xffffff;
    else if (l != 2) return (uint32_t)(-1);
    // Abort if c1 is not even
    if (c1 & 0x800) return (uint32_t)(-1);
    // l = lsbit of oct
    l = mat24_def_lsbit24(oct);
    // compute syndrome of (odd) vector w ^ 2**l, w = gcode_to_vect(v1)
    c1 ^= MAT24_RECIP_BASIS[l];
    syn = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ];
    syn = (1 << (syn & 31)) ^ (1 << ((syn>>5) & 31))   
                               ^ (1 << ((syn>>10) & 31));
    // Abort if syndrome is not a subset of the octad oct
    if ((syn & oct) != syn) return (uint32_t)(-1);
    // Compress syndrome to suboctad number
    syn = mat24_extract_b24(syn, oct) >> 1;
    // Complement suboctad number if highest bit is set
    l = (syn >> 6) & 1;
    return (syn ^ (0-l)) & 0x3f;
}    

/** 
  @brief Return parity of halved bit weight of the even suboctad

  Here parameter ``u_sub`` is the number of a suboctad. A suboctad
  cooresponds to a subset of an octad of even parity. The function 
  returns 0 is the bit weight of that subset is divisible by four 
  and 1 otherwise.

  The numbering of suboctads is described in the documentation
  of function mat24_suboctad_to_cocode().
*/
// %%EXPORT p
uint32_t mat24_suboctad_weight(uint32_t u_sub)
{
   uint_fast32_t w = (u_sub & 0x15) + ((u_sub & 0x2a) >> 1);
   w = w + (w >> 2) + (w >> 4) + 1;
   return (w >> 1) & 1; 
}


/** 
  @brief Return scalar product of two suboctads

  The function returns the scalar product of the two suboctads 
  with the numbers ``u_sub1, u_sub2``.  
     
  Here the scalar product is the parity of the vector 
  ``u_sub1 & u_sub2`` when ``u_sub1`` and ``u_sub2`` are given as 
  subsets of an octad in vector notation.
 
  But in this functions parameters ``u_sub1, u_sub2`` are suboctad 
  numbers as documented in function mat24_suboctad_to_cocode().
*/
// %%EXPORT p
uint32_t mat24_suboctad_scalar_prod(uint32_t u_sub1, uint32_t u_sub2)
{
   uint_fast32_t wp = (0x96 >> ((u_sub1 ^ (u_sub1 >> 3)) & 7)) 
                    & (0x96 >> ((u_sub2 ^ (u_sub2 >> 3)) & 7));
   u_sub1 &= u_sub2;
   wp ^= (0x96 >> ((u_sub1 ^ (u_sub1 >> 3)) & 7));
   return wp & 1;
}


/*************************************************************************
*** Parker Loop
*************************************************************************/

/** 
  @brief Returns the theta function for the Parker loop

  Here function ``theta()`` is a quadratic function from the Golay code 
  ``C`` to the cocode ``C*``. Parameter ``v1`` of function ``theta`` 
  is a Golay code word in ``gcode`` representation. The result of 
  the ``theta`` function is returned as a Golay cocode word in 
  ``cocode`` representation.

  The cocycle of the Parker loop is given by:
 
           cocycle(v1, v2) =   mat24_scalar_prod(theta(v1), v2),
         
  where mat24_scalar_prod() computes the scalar product.

  The function evluates the lower 12 bits of ``v1``  only. Thus
  ``v1`` may also be an element of the Parker loop.
*/
// %%EXPORT p
uint32_t mat24_ploop_theta(uint32_t v1)
{
   return MAT24_THETA_TABLE[v1 & 0x7ff] & 0xfff;
}


/** 
  @brief Returns the cocycle of the Parker loop.
 
  Here parameters `v1` and `v2` are Golay code vectors in  ``gcode`` 
  representations or elements of the Parker loop, coded as in 
  function ``mat24_mul_ploop``. Then the Parker  loop product  of 
  ``v1`` and ``v2`` is given by
 
      v1 (*) v2  =  v1 ^ v2 * (-1)**cocycle(v1, v2). 
*/
// %%EXPORT p
uint32_t mat24_ploop_cocycle(uint32_t v1, uint32_t v2)
{
    uint_fast32_t s;
    s = MAT24_THETA_TABLE[v1 & 0x7ff] & v2 & 0xfff;
    s ^= s >> 6;
    s ^= s >> 3;
    s = 0x96 >> (s & 7);
    return s & 1; 
}

/** 
  @brief Returns the product of two elements of the Parker loop
 
  Here the Parker loop elements ``v1`` and ``v2`` are integers
  coded as follows:

      bit 0,...,11:   a Golay code word in ``gcode`` representation

      bit 12:         Parker loop sign

  The other bis of``v1`` and ``v2`` are ignored.
*/
// %%EXPORT p
uint32_t mat24_mul_ploop(uint32_t v1, uint32_t v2)
{

   return v1 ^ v2 ^ (mat24_ploop_cocycle(v1, v2) << 12);
}


/** 
  @brief Returns a power of an element of the Parker loop
 
  Here ``v1`` is a the Parker loop element coded as in function
  mat24_mul_ploop(). ``u_exp`` is the exponent. The function
  returns the power ``v1 ** exp`` as an element of the Parker loop.

  E.g. mat24_pow_ploop(v1, 3) is the inverse of ``v1``.
*/
// %%EXPORT p
uint32_t mat24_pow_ploop(uint32_t v1, uint32_t u_exp)
{
    return (v1 & (0 - (u_exp & 1))) 
      ^ (MAT24_THETA_TABLE[v1 & 0x7ff] & ((u_exp & 2) << 11));
}


/** 
  @brief Return commutator of Golay code words ``v1`` and ``v2``
 
  This is equal to 0 if the intersection of the bit vectors ``v1`` 
  and  ``v2`` has  bit weight 0 mod 4, and equal to 1 is that 
  intersection has bit weight 2 mod 4. Words ``v1`` and ``v2`` 
  must be given in ``gcode``  representation.

  For  Parker loop elements ``v1`` and ``v2`` (coded as in function
  ``mat24_mul_ploop``) the commutator of  ``v1`` and ``v2`` is
  equal to

         (-1) ** mat24_ploop_comm(v1, v2),

  where ``**`` denotes exponentiation.
*/
// %%EXPORT p
uint32_t mat24_ploop_comm(uint32_t v1, uint32_t v2)
{   
    uint_fast32_t r;
    r = (MAT24_THETA_TABLE[v1 & 0x7ff] & v2)
      ^ (MAT24_THETA_TABLE[v2 & 0x7ff] & v1);
    r ^= r >> 6; r ^= r >> 3;
    return (0x96 >> (r & 7)) & 1;      
} 


/** 
  @brief Return intersection of two Golay code words as cocode word.
 
  Here ``v1`` and ``v2`` are Golay code words in ``gcode`` 
  representation. The result is a cocode word returned in 
  ``cocode`` representation.
*/
// %%EXPORT p
uint32_t mat24_ploop_cap(uint32_t v1, uint32_t v2)

{
    v1 &= 0x7ff; v2 &= 0x7ff;
    return (MAT24_THETA_TABLE[v1]  ^  MAT24_THETA_TABLE[v2] 
              ^ MAT24_THETA_TABLE[v1 ^ v2]) & 0xfff ;
}

/** 
  @brief Return associator of Golay code words ``v1, v2,`` and ``v3``
 
  This is the parity of the intersection of the bit vectors ``v1, v2,`` 
  and ``v3``. So the function returns 0 or 1. Vectors ``v1, v2, v3`` 
  are in ``gcode``  representation.

  The associator of three Parker loop elements ``v1, v2, v3`` is equal 
  to

       (-1) ** mat24_ploop_assoc(v1, v2, v3) .
	   
  Here ``v1, v2, v3`` are encoded as in function mat24_mul_ploop(). 	   
*/
// %%EXPORT p
uint32_t mat24_ploop_assoc(uint32_t v1, uint32_t v2, uint32_t v3)
{
    uint_fast32_t r;
    r = (MAT24_THETA_TABLE[v1 & 0x7ff] & v3)
      ^ (MAT24_THETA_TABLE[v2 & 0x7ff] & v3)
      ^ (MAT24_THETA_TABLE[(v1 ^ v2) & 0x7ff] & v3);
    r ^= r >> 6; r ^= r >> 3;
    return (0x96 >> (r & 7)) & 1;      
}


/** 
  @brief Return cocode element that kills signs of Parker loop elements
  
  Here ``p_io`` refers to an array of ``u_len`` Parker loop elements
  are coded as in function mat24_mul_ploop(). The function tries to 
  find a cocode element that makes all these Parker loop elements 
  positive, when operating on them as a diagonal automorphism. The 
  function returns the least cocode  element in lexical order 
  satisfying that condition in the bits ``0,...,11`` of the return 
  value. For that order we assume that lower bits have higher valence. 
  If no such cocode element  exists, the function fails.
 
  We set bit 12 of the return value to indicate a failure.
 
  The array ``p_io`` is destroyed. More specifically, the first 
  ``k`` entries of that array are changed to an array of linear
  independent Parker loop elements. When these ``k`` elements are
  mapped to positive Parker loop elements, this also yields a
  solution of the original problem. If the problem cannot be 
  solved then we put ``p_io[k-1] = 0x1000``. 
 
  The function returns the value ``k`` in bits ``31,...,16``
  of the result.
*/
// %%EXPORT p
uint32_t mat24_ploop_solve(uint32_t *p_io, uint32_t u_len)
{
    uint_fast32_t col, row, nrows, mask, piv, piv_col[13], res;
    nrows = 0;
    for (col = 0; col <= 12; ++col) {
        mask = 1 << col;
        for (row = nrows; row < u_len; ++row) {
            if (p_io[row] & mask) {
                piv = p_io[row];  
                p_io[row] = p_io[nrows];
                for (row = 0; row < u_len; ++row) {
                    p_io[row] ^= piv & (0UL - ((p_io[row] >> col) & 1)); 
                } 
                p_io[nrows] = piv;
                piv_col[nrows++] = col;
                break;
            }
        }
    }
    res = 0;
    for (row = 0; row < nrows; ++row) {
        res |= ((p_io[row] >> 12) & 1) << piv_col[row];
    }
    return res + (nrows << 16);  
}



/*************************************************************************
*** Mathieu group Mat24
*************************************************************************/


/// @cond DO_NOT_DOCUMENT

// Return the same result as function mat24_syndrome(x, 24).
// But this is faster and works for vectors x with odd
// parity only.
static inline uint_fast32_t odd_syn(uint_fast32_t x) {
    x = MAT24_ENC_TABLE0[(x) & 0xff] 
      ^ MAT24_ENC_TABLE1[((x) >> 8) & 0xff]  
      ^ MAT24_ENC_TABLE2[((x) >> 16) & 0xff];
    x = MAT24_SYNDROME_TABLE[(x) & 0x7ff]; 
    return  (1 << ((x) & 31)) ^ (1 << (((x) >> 5) & 31))  
              ^ (1 << (((x) >> 10) & 31));
}

#define lsb24(x) ((uint8_t)(mat24_def_lsbit24_pwr2(x)))

/// @endcond


/** 
  @brief Complete permutation in the Mathieu group ``Mat24`` from 7 images

  This is an auxilary function for function mat24_perm_from_heptads().
  We use the terminology introduced in that function.

  The function completes the array ``p_io`` to a permutation ``p``
  in the Mathieu group ``Mat24``. On output, permutation ``p`` is 
  given as a mapping ``i -> p_io[i]`` for ``i = 0,...,23``.

  On input, the images ``p_io[i]`` must be given for 
  ``i = 0,1,2,3,4,5,8``; the other entries of ``p_io`` are ignored.

  The set ``(p_io[i], i = 0,1,2,3,4,5,8)`` must be an umbral heptad 
  with distiguished element ``p_io[8]``. Then the mapping
  ``i -> p_io[i], i = 0,1,2,3,4,5,8`` is a feasible mapping between 
  umbral heptads; it extends to a unique permutation in ``Mat24``.
  Note that ``8`` is the distingished element of the umbral heptad
  ``(0,1,2,3,4,5,8)``. 

  The function returns 0 if the mapping given on input can be
  extended to an element of ``Mat24``, and a nonzero value
  otherwise.

  Implementation idea:

  We choose pentads, i.e. subsets of size 5 of the set ``(0,....,23)``
  that consist of known values ``p_io[i]``. We calculate the syndromes
  of such pentads, which are triads, i.e. sets of size three. 
  Calculating the syndromes of the preimages of these pentads we obtain 
  mappings between triads. Intersecting triads in a suitable way we 
  obtain mappings between singletons, and hence peviously unknown 
  images of elements of the set ``(0,....,23)``.
*/

// %%EXPORT p
uint32_t mat24_perm_complete_heptad(uint8_t *p_io)
{
    // This implementation is (almost) a copy of the 
    // implementation of the corresponding python function
    // mmgroup.dev.mat24.mat24heptad.mat24_complete_heptad().
    uint_fast32_t  err, s1, s5, s015, s3, s4, s8, s01234; 
    uint_fast32_t  s567, s67, s9AB, s9CD, s9, s6GH, s6;
    uint_fast32_t  sACE, sD, sFGI, sG, sFJK, sJLM, sALN;

    err = ((p_io[0] + 8) | (p_io[1] + 8) | (p_io[2] + 8) | 
      (p_io[3] + 8) | (p_io[4] + 8) | (p_io[5] + 8) | (p_io[8] + 8));
    err &= (0 - 0x20);
    s1 = 1 << p_io[1]; 
    s5 = 1 << p_io[5];
    s015 = (1 << p_io[0]) ^ s1 ^ s5;
    s3 = 1 << p_io[3]; 
    s4 = 1 << p_io[4]; 
    s8 = 1 << p_io[8];
    s01234 = s015 ^ s5 ^ (1 << p_io[2]) ^ s3 ^ s4;
    // if err == 0 then 0 <= s01234 < 0x1000000 has odd parity
    // octad = [0, 1, 2, 3, 4, 5, 6, 7]
    s567 = odd_syn(s01234);
    err |= (s01234) & s567;
    // if err == 0 then entries [0,1,2,3,4,6] are in an octad
    err |= (s01234 | s567) & s8;
    // if err == 0 then entry 8 is not in that octad
    err |= s5 ^ (s5 & s567);
    s67 = s567 & ~s5;
    // octad = [0, 1, 2, 3, 8, 9, 10, 11]
    s9AB = odd_syn(s01234 ^ s4 ^ s8);
    // octad = [0, 1, 4, 5, 8, 9, 12, 13]
    s9CD = odd_syn(s015 ^ s4 ^ s8);
    s9 = s9AB & s9CD;
    p_io[9] = lsb24(s9);
    // octad [1, 3, 5, 6, 8, 9, 16, 17]
    s6GH = odd_syn(s1 ^ s3 ^  s5 ^ s8 ^ s9);
    s6 = s67 &  s6GH;
    p_io[6] = lsb24(s6);
    p_io[7] = lsb24(s67 & ~s6GH);
    // still needed: 
    //   err, s1, s015, s3, s8, s01234, s9AB, s9CD, s9, s6GH, s6
    // octad [0, 2, 4, 6, 8, 10, 12, 14]
    sACE = odd_syn(s01234 ^ s1 ^ s3 ^ s6 ^ s8);
    p_io[10] = lsb24(s9AB & sACE);
    p_io[11] = lsb24(s9AB & ~sACE & ~s9);
    p_io[12] = lsb24(s9CD & sACE);
    sD = s9CD & ~sACE & ~s9;
    p_io[13] = lsb24(sD);
    p_io[14] = lsb24(sACE & ~s9AB & ~s9CD);
    // still needed: 
    //   err, s1, s015, s3, s8, s6GH, s6, sACE, sD
    // octad [0, 1, 5, 6, 13, 15, 16, 18]
    sFGI = odd_syn(s015 ^ s6 ^ sD);
    sG = s6GH & sFGI;
    p_io[16] = lsb24(sG);
    p_io[17] = lsb24(s6GH & ~s6 & ~sFGI);
    // octad [0, 1, 3, 5, 8, 15, 19, 20]
    sFJK = odd_syn(s015 ^ s3 ^ s8);
    p_io[15] = lsb24(sFGI & sFJK);
    p_io[18] = lsb24(sFGI & ~sG & ~sFJK);
    // octad [0, 3, 5, 6, 16, 19, 21, 22]
    sJLM = odd_syn(s015 ^ s1 ^ s3 ^ s6 ^ sG);
    p_io[19] = lsb24(sFJK & sJLM);
    p_io[20] = lsb24(sFJK & ~sFGI & ~sJLM);
    // octad [0, 1, 5, 6, 8, 10, 21, 23]
    sALN = odd_syn(s015 ^ s6 ^ s8); 
    p_io[21] = lsb24(sALN & sJLM);
    p_io[22] = lsb24(sJLM & ~sALN & ~sFJK);
    p_io[23] = lsb24(sALN & ~sACE & ~sJLM);
    return err;
}


/**
  @brief Check if permutation is in in the Mathieu group ``Mat24``.

  The function checks the mapping ``i -> p1[i]``, ``i = 0,...,23``. 

  It returns zero if that mapping is a permutation in ``Mat24`` 
  and a nonzero value otherwise.

  The implementation uses function mat24_perm_complete_heptad().
*/
// %%EXPORT p
uint32_t mat24_perm_check(uint8_t *p1)
{
    uint8_t p2[24];
    memcpy(p2, p1, 9*sizeof(uint8_t));
    return mat24_perm_complete_heptad(p2) || memcmp(p1, p2, 24);
}        

/**
  @brief Complete an octad given by 6 elements of it. 

  Given entries ``p_io[i], i = 0,1,2,3,4,5``, we calculate values
  ``p_io[6], p_io[7]`` such that the set ``(p_io[i], 0 <= i < 8)`` 
  is an octad. Furthermore, we order the values ``p_io[6], p_io[7]`` 
  in such way that the mapping ``i -> p_io[i]`` may be extended to a 
  permutation in the grpup ``Mat24``. This restrtiction determines
  the order uniquely. Note that the set ``0,...,7`` is an octad,
  which is called the standard octad.

  The set ``p_io[i], i = 0,1,2,3,4,5`` must be a subset of an
  octad; otherwise the function fails. The function returns 0
  in case of success and ``(uint32_t)(-1)`` in case of failure.

  The implementation is a simplified version of function
  mat24_perm_complete_heptad().
*/
// %%EXPORT p
uint32_t mat24_perm_complete_octad(uint8_t *p_io)
{
    uint_fast32_t  err, s1, s5, s015, s3, s4, s8, s01234; 
    uint_fast32_t  s567, s67, s9AB, s9CD, s9, s6GH, s6;

    err = ((p_io[0] + 8) | (p_io[1] + 8) | (p_io[2] + 8) | 
      (p_io[3] + 8) | (p_io[4] + 8) | (p_io[5] + 8));
    err &= (0 - 0x20);
    s1 = 1 << p_io[1]; 
    s5 = 1 << p_io[5];
    s015 = (1 << p_io[0]) ^ s1 ^ s5;
    s3 = 1 << p_io[3]; 
    s4 = 1 << p_io[4]; 
    s01234 = s015 ^ s5 ^ (1 << p_io[2]) ^ s3 ^ s4;
    // if err == 0 then 0 <= s01234 < 0x1000000 has odd parity
    // octad = [0, 1, 2, 3, 4, 5, 6, 7]
    s567 = odd_syn(s01234);
    // Put s8 = 1 << u, with u the smallest entry not in the octad
    s8 = 0xffffff ^ (s01234 | s567);
    s8 = s8 & (0 - s8);   
    err |= (s01234) & s567;
    // if err == 0 then entries [0,1,2,3,4,6] are in an octad
    err |= s5 ^ (s5 & s567);
    s67 = s567 & ~s5;
    // octad = [0, 1, 2, 3, 8, 9, 10, 11]
    s9AB = odd_syn(s01234 ^ s4 ^ s8);
    // octad = [0, 1, 4, 5, 8, 9, 12, 13]
    s9CD = odd_syn(s015 ^ s4 ^ s8);
    s9 = s9AB & s9CD;
    // octad [1, 3, 5, 6, 8, 9, 16, 17]
    s6GH = odd_syn(s1 ^ s3 ^  s5 ^ s8 ^ s9);
    s6 = s67 &  s6GH;
    p_io[6] = lsb24(s6);
    p_io[7] = lsb24(s67 & ~s6GH);
    return err ? (0 - 1) : 0;
}



/** 
  @brief Complete a mapping to a permutation in the Mathieu group ``Mat24``

  A permutation in the  Mathieu group ``Mat24`` is a mapping  from the
  set ``(0,...,23)`` to itself.  The function completes the  mapping 
  ``h1[i] -> h2[i]``, ``0 <= i < 7``, ``0 <= h1[i], h2[i] < 24`` to
  a permutation ``i -> p_out[i]``, ``0 <= i < 24`` in the 
  group ``Mat24``. The result is returned in the array ``p_out[i]``.

  The sets ``h1[i], 0 <= i < 7`` and ``h2[i], 0 <= i < 7`` must be
  umbral heptads, and the mapping from ``h1`` to ``h2`` must be
  feasible.

  An umbral heptad is a set of seven elements of the set ``(0,...,23)``
  which is not a subset of an octad. The syndrome of an umbral heptad, 
  i.e. the smallest set equivalent to the heptad  modulo the Golay code, 
  is a singleton containing exactly one element of the umbral heptad. 
  That element is called the distiguished element of the heptad. 
  A feasible mapping from an umbral heptad to another umbral heptad is
  a mapping that maps the distiguished element of the first heptad to
  the distiguished element of the second heptad.

  It can be shown that a feasible mapping from an umbral heptad to 
  another umbral heptad extends to a unique element of the Mathieu 
  group. 

  The function returns 0 if the mapping ``h1[i] -> h2[i]`` can be
  extended to an element of ``Mat24`` and ``(uint32_t)(-1)``
  otherwise.

  The implementation uses function mat24_perm_complete_heptad().
*/
// %%EXPORT p
uint32_t mat24_perm_from_heptads(uint8_t *h1, uint8_t *h2, uint8_t *p_out)
{
    uint8_t p1[24], p2[24];
    uint_fast32_t v, y, i;
 
    // First find the special element v of h1 not contained in the octad
    v = 0;
    for (i = 0; i < 7; ++i)  v |= 1 << (h1[i] & 31);

    // Put y = mat24_syndrome(v).
    y = MAT24_ENC_TABLE0[v & 0xff]
           ^ MAT24_ENC_TABLE1[(v >> 8) & 0xff]
           ^ MAT24_ENC_TABLE2[(v >> 16) & 0xff];
    y = MAT24_SYNDROME_TABLE[y & 0x7ff];
    y = (1 << (y & 31)) ^ (1 << ((y >> 5) & 31)) 
                              ^ (1 << ((y >> 10) & 31));  
    
    // Put v = lsbit(v & y). Then v is the special element of h1
    v &= y; 
    v =  mat24_def_lsbit24(v); 
  
    // Find position y of element v in h1
    y = 0; 
    for (i = 0; i < 7; ++i)   y |= ((h1[i] != v) - 1) & i;

    // Copy special element of h1 to position 8 of p1 and copy the other
    // elements of h1 to positions 0,...,6. Copy h2 similarly to p2
    memcpy(p1, h1, 7*sizeof(uint8_t));
    memcpy(p2, h2, 7*sizeof(uint8_t));
    p1[8] = p1[y];   p1[y] = p1[6];
    p2[8] = p2[y];   p2[y] = p2[6];

    // Complete p1 and p2 from heptad. Return error if any completion fails
    if (mat24_perm_complete_heptad(p1) |
          mat24_perm_complete_heptad(p2)) return (uint32_t)(-1);

    //  If success, put p = p1**(-1) * p2
    for (i = 0; i < 24; ++i)  p_out[p1[i]] = p2[i];
    return 0;
}        




/// @cond DO_NOT_DOCUMENT 

static inline void insertsort_i8(uint8_t *a1, uint8_t *a2, int32_t n)
// Sort the array ``a1`` of length ``n``.
// Perform the same permutation on the array ``a2`` as on ``a1``
{
    int_fast32_t i, j;
    for (i = 1; i < n; i += 1) {
        uint_fast8_t temp1 = a1[i], temp2 = a2[i];
        for (j = i; j >= 1 && a1[j - 1] > temp1; --j) {
            a1[j] = a1[j - 1]; a2[j] = a2[j - 1];
        }
        a1[j] = temp1;  a2[j] = temp2;
    }
}
/// @endcond



/** 
  @brief Complete a mapping to a permutation in the Mathieu group ``Mat24``

  A permutation in the  Mathieu group ``Mat24`` is a mapping  from the
  set ``(0,...,23)`` to itself.  The function tries to complete the
  mapping ``h1[i] -> h2[i]``, ``0 <= i < n``, ``0 <= h1[i], h2[i] < 24``
  to a permutation ``i -> p_out[i]``, ``0 <= i < 24`` in the Mathieu
  group ``Mat24``. In case of success, such a permutation is stored in
  the array ``p_out``.

  The function returns

  -1 if the mapping ``h1[i] -> h2[i]`` does not extend to a legal
  permutation of the numbers 0,...,23. Note that duplicate entries
  in ``h1`` or ``h2`` are illegal.

  0  if no such permutation exists in the Mathieu group ``Mat24``.

  1  if the mapping ``h1[i] -> h2[i]`` extends to a unique permutation
  in ``Mat24``.

  2 if if the mapping ``h1[i] -> h2[i]`` can be completed to several
  permutations in ``Mat24``, and not all entries ``h1[i]`` can be
  covered by an octad. This may happen in case ``n = 6`` only.

  3 if if the mapping ``h1[i] -> h2[i]`` can be completed to several
  permutations in ``Mat24``, and all entries ``h1[i]`` can be
  covered by an octad.

  If the return value is greater then zero then a suitable permutation
  in ``Mat24`` is returned in the array referred by ``p_out``.
  The returned permutation depends on the mapping ``h1 -> h2`` only,
  regardless of the order of the entries in ``h1``.

  Caution:

  Some input mappings allow several output permutations. Changing the
  implementation of this function such that the same input leads to
  a different output permutation destroys the interoperability between
  different versions of the project!!
*/
// %%EXPORT p
uint32_t mat24_perm_from_map(uint8_t *h1, uint8_t *h2, uint32_t n, uint8_t *p_out)
{
    uint_fast32_t err, bm1, bm2, i, o1, o2, i8, i16;
    uint8_t p1[32], p2[32], t;
    int32_t res;

    // Check for errors. We reject duplicate entries in any of the 
    // arrays ``h1`` or ``h2``, and also enries >= 24.
    // Compute the bitmap of the entries in ``h1`` in ``bm1``,
    // and the bitmap of the entries in ``h2`` in ``bm2``.
    err = 0 - (n > 24);
    bm1 = bm2 = 0;
    if (err == 0) for (i = 0; i < n; ++i) {
        err |= (h1[i] + 8) | (h2[i] + 8);
        bm1 |= 1 << h1[i]; 
        bm2 |= 1 << h2[i];
    }
    if (err & (0-32) || mat24_bw24(bm1) != n || mat24_bw24(bm2) != n) {
        for (i = 0; i < 24; ++i) p_out[i] = 24;
        return (uint32_t)(-1); 
    }
    
    // Copy ``h1`` to ``p1`` and ``h2`` to ``p2``. In case ``n < 9``
    // we sort the copy ``p1`` of ``h1`` and permute ``p2``
    // correspondingly, so that the permutation depends on the 
    // mapping ``h1 -> h2`` only. In case ``n >= 9`` there is at
    // most one feasible permutation in ``Mat24``.
    // In case ``n < 5`` we append entries (with lowest possible 
    // values in natural order) to  ``p1`` and ``p2`` so that both 
    // lists will have length at least 5.  
    if (n < 5) {
        mat24_vect_to_bit_list(bm1, p1);
        mat24_vect_to_bit_list(bm2, p2);
    }
    for (i = 0; i < n; ++i) {
        p1[i] = h1[i];
        p2[i] = h2[i];
    }
    if (n < 9) insertsort_i8(p1, p2, n);

    // Store the bit vectors containing the first five entries
    // of ``p1`` in ``bm1``.
    bm1 = bm2 = 0;
    for (i = 0; i < 5; ++i)  bm1 |= 1 << p1[i]; 
    for (i = 0; i < 5; ++i)  bm2 |= 1 << p2[i]; 

    // Store the (unique) octads containing the first five entries 
    // of ``p1`` and ``p2`` in ``bm1`` and ``bm2``, respectively.
    o1 = bm1 | mat24_syndrome(bm1, 0);
    o2 = bm2 | mat24_syndrome(bm2, 0);

    // Try to find an index ``i8 >= 5`` such that ``p1[i8]`` is in
    // the octad ``o1``. Try to find an index ``i16 >= 5`` such 
    // that ``p1[i16]`` is not in the octad ``o1``.
    // Index ``i8 == 24`` means 'no entry found'.
    // Index ``i16 == 25 means`` 'no entry found'.
    // If no entry has ben found the we will later put some entry
    // into  ``p1[i8]`` or ``p1[i16]``.
    i8 = 24;  // This is a rather bad index
    i16 = 25;  // This is a rather bad index
    for (i = 5; i < n; ++i) {
        if ((1 << p1[i]) & o1) i8 = (i8 == 24) ? i : i8;
        else i16 = (i16 == 25) ? i : i16;
    }

    // Compute return value (in case of success) from i8 and i16
    if (i16 == 25) res = 3; // everything is in the octad ``o1``.
    else res = 1 + (i8 == 24 && n < 7);
       
    // If no index ``i8`` found then:
    //    if n < 7 then take entries from the syndromes of 
    //    the first five entries of ``p1`` and ``p2``;
    //    otherwise just put ``i8 = 5, i16 = 6``.
    if (i8 == 24) {
        if (n < 7)  {
            bm1 ^= o1;  bm2 ^= o2;  // compute symdromes
            p1[24] = mat24_def_lsbit24(bm1);
            p2[24] = mat24_def_lsbit24(bm2);
        } else {
            i8 = 5; i16 = 6;
        }
    }

    // If no index ``i16`` found then take entries from the 
    // complements of the octads  ``o1`` and o2.
    if (i16 == 25) {
        o1 = ~o1;  o2 = ~o2; // complement octads o1 and o2
        p1[25] =  mat24_def_lsbit24(o1);
        p2[25] =  mat24_def_lsbit24(o2);
    }
    // Copy entries at positions ``i8`` and ``i16`` 
    // of ``h1`` and ``h2`` to positions 5 and 6.
    t = p1[i16]; p1[5] = p1[i8]; p1[6] = t;
    t = p2[i16]; p2[5] = p2[i8]; p2[6] = t;

    // Compute ``p_out`` from ``p1[0,...,6]`` and ``p2[0,...,6]``
    // Return 0 if this fails
    if (mat24_perm_from_heptads(p1, p2, p_out)) {
        // For debugging
        for (i = 0; i < 8; ++i) {
            p_out[i] = p1[i]; p_out[i+8] = p2[i];
        }
        p_out[16] = (uint8_t)i8;  p_out[16] = (uint8_t)i16;         
        p_out[18] = p1[24]; p_out[19] = p1[25];
        p_out[20] = p2[24]; p_out[21] = p2[25];
        p_out[22] = 0xca; p_out[23] = 0xfe;
        return 0;
    }    
 
    // Check that permutation ``p_out`` really maps ``h1`` to ``h2``.
    // Return 0 if this check fails.
    err = 0;
    for (i = 0; i < n; ++i) err |= p_out[h1[i]] ^ h2[i];
    if (err)  return 0;

    // Otherwise we are successful and return ``res``.
    return res;    
}



/// @cond DO_NOT_DOCUMENT
#define  STD_OCTAD %{MAT24_STD_OCTAD}
/// @endcond

/**
  @brief Compute permutation in the Mathieu group ``Mat24`` from its number

  The Mathieu group has order ``244823040``. We assign numbers
  ``0 <= n < 244823040`` to the elements of ``Mat24``, with
  ``0`` the number of the neutral element. This is just a 
  convenient way to refer to an element of ``Mat24``.  The actual 
  numbering is not part of the public interface.

  The function calculates the permutation with the number ``u_m24``
  and stores it in the array ``p_out`` as a mapping
  ``i -> p_out[i]``. ``0 <= u_m24 < 244823040`` must hold;
  otherwise the function fails.

  The function returns 0 in case of success and ``(uint32_t)(-1)``
  in case of failure. 

  Implementation idea:

  Internally we represent the permutation number in mixed radix
  base, where one digit refers to the octad  which is the image of
  the standard octad. All octads are stored in an internal table.
  Once having estblished a mapping from the standard octad to another
  octad, is suffices to work in the stabilizer of that octad. That
  stabilizer is a semidirect product of the alternating group of 8
  elements, and an elementary Abelian group of order 16 that acts 
  regularly on the 16 elements not in the octad. So working in that 
  stabilizer is easy; here we use function 
  mat24_perm_complete_heptad().  
*/
// %%EXPORT p
uint32_t mat24_m24num_to_perm(uint32_t u_m24, uint8_t *p_out)
{
    uint_fast32_t oct, i, j, k = u_m24, k1;
    uint8_t p1[32], j8;
  
    // Let k be the input u_m24
    // Integer 0 <= k < 244823040 is evaluated in mixed-radix with bases
    // 759, 8, 7, 6, 5, 4, 3, 16, with valence decreasing from left to right. 
    // In the sequel these digits of k are named:
    //
    //   oct  k_0  k_1  k_2  k_3  k_4  k_5   k'
    //   759   8    7    6    5    4    3    16 

    oct =  k/322560;            // number of image of standard octad 0..7   
    if (oct >= 759) return (uint32_t)(-1); // check if input k is correct 
    k -= 322560 * oct;  // remove digit 'oct' from input k
    oct -= 759 - STD_OCTAD;   // Manipulate oct so that input oct=0
    oct += (oct >> 12) & 759;   //   corresponds to the standard octad 
    oct = mat24_octad_to_vect(oct); // get bit vector for octad

    // p1[0..7]  will be the sorted entries of the octad oct.
    // p1[8..23] will be the sorted remaining entries. 
    // This trick is documented in function mat24_vect_to_bit_list.
    oct <<= 3; j = 0x8;
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = oct & 8;
        p1[(j >> o) & 0x1f] = (uint8_t)i;
        j += 1 << o;
        oct >>= 1;
    }

    // Let p1[8] be the k'-th smallest entry outside octad  oct,
    // where 0 < k' < 16 is the lowest digit of k.
    p1[8] = p1[8 + (k & 15)]; 

    // Format k such that original k/8 is at bit positions 28..30 
    k >>= 4;
    k *= (1 << 28) / 2520 + 1;

    // For i = 0,...,5: exchange element at pos. i with element 
    //                 at pos i + k_i, where 0 <= k_i < 8 - i. 

    // %%FOR i in range(6)
    k1 = %{i} + (k >> 28);  // this is k[%{i}]
        j8 = p1[%{i}];  p1[%{i}] = p1[k1]; p1[k1] = j8; 
        k = (k & 0xfffffff) * %{int:7-i};  // remove digit k_%{i} from k
    // %%END FOR

    // Now entries at pos. 0,1,2,3,4,5,8 are valid. use
    // mat24_perm_complete_heptad() to compute the remaining entries
    mat24_perm_complete_heptad(p1);
    memcpy(p_out, p1, 24 * sizeof(uint8_t));
    return 0;
}







/**
  @brief Compute number of a permutation in the Mathieu group ``Mat24``

  This is the inverse of function mat24_m24num_to_perm(). 

  Given a permutation ``i -> p1[i], 0 <= i < 24``, the function
  returns the number ``n`` of that permutation. We have 
  ``0 <= n < 244823040``, as described in function 
  ``mat24_int_to_perm``.

  The function returns garbage if ``p1`` is not a valid permutation
  in ``Mat24``. One may use function mat24_perm_check() to check
  if permutation ``p1`` is in ``Mat24``.

  Essentially, the implementation just reverses the operations
  in function mat24_int_to_perm().
*/
// %%EXPORT p
uint32_t mat24_perm_to_m24num(uint8_t  *p1)
// (without any indication of failure) if p1 is not in Mat24.
{
    uint_fast32_t oct, i, j, res;
    uint_fast8_t p2[32], q[8], q_inv[8], j8;

    // let oct be the octad formed by p1[0],...,p1[7]
    oct = (1 << p1[0]) | (1 << p1[1]) | (1 << p1[2]) | (1 << p1[3]) 
        | (1 << p1[4]) | (1 << p1[5]) | (1 << p1[6]) | (1 << p1[7]);

    // put res = mat24_vect_to_octad(oct)
    res = MAT24_ENC_TABLE0[oct & 0xff]
          ^ MAT24_ENC_TABLE1[(oct >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(oct >> 16) & 0xff];
    res =  mat24_gcode_to_octad(res >> 12, 1) & 0xfff;
    // put res = (res - STD_OCTAD) mod 759
    res -=  STD_OCTAD;
    res += (res >> 12) & 759;

    oct <<= 3; j = 0;
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = oct & 8;
        p2[i] = (j >> o) & 0x1f;
        j += 1 << o;
        oct >>= 1;
    }

    // %%FOR i in range(8)
    j8 = p2[p1[%{i}] & 0x1f] & 7;
    q[j8] = %{i};
    q_inv[%{i}] = j8;
    // %%END FOR

    // %%FOR i in range(6)
    j8 = q_inv[%{i}];
    q_inv[q[%{i}]] = q_inv[q[j8]];
    q[j8] = q[%{i}];
    res = res * %{int:8-i} + j8 - %{i};
    // %%END FOR

    return  16 * res + p2[p1[8] & 0x1f];
}

            


/**
  @brief Convert permutation in the Mathieu group ``Mat24`` to bit matrix

  The input of the function is the permutation ``p: i -> p1[i]``,
  ``0 <= i < 24`` which must be in the Mathieu group ``Mat24``.

  The function computes a ``12 times 12`` bit matrix ``m``, acting 
  on  a Golay code vector ``v`` (in ``gcode`` representation) by right 
  multiplication. Then we have ``v * m = p(v)``. Bit ``m[i,j]`` is
  stored in bit ``j`` of the the integer ``m_out[i]``.

  Output ``m_out[i], 0 <= i < 12`` contains garbage if ``p`` is not
  in ``Mat24``.

  Implementation idea:

  In the standard basis of ``GF(2)**24``, that operation corresponds
  to a permutation. We have precomputed a matrix converting that
  standard basis to an internal basis, where Golay code words are
  visible, and also the inverse of that matrix. Thus the operation
  is just an (optimized) sequence of matrix multiplications.
*/
// %%EXPORT p
void mat24_perm_to_matrix(uint8_t  *p1, uint32_t *m_out)
{
   int i;
   uint32_t a[24]; 
   for (i=0; i<24; ++i) a[i] = MAT24_RECIP_BASIS[p1[i] & 0x1f] >> 12;
   // %%BITMATMUL Mat24_basis[12:23], uint32_t, a, m_out   
   m_out[11] = 0x800;
}



/**
  @brief Convert bit matrix to permutation in the Mathieu group ``Mat24``

  This is the inverse of function mat24_perm_to_matrix()

  The input ``m1`` of the function is a bit matrix that maps
  a Golay code word ``v`` to ``p(v) = v * m1``, as described in
  function mat24_perm_to_matrix().

  The function computes the permutation ``p: i -> p_out[i]``, 
  ``0 <= i < 24``, from that matrix and stores the result in
  the output vector ``p_out`` of length 24.

  Output ``p_out[i], 0 <= i < 24`` contains garbage if ``m1`` is not
  bit matrix corresponding to an element of ``mat24``.

  Implementation idea:

  We could have reversed the operation of function 
  mat24_perm_to_matrix(), but the following implememtation is
  faster:

  Converting rows of matrix ``m1`` from ``gcode`` to ``standard``
  representation yields the images of some Golay code words as bit
  vectors. Intersecting these bit vectors in a suitable way yields
  the images of singletons and hence the requestend permutation.
*/
// %%EXPORT p
void mat24_matrix_to_perm(uint32_t *m1, uint8_t *p_out)
{
   // %%MAT24_MATRIX_TO_PERM   m1, p_out
}

/**
  @brief Complete bit matrix for Mathieu group ``Mat24`` from submatrix

  Let the input ``m1`` of the function be a 12 times 12 bit matrix
  that maps  a Golay code word ``v`` to ``p(v) = v * m1``, as 
  described in function ``mat24_perm_to_matrix()``.

  There are cases where the first 11 rows and columns of ``m1``
  can be deduced from an external source, but the last row and 
  column is unknown. This means the operation of an element of
  ``Mat24`` on the Golay code is know modulo the code word 
  ``Omega = (1,...,1)`` only. This function completes such an 
  11 times 11 bit matrix to a 12 times 12 matrix in place.
*/
// %%EXPORT p
void mat24_matrix_from_mod_omega(uint32_t *m1)
{
    uint32_t i, weights = %{hex:Mat24_basis_weights_8} << 11;
    // Let b[i] be the i-th basis vector of the Golay code and w[i] 
    // the weight of b[i]. Bit i + 11 of ``weights`` is equal to bit  
    // 3 of ``w[i]``. Bit 3 of the bit weight of the image ``m1[i]``  
    // of b[i] is obtained from table MAT24_THETA_TABLE. Adding
    // ``Omega`` to the Golay code word ``m[i]`` flips both, bit 3 
    // of ``w[i]``, and bit 11 of ``m[i]``. So we can adjust ``m[i]``.

    m1[11] &= ~0xfff;   // m1[11] is always equal to Omega
    for (i = 0; i < 12; ++i) {
        m1[i] ^= ((MAT24_THETA_TABLE[m1[i] & 0x7ff] >> 2) 
                  ^ (weights >> i)) & 0x800;
    }
}


/*************************************************************************
*** Mathieu group M24: Mapping a dodecad
*************************************************************************/
/**
  @brief Compute a (unique) heptad from a dodecad.

  This is a (rather technical) auxiliary function for function 
 ``mat24_perm_from_dodecads``

  Let ``d1`` be a dodecad as in function mat24_perm_from_dodecads().

  There is a unique umbral heptad ``h``, as defined in the documentation
  of function mat24_perm_from_heptads(), satisfying the properties 
  described below.
   
  The function evaluates the first 9 elements ``d1[i], 0 <= i < 9``. 
  It fails if these elements are not a subset of a dodecad or not 
  pairwise disjoint.
  
  The function returns 0 in case of success and ``(uint32_t)(-1)``
  in case of failure.
  
  Properties of heptad ``h``:
  
  ``h`` contains ``d1[i]`` for ``0 <= i < 5`` and also the unique 
  element ``h_5`` in the intersection  of ``d1`` and the syndrome 
  ``S5`` of the set ``(d1[i], 0 <= i < 5)``.
  
  Let ``S5 = (h_5, h_6, h_7)`` such that ``Mat24`` contains a
  mapping that maps ``i`` to ``d1[i]`` for ``i < 5`` and ``i`` to
  ``h_i`` for ``i = 5, 6, 7``. This determines ``h_6``  uniquely. 
  Then ``h_6`` is not in the dodecad ``d1``. Let ``T`` be the
  tetrad containing  the set ``(d1[0], d1[1], d1[2], h_6)``. 
  Tetrad ``T`` contains exactly one set ``U`` intersecting ``d1`` 
  in 3  elements disjoint to ``(d1[i], 0 <= i < 5)``.  Then 
  heptad ``h`` contains the element ``d_7`` of the singleton 
  ``U \ d1`` as ts  distinguished element.

  The function puts ``h_out[i] = d1[i]`` for ``0 <= i < 5`` and
  ``h_out[5] = h_5, h_out[6] = d_7.``
*/
static uint32_t dodecad_to_heptad(uint8_t *d1, uint8_t *h_out)
{
    uint_fast32_t s5, rem, all_12, syn, t, i;
    uint8_t a[8];
    uint8_t sextet[24];
    syn = s5 = (1 << d1[0]) ^ (1 << d1[1]) ^ (1 << d1[2]) 
         ^ (1 << d1[3]) ^ (1 << d1[4]);
    syn = odd_syn(syn);
    t = rem = s5 ^ (1 << d1[5]) ^ (1 << d1[6]) 
         ^ (1 << d1[7]) ^ (1 << d1[8]);
    t = odd_syn(t);
    all_12 = t ^ rem;
    if (mat24_bw24(all_12) != 12) return (uint32_t)(-1);
    h_out[0] = a[0] = d1[0]; h_out[1] = a[1] = d1[1]; 
    h_out[2] = a[2] = d1[2]; h_out[3] = a[3] = d1[3];  
    h_out[4] = a[4] = d1[4]; 
    t = syn & all_12;
    h_out[5] = a[5] = mat24_def_lsbit24(t);
    if (mat24_perm_complete_octad(a)) return (uint32_t)(-1);
    t = (1 << a[0]) ^ (1 << a[1]) ^ (1 << a[2]) ^ (1 << a[6]); 
    t = MAT24_ENC_TABLE0[(t) & 0xff] 
           ^ MAT24_ENC_TABLE1[((t) >> 8) & 0xff]  
           ^ MAT24_ENC_TABLE2[((t) >> 16) & 0xff];
    if (mat24_cocode_to_sextet(t, sextet)) return (uint32_t)(-1);
    rem = ~(all_12 | syn);
    for (i = 0; i < 24; i += 4) {
        t = ((1 << sextet[i]) ^ (1 << sextet[i+1]) 
          ^ (1 << sextet[i+2]) ^ (1 << sextet[i+3])) & rem;
        if (t != 0 && (t & (t-1)) == 0) {
            h_out[6] = mat24_def_lsbit24_pwr2(t);
            return 0;
        }        
    }
    return (uint32_t)(0-1);
}      


/**
  @brief Find permutation in ``Mat24`` mapping one dodecad to another

  A dodecad is a word of the Golay code of weight 12. Given two dodecads
  ``d1, d2``, and five elements ``d1[0],...,d1[4]`` of ``d1``, and also
  five elements ``d2[0],...,d2[4]`` of ``d2``, there is a unique
  permutation ``p`` in ``Mat24`` with the following properties:

         d1     is mapped to   d2  ,

         d1[i]  is mapped to   d2[i]  for  0 <= i < 5 .
  
  On input the function  takes two dodecads ``d1, d2`` as arrays
  of integers, and it computes a permutation ``p: i -> p_out[i]``
  satisfying the properies given above. In case of success it stores
  ``p`` in the array ``p_out``. Only the first 9 elements
  ``d1[i], d2[i], 0 <= i < 9`` of ``d1`` and ``d2`` are evalutated.
  There is at most one dodecad containing ``d1[i], 0 <= i < 9`` and
  at most one dodecad containing ``d2[i], 0 <= i < 9``, assuming
  ``d1[i] != d1[j]``  and  ``d2[i] != d2[j]`` for ``i != j``.

  The function fails if the evaluated entries of ``d1`` or of ``d2``
  are not a subset of a dodecad or not pairwise disjoint.
  
  The function returns 0 in case of success and ``(uint32_t)(-1)``
  in case of failure.

  The implementation calls function dodecad_to_heptad() for
  contructing (unique) heptads ``h1`` and ``h2`` from  ``d1`` and 
  ``d2``. Then it calls function mat24_perm_from_heptads() for 
  computing the unique permutation in ``Mat24`` that maps ``h1`` 
  to ``h2``.
*/
// %%EXPORT p
uint32_t mat24_perm_from_dodecads(uint8_t *d1, uint8_t *d2, uint8_t *p_out)
{
    uint8_t h1[8], h2[8];
    return (dodecad_to_heptad(d1, h1) || dodecad_to_heptad(d2, h2)
            || mat24_perm_from_heptads(h1, h2, p_out)) 
            ? (uint32_t)(-1) : 0;
}


/*************************************************************************
*** Mathieu group M24: operation of group elements
*************************************************************************/
/**
  @brief Apply a permutation in the Mathieu group ``Mat24`` to a bit vector

  Apply the pernnutation ``p: i -> p1[i]`` to the bit vector ``v1``.
  This maps bit ``i`` of ``v1`` to bit ``p1[i]`` of the returned 
  result.
*/
// %%EXPORT p
uint32_t mat24_op_vect_perm(uint32_t v1, uint8_t *p1)
{
   uint_fast32_t i, w = 0;
   for (i = 0; i < 24; ++i) w |=  ((v1 >> i) & 1) << p1[i];
   return w;
}


/**
  @brief Apply a ``12 times 12`` bit matrix to a Golay code vector

  A matrix ``12 times 12`` bit matrix ``m`` must be encoded
  in the input parameter ``m1`` as specified in function
  mat24_perm_to_matrix(). The function returns the matrix
  product ``v1 * m`` as bit vector. Input ``v1`` and  the
  return value are Golay code words given in ``gcode`` 
  representation.    
*/
// %%EXPORT p
uint32_t mat24_op_gcode_matrix(uint32_t v1, uint32_t *m1)
{
    uint_fast32_t w = 0;
    register int i;
    for (i=0; i< 12; ++i) w ^= *m1++ & (0 - ((v1 >> i) & 1)); 
    return w;
}


/**
  @brief Apply a permutation in the group ``Mat24`` to a Golay code vector 

  Apply the permutation ``p: i -> p1[i]`` (which must be an element 
  of the Mathieu group Mat24) to the Golay code word ``v1``, 
  with ``v1`` given in ``gcode`` representation.

  The function returnes the permuted Golay code  word in 
  ``gcode`` representation.
*/
// %%EXPORT p
uint32_t mat24_op_gcode_perm(uint32_t v1, uint8_t *p1)
{
    uint_fast32_t i, w = 0;
    v1 =   MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
           ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff];
    for (i = 0; i < 24; ++i) w |=  ((v1 >> i) & 1) << p1[i];
    v1 =  MAT24_ENC_TABLE0[w & 0xff]
           ^ MAT24_ENC_TABLE1[(w >> 8) & 0xff]
           ^ MAT24_ENC_TABLE2[(w >> 16) & 0xff];
    return v1 >> 12;
}


/**
  @brief Apply a permutation in the group ``Mat24`` to a Golay cocode element 

  Apply the permutation ``p: i -> p1[i]`` (which must be an element 
  of the Mathieu group Mat24) to the Golay cocode element ``c1``, 
  with ``c1`` given in ``cocode`` representation.

  The function returnes the permuted cocode  word in 
  ``cocode`` representation.
*/
// %%EXPORT p
uint32_t mat24_op_cocode_perm(uint32_t c1, uint8_t *p1)
{
   uint_fast32_t res;
   res =  0 - (((c1 >> 11) + 1) & 1);   // res = 0 if c1 is odd else -1
   c1 ^= MAT24_RECIP_BASIS[0] & res;    // make c1 odd
   res &= MAT24_RECIP_BASIS[p1[0] & 31]; // .. and adjust result
   c1 = MAT24_SYNDROME_TABLE[ c1 & 0x7ff ]; // get syndrome
   res ^= MAT24_RECIP_BASIS[p1[c1 & 31] & 31]
        ^ MAT24_RECIP_BASIS[p1[(c1 >> 5) & 31] & 31]
        ^ MAT24_RECIP_BASIS[p1[(c1 >> 10) & 31] & 31];
   return res & 0xfff;
}



/**
   @brief Compute product of two permutations in the Mathieu group ``Mat24``

   Here inputs ``p1, p2`` must be permutations represented as mappings
   ``i -> p1[i], i -> p2[i]``. The function computes the product
   ``p1 * p2`` and stores it in the array ``p_out`` in the same form.
   Thus ``p_out[i] = p2[p1[i]]``.

   Input errors are not detected, but output buffer overflow is
   prevented. Any overlap between ``p1, p2,`` and ``p_out`` is
   possible.
*/
// %%EXPORT p
void mat24_mul_perm(uint8_t *p1, uint8_t *p2, uint8_t *p_out)
{
    uint8_t p[32];
    uint_fast8_t i;
    for (i = 0; i < 24; ++i) p[i] = p2[p1[i] & 31];
    memcpy(p_out, p, 24); 
}


/**
   @brief Compute the inverse of a permutation in the Mathieu group ``Mat24``

   Here input ``p1`` must be a permutation represented as mapping
   ``i -> p1[i]``. The function computes the inverse of ``p1``
   and stores it in the array ``p_out`` in the same form.
   Thus ``p_out[p1[i]] = i``.

   Input errors are not detected, but output buffer overflow is
   prevented. Any overlap between ``p1`` and ``p_out`` is possible.
*/
// %%EXPORT p
void mat24_inv_perm(uint8_t *p1, uint8_t *p_out)
{
    uint8_t p[32];
    uint_fast8_t i;
    for (i = 0; i < 24; ++i)  p[p1[i] & 31] = i;
    memcpy(p_out, p, 24); 
}


/*************************************************************************
*** Automorphisms of the Parker Loop
*************************************************************************/

// %%IF* INT_BITS == 32
static const uint32_t MAT24_AUTPL_QF_TABLE[] = {
  // %%TABLE Mat24_autpl_qf_table, uint32   
};
// %%END IF

/**
  @brief Auxiliary function for function mat24_perm_to_autpl()
  
  Given a Parker loop autmorphism ``a``, the function computes a
  quadratic form ``qf`` on the Golay code defined as follows:
  
  ``qf(g[i]) = 0`` for all basis vectors ``g[i]`` of the standard
  basis of the Golay code. Furthermore we have
   
        qf(v1 + v2) = qf(v1) + qf(v2) + b(v1, v2) ,
		
  where ``b`` is a bilinear form on the Golay code defined by	
    
        b(x,y) = theta(p(x), p(y)) + theta(x, y)    (mod 2).
		
  Here ``p`` is the element of the group ``Mat24`` obtained by 
  taking the automorphism ``a``  modulo sign, and ``theta`` is 
  the cocycle of the Parker loop. Then ``b`` is an alternating
  bilinear form by [Seys20], Lemma 4.1. 
	
  Let ``b[i,j] = b(g[i], g[j])`` where ``g[i]`` is the ``i-th``
  basis vector of the Golay code in our selected standard basis. 
  
  Input ``m_io`` represents the Parker loop automorphism ``a`` as 
  documented in function mat24_perm_to_autpl(). Here we modify
  the array ``m_io`` by storing the bit ``b[i,j]`` in bit ``13+j``
  of entry ``m_io[i]`` for ``i > j``.

  So the quadratic form ``qf`` is now also stored in the array
  ``m_io`` representing the automorphsm ``a``. As explained in
  [Seys20] this facilitates computation in the automorphism group
  of the Parker loop.
*/
// %%EXPORT p
void mat24_autpl_set_qform(uint32_t *m_io)
{
    uint_fast32_t i;
    uint_fast%{INT_BITS}_t v,  m2[10];

    // The quadratic form qf on the Golay code is defined as follows:
    // qf(b[i]) = 0 for all basis vectors b[i] of the standard
    // basis of the Golay code. Furthermore
    //   qf(v1+v2) = qf(v1) + qf(v2) + v1 * q * transpose(v2),
    // with matrix q as defined below.
 
    // First compute the 12 x 12  matrix q with
    // q[i,j] = theta(m[i], m[j])  ^  theta(b[i],b[j]).
    // Here b[i] is the i-th standard basis vector of the Golay code
    // and m[i] is it image under the automorphism given by m_io.
    // So m[i] = m_io[i] & 0xfff.
    // The matrix q is alternating.
    // We just compute the lower triangle of q in order to evaluate a
    // quadratic form associated with q. Our last basis vector b[11] is 
    // is Omega, so q[i,11] = q[11,i] = 0, and hence for the lower 
    // triangle it suffices to compute q[i,j] for i=0,...,10; 
    // j=0,...,i-1. We store q[i,j] in bit (j+13) of m[i].

    // Internal operation:
    // Most of the work is the computation of  theta(m[i], m[j]).
	
  // %%IF* INT_BITS == 32
  
    // We read theta(b[i],b[j]) from table MAT24_AUTPL_QF_TABLE.
    // Store m[i], bit 0..10, in m2[i], bit 0..10,
    // and a copy of that value in m2[i], bit 16..26  
    for (i = 0; i < 10; ++i)  {
        v =  (m_io[i] & 0x7ff); 
        m2[i] = v + (v << 16);
    }

    // Put v = (theta(m[i], bit 0..10,  theta(m[i+1]), bit 0..10)
    // and compute the matrix product v * transpose(m2) 
    // for i = 1,3,5,7,9.
    // The result is theta(m[i], m[j]), j= 0..10 and
    // theta(m[i+1], m[j]), j= 0..10. 
    // Then compute q[i,j] and q[i+1,j] for j < i from these results
    // and constants theta(b[i],b[j]) in table MAT24_AUTPL_QF_TABLE.
    for (i = 1; i < 11; i += 2) {
        v = (MAT24_THETA_TABLE[m_io[i] & 0x7ff] & 0x7ff)
            ^ ((MAT24_THETA_TABLE[m_io[i+1] & 0x7ff] & 0x7ff) << 16);
        // %%BITVMULTRANSP v, m2, 16, 10, 2
        v = (v ^ MAT24_AUTPL_QF_TABLE[i-1]) & MAT24_AUTPL_QF_TABLE[i];
        m_io[i] = (m_io[i] & 0x1fff) ^ ((v & 0x7ff) << 13);
        m_io[i+1] = (m_io[i+1] & 0x1fff) ^ ((v & 0x7ff0000) >> 3);
    }
    // Clear rows 0 and 11 of the quadratic form

  // %%ELSE	
	
    for (i = 0; i < 10; ++i)  {
        v =  (m_io[i] & 0x7ff);
        v ^= v << 12; v ^= v << 24;
        m2[i] = v ^ (v << 48);
    }
	
	v = (uint64_t)MAT24_THETA_TABLE[m_io[1] & 0x7ff] & 0x7ff;
	// %%FOR i in range(1, 5)
	v ^= (uint64_t)(MAT24_THETA_TABLE[m_io[%{int:i+1}] & 0x7ff] & 0x7ff) << %{int:12*i};
	// %%END FOR
	
	// %%BITVMULTRANSP v, m2, 12, 5, 5
	v ^= %{Mat24_autpl_qf_table64[0]};

	// %%FOR i in range(5)
	m_io[%{int:i+1}] &= 0x1fff;
	m_io[%{int:i+1}] ^= %{BITV_EXTRACT: v, 12*i, i+1, 13};
	// %%END FOR
	
	v = (uint64_t)MAT24_THETA_TABLE[m_io[6] & 0x7ff] & 0x7ff;
	// %%FOR i in range(1, 5)
	v ^= (uint64_t)(MAT24_THETA_TABLE[m_io[%{int:i+6}] & 0x7ff] & 0x7ff) << %{int:12*i};
	// %%END FOR
	
	// %%BITVMULTRANSP v, m2, 12, 10, 5
	v ^= %{Mat24_autpl_qf_table64[1]};

	// %%FOR i in range(5)
	m_io[%{int:i+6}] &= 0x1fff;
	m_io[%{int:i+6}] ^= %{BITV_EXTRACT: v, 12*i, i+6, 13};
	// %%END FOR

  // %%END IF	


    m_io[0] &= 0x1fff; m_io[11] &= 0x1fff;
}

/**
  @brief Construct a Parker loop automorphism 

  The function combines a cocode element ``c1`` and a permutation
  ``p`` in the Mathieu group ``Mat24`` to a Parker loop automorphism.
  Here ``c1`` must be given in ``cocode`` representation. Permutation 
  ``p`` must be given as a mapping ``i -> p1[i], 0 <= i < 24``.
  
  Up to sign, the image of an element of the Parker loop is the 
  corresponding Golay code vector permuted by the permutation ``p``. 
  The sign of the image of the ``i``-th positive basis vector of 
  the Parker loop is given by  bit ``i`` of ``c1``. This determines 
  the automorphism uniqely. We will write ``AutPL(c1, p)`` for that 
  automorphism.
  
  The function returns the automorphism ``AutPL(c1, p)`` as an array 
  ``m_out`` of 12 integers of  type ``uint32_t``. The lowest 13 bits
  of ``m_out[i]`` contain the image of the ``i``-th positive basis 
  vector. Here each image is encoded as a Parker loop element as in
  function ``mat24_mul_ploop``. 
  
  We also compute a quadratic form in the higher bits of the entries  
  of ``m_out``, as described in function mat24_autpl_set_qform(). 
  This facilitates computations in  the automorphism group of the 
  Parker loop. 
  
  Let ``Id`` be the neutral element in ``Mat24``. Then we have
  
        AutPL(c1, p)  = AutPL(c1, Id) * AutPL(0, p) .
*/  
// %%EXPORT p
void mat24_perm_to_autpl(uint32_t c1, uint8_t *p1, uint32_t *m_out)
{
    uint_fast32_t i;
    mat24_perm_to_matrix(p1, m_out);
    for (i = 0; i < 12; ++i) m_out[i] ^= ((c1 >> i) & 1) << 12;
    mat24_autpl_set_qform(m_out);
}


/**
  @brief Compute a diagonal Parker loop automorphism 

  The function converts a cocode element ``c1`` to a Parker loop 
  automorphism. Here ``c1`` must be given in ``cocode`` 
  representation. Such an automorphism is called a diagnonal
  asutomorphism; it changes the signs of the Parker loop
  elements only.
  
  The resulting automorphism is stored in ``m_out`` in the same 
  way as in function mat24_cocode_to_autpl().
    
  If ``p0`` is an array representing the neutral element of the
  group ``Mat24`` then ``mat24_cocode_to_autpl(cl, m_out)`` is 
  equivalent to ``mat24_perm_to_autpl(c1, p0, m_out)``.  
*/
// %%EXPORT p
void mat24_cocode_to_autpl(uint32_t c1, uint32_t *m_out)
{
    uint_fast32_t i;
    for (i = 0; i < 12; ++i) {
        m_out[i] = (1 << i) + (((c1 >> i) & 1) << 12);
    }
}


/**
  @brief Extract permutation from Parker loop automorphism.
  
  Ignoring the signs of the Parker loop, an automorphism ``m1`` 
  of  the Parker loop is an automorphism of the Golay code 
  and can be represented as a permutation in the Mathieu 
  group ``Mat24``. Here ``m1`` must be encoded as described in
  function mat24_perm_to_autpl(). 
  
  The function computes the permutation in the group ``Mat24`` 
  corresponding the automorphism ``m1`` and returns it in ``p1``
  as a  mapping ``i -> p1[i]``.
*/  
// %%EXPORT p
void mat24_autpl_to_perm(uint32_t *m1, uint8_t  *p_out)
{
    mat24_matrix_to_perm(m1, p_out);
}

/**
  @brief Extract cocode element from Parker loop automorphism.
  
  Given an automorphism ``m1`` of the  Parker loop, as constructed 
  by function mat24_perm_to_autpl(), the function returns a
  cocode element ``c`` in ``cocode`` representation. Element ``c``
  has the following property:
  
  Let ``p`` be the permutation in ``Mat24`` obtained from ``m1``
  by calling mat24_autpl_to_perm(m1, p). Then calling
  ``mat24_perm_to_autpl(c, p, m2)``, where ``m2`` is a suitable 
  array, constructs a copy ``m2`` of ``m1`` from ``c`` and ``p``.  
*/  
// %%EXPORT p
uint32_t mat24_autpl_to_cocode(uint32_t *m1)
{
    uint_fast32_t i, v = 0;
    for (i = 0; i < 12; ++i)  v += ((m1[i] >> 12) & 1) << i;
    return v;
}


/// @cond DO_NOT_DOCUMENT

// The following macro computes t = mat24_op_ploop_autpl(v1, m1).
// It destroys v1. Description see function mat24_op_ploop_autpl().
#define inline_op_ploop_autpl(v1, m1, t) \
    t = (v1 & 0x1000) \
      ^ (m1[0] & (0-(v1 & 1))) ^ (m1[1] & (0-((v1 >> 1) & 1))) \
      ^ (m1[2] & (0-((v1 >> 2) & 1)))  ^ (m1[3] & (0-((v1 >> 3) & 1))) \
      ^ (m1[4] & (0-((v1 >> 4) & 1)))  ^ (m1[5] & (0-((v1 >> 5) & 1))) \
      ^ (m1[6] & (0-((v1 >> 6) & 1)))  ^ (m1[7] & (0-((v1 >> 7) & 1))) \
      ^ (m1[8] & (0-((v1 >> 8) & 1)))  ^ (m1[9] & (0-((v1 >> 9) & 1))) \
      ^ (m1[10] & (0-((v1 >> 10) & 1))) ^ (m1[11] & (0-((v1 >> 11) & 1)));\
    v1 = (t >> 13) & v1;  v1 ^= v1 >> 6;  v1 ^= v1 >> 3; \
    v1 = (0x96 >> (v1 & 7)) & 1; \
    t = (t & 0x1fff) ^ (v1 << 12);     

/// @endcond


/**
  @brief Apply a Parker loop automorphism to a Parker Loop element

  Apply Parker loop automorphism ``m1`` to Parker Loop element ``v1``
  and return the result as a Parker Loop element.
 
  Here ``m1`` is a Parker loop autmorphism as constructed by function 
  mat24_perm_to_autpl(). ``v1`` and the return value is an element 
  of the Parker loop, encoded as in function mat24_mul_ploop().
*/
// %%EXPORT p
uint32_t mat24_op_ploop_autpl(uint32_t v1, uint32_t *m1)
{
    // Operation:
    // Matrix m1 contains a quadratic form qf and the images of the
    // basis vectors, as described in function mat24_autpl_set_qform().
    // Let m = (m[0],...,m[1]), with row vector m[i] the image of the 
    // i-th basis vector b[i]. Then we compute the product binary 
    // matrix product:
    //    t0 = v_12 * m,
    // where v_12 is the vector containing the lower 12 bits of v, 
    // excluding the sign bit. t0 is the correct result up to sign.
    // Then we asjust the sign as follows:
    //   t = t0  ^  (v1 & 0x1000) ^ (s << 12),  
    // where (v1 & 0x1000) is the sign bit of v1 and s is defined by
    // s = qf(v_12) =  v_12 *  q  * transpose(v_12),
    // and q is the 12 x 12 matrix representing the quadratic form qf 
    // as in function mat24_autpl_set_qform().  

    uint_fast32_t  t;
    inline_op_ploop_autpl(v1, m1, t);
    return t;
}


/**
  @brief Compute the product of two Parker Loop automorphisms
  
  Given two Parker Loop automorphism ``m1, m2`` the function
  computes ``m1 * m2`` and stores the result in ``m_out``. All
  Parker loop automorphisms are encoded as in function
  mat24_perm_to_autpl(). 
  
  For an element ``a`` of the Parker loop we have
  ``m_out(a) = m2(m1(a))``.
*/
// %%EXPORT p
void mat24_mul_autpl(uint32_t *m1, uint32_t *m2, uint32_t *m_out)
{
    uint_fast32_t  i, v, t;
    uint32_t m[12];
    // Compute images of the vectors m[i] in m1 under the
    // automorphism m2 of the parker loop,
    for (i = 0; i < 12; ++i) {
        v = m1[i];
        inline_op_ploop_autpl(v, m2, t);
        m[i] = t;
    }
    // Store the images of the vectors m[i]  in output matrix m_out
    for (i = 0; i < 12; ++i) m_out[i] = m[i];
    // Compute the quadratic form for m_out.
    mat24_autpl_set_qform(m_out);
}

/**
  @brief Compute the inverse of a Parker Loop automorphisms
  
  Given a Parker Loop automorphism ``m1`` the function computes
  the inverse of  ``m1`` and stores the result in ``m_out``. All
  Parker loop automorphisms are encoded as in function
  mat24_perm_to_autpl(). 
*/
// %%EXPORT p
void mat24_inv_autpl(uint32_t *m1, uint32_t *m_out)
// Put m_out = m1**(-1) for a Parker loop automorphisms m1
//
// Here all automorphisms are in 'autpl' representation.
{
    uint_fast32_t  i, v, t;
    uint8_t p[32], p_inv[32];
    uint32_t mi[12];

    mat24_matrix_to_perm(m1, p); 
    for (i = 0; i < 24; ++i) p_inv[p[i] & 31] = (uint8_t)i;
    mat24_perm_to_matrix(p_inv, mi);
    for (i = 0; i < 12; ++i) {
         v = mi[i];
         inline_op_ploop_autpl(v, m1, t);
         mi[i] ^= (t & 0x1000);
    }
    for (i = 0; i < 12; ++i) m_out[i] = mi[i]; 
    mat24_autpl_set_qform(m_out);
}


//345678901234567890123456789012345678901234567890123456789012345678901234567890  


/**
  @brief Compute inverse Parker Loop automorphism from permutation
  
  This is equivalent to
  
        mat24_inv_perm(p1, p_out);
        mat24_perm_to_autpl(c1, p1, m_temp);  
        mat24_inv_autpl(m_temp, m_out);  
		
  The function saves some intermedate steps so that it is faster.		
*/   
// %%EXPORT p
void mat24_perm_to_iautpl(uint32_t c1, uint8_t *p1, uint8_t *p_out, uint32_t *m_out)
{
    uint_fast32_t i, v, t;
    uint32_t m1[16];
    uint8_t p_inv[32];
    mat24_perm_to_matrix(p1, m1);
    for (i = 0; i < 12; ++i) m1[i] ^= ((c1 >> i) & 1) << 12;
    mat24_autpl_set_qform(m1);

    for (i = 0; i < 24; ++i) p_inv[p1[i] & 31] = (uint8_t)i;
    for (i = 0; i < 24; ++i) p_out[i] = p_inv[i];
    mat24_perm_to_matrix(p_inv, m_out);
    for (i = 0; i < 12; ++i) {
        v = m_out[i];
        inline_op_ploop_autpl(v, m1, t);
        m_out[i]  ^= (t & 0x1000);
    }
    mat24_autpl_set_qform(m_out);
}



/*************************************************************************
*** Auxiliary functions for the Monster group
*************************************************************************/

/**
  @brief Compute modified Benes network for permutation of 24 entries

  The Benes network is computed for the permutation ``p: i -> p1[i]``.
  The network consists of 9 layers. The returned array ``a_out`` of 
  length 9 describes that network. In layer ``i``, entry ``j`` is to
  be  exchanged with entry  ``j + d[i]``, if bit ``j`` of the value 
  ``a_out[i]``  is set. Here ``d[i] = 1,2,4,8,16,8,4,2,1`` for
  ``i = 0,...,8``. For all such exchange steps we have ``j & d[i] == 0``.
  We also assert that no entry with index ``>=24`` will be touched. 
*/
// %%EXPORT p
void mat24_perm_to_net(uint8_t *p1, uint32_t *a_out)
{
    uint_fast8_t p[32], q[32];
    uint_fast32_t i, j, sh, d, done;
    uint_fast32_t res0, res1, res2;

    for (i = 0; i < 24; ++i) 
        p[i] = p1[i] & 31; // copy permutation p1 to p

    // The first and the last three layers are a standard Benes network. 
    // Do Benes network looping algorithm steps for d = 1, 2, 4
    for (sh = 0; sh < 3; ++sh)
    {      
        d = 1 << sh;
        for (i = 0; i < 24; ++i)
            q[p[i]] = (uint8_t)i;  // q := inverse of p
        done = 0;            // bit i marks that step i->p[i] is done
        res0 = 0;            // initial looping transpositions
        res1 = 0;            // final looping transpositions
        for (i = 0; i < 24; ++i)  // Looping step for Benes network
        {
            j = i;           // j is a node not yet processed
            while (!(done & (1 << j))) // while node j not done
            {
                done |= 1 << j;        // delare node j done
                j = p[j];              // j := permutation result p[j]
                // route node p[j] thru '0' part of inner Benes network
                // so we do: if (j & d): res1 |=  1 << (j & ~d)
                res1 |= ((j & d) >> sh) << (j & ~d);
                j = q[j ^ d];          // j = origin of buddy of p[j]
                done |= 1 << j;        // declare that buddy done
                // route buddy thru '1' part of inner Benes network
                // so we do: if (~j & d): res0 |=  1 << (j & ~d)
                res0 |= ((~j & d) >> sh) << (j & ~d);
                j = j ^ d;             // j = buddy of that origin
            }
        }
        a_out[sh] = res0;    // save initial looping transposition
        a_out[8-sh] = res1;  // save final looping transposition
        res0 |= res0 << d;   // initial: exchange i with i^d if bit i set
        res1 |= res1 << d;   // final: exchange i with i^d if bit i set
        for (i = 0; i < 24; ++i)  // compute q = (initial) * p * (final)
        {
            j = p[i ^ (((res0 >> i) & 1) << sh)];
            q[i] = (uint8_t)(j ^ (((res1 >> j) & 1) << sh));
        }
        for (i = 0; i < 24; ++i) // copy (initial) * p * (final) to p
            p[i] = q[i];
    }
    // It remains to compute the 3 middle layers. They must compute
    // the permutation i -> p[i] with p[i] = i (mod 8). E.g. for i=0
    // we do the following transpositions, if (0, 8, 16) maps to
    //
    //   ( 0,  8, 16):          (id)  *   (id)   *   (id)  // [1]
    //   ( 0, 16,  8):         (0,8)  *  (0,16)  *  (0,8)  // [0]     
    //   ( 8,  0, 16):         (0,8)  *   (id)   *   (id)  // [2]  
    //   ( 8, 16,  0):         (0,8)  *  (0,16)  *   (id)  // [3]
    //   (16,  0,  8):          (id)  *  (0,16)  *  (0,8)  // [4]  
    //   (16,  8,  0):          (id)  *  (0,16)  *   (id)  // [5]
    //          
    // For each permutation of (i, i+8, i+16) we compute a number j,
    // as indicated in square brackets above, from the bits 3 and 4 of
    // p[i] and p[i+8]. Then we use table look up for obtaining the
    // correct transpostions as given in the list above.   
    res0 = res1 = res2 = 0;
    for (i = 0; i < 8; ++i)
    {
        j = p[i] >> 3;
        j = 2 * j + ((p[i+8] >> (3 + (j & 1))) & 1);
        j = (0x236407 >> (j << 2)) & 0xf;
        res2 |=  (j & 1) << i;
        res1 |=  ((j >> 1) & 1) << i;
        res0 |=  ((j >> 2) & 1) << i;
    }
    a_out[3] = res0; a_out[4] = res1; a_out[5] = res2;
}





/**  
  @brief Auxiliary function for computing in the monster.
  
  The function is used for applying the automorphism ``m1`` of 
  the Parker loop to a vector of the ``196884``-dimensional 
  representation of the monster. ``m1`` is encoded as in function
  mat24_perm_to_autpl().

  It computes a table ``a_out[i], i = 0,...,0x7ff``, such that
  ``(a_out[i] & 0x7ff)`` is the image ``m1(i)`` of the Parker 
  loop element ``i`` modulo the center of the Parker loop. Signs 
  are stored in bits ``12,...,14`` of ``a_out[i]`` as follows:
  
        Bit 12: (sign of m1(i)) ^ (odd &  P(i))
	 
        Bit 13: (sign of m1(i))
	 
        Bit 14: (sign of m1(i)) ^ (bit 11 of m1(i))
		
  Here ``odd`` is the parity of the automorphism, and ``P()``
  is the power map of the Parker loop.
*/
// %%EXPORT p
void mat24_op_all_autpl(uint32_t *m1, uint16_t *a_out)
{
    uint_fast32_t i;   // exponential counter: 1, 2, 4, 8,...,0x400
    uint_fast32_t j;   // counter from 1 to i-1
    uint_fast32_t ri;  // accumulator for computing a_out[i]
    uint_fast32_t q;   // q is row log2(i) of bilinear form in m1
    uint_fast32_t qq, qq1, qq2;  // used for computing a sign bit
    uint_fast32_t odd; // set to a nonzero value if m1 is odd
    odd = m1[11] & 0x1000;
    // We have to to the following:
    a_out[0] = 0; 
    // But we also don't like dummy operations with undefined input
    a_out[1] = a_out[2] = a_out[3] = 0;
    for (i = 1; i < 0x800; i += i) {
        // First compute ri = a_out[i] and copy the (halved) 
        // corresponding row of bilinear form from m1 to q. 
        ri = *m1++;                 // row  log2(i)   of  m1
        q = (ri >> 13) & 0x7ff;     // row of bilinear form B
        // m1[log2(i)], bit 0,..12 is the Parker loop element i,
        // with bit 12 the sign bit. Store sign bit to bits 12...14
        // of ri. Store image of element i in bits 11...0.
        // of ri. xor bit 11 of that image to bit 14 of ri. Note that 
        // the Power map bit is 0 for all basis vectors.
        ri = (0-(ri & 0x1000)) ^ (ri & 0xfff) ^ ((ri & 0x800) << 3);
        a_out[i] = (uint16_t)ri;   // Save result ri in a_out.
        qq1 = 0 - ((q & 1) << 12);
        a_out[i+1] = (uint16_t)(ri ^ a_out[1] ^ qq1);   
        qq2 = 0 - ((q & 2) << 11);     
        a_out[i+2] = (uint16_t)(ri ^ a_out[2] ^ qq2);   
        a_out[i+3] = (uint16_t)(ri ^ a_out[3] ^ qq1 ^ qq2);   
        // Next compute a_out[i+j], 1 <= j < i.
        // We do cases j,..j+3 in a single iteration for j = 0 mod 4
        for (j = 4; j < i; j += 4) {
            // Store bit dsign = B(i, j) = parity(j & q) in 
            // qq, bits 12..14. We have 
            //  sign(i+j) = sign(i) ^ sign(j) ^ dsign
            qq = j & q;
            qq ^= qq >> 6;
            qq ^= qq >> 3;
            qq = -((0xD20 << (qq & 7)) & 0x1000); 
            // Put a_out[i+j] = a_out[i] ^ a_out[j] ^ dsign
            a_out[i+j] = (uint16_t)(ri ^ a_out[j] ^ qq); 
            qq1 = qq ^ (0-((q & 1) << 12)); // qq1[12..14] = qq0^B(i,1) 
            a_out[i+j+1] = (uint16_t)(ri ^ a_out[j+1] ^ qq1); 
            qq2 = 0 - ((q & 2) << 11);     // qq2[12..14] =  B(i,2) 
            a_out[i+j+2] = (uint16_t)(ri ^ a_out[j+2] ^ qq ^ qq2); 
            a_out[i+j+3] = (uint16_t)(ri ^ a_out[j+3] ^ qq1 ^ qq2); 
        }
    }
    if (odd) for (i = 0; i < 0x800; i += 4) {
        // Adjust bit 12  for power map if m1 is odd   
        a_out[i] ^= MAT24_THETA_TABLE[i] & 0x1000;
        a_out[i+1] ^= MAT24_THETA_TABLE[i+1] & 0x1000;
        a_out[i+2] ^= MAT24_THETA_TABLE[i+2] & 0x1000;
        a_out[i+3] ^= MAT24_THETA_TABLE[i+3] & 0x1000;
    }
}




/**  
  @brief Auxiliary function for computing in the monster.
  
  This is a simplified version of function mat24_op_all_autpl(),
  which is used for applying the diagonal automorphism ``c1`` 
  of the Parker loop (encoded in ``cocode`` representation) to
  a vector of a representation of the monster.

  The function computes a table ``a_out[i], i= 0,...,0x7ff``, 
  containing the signs related to this operation as follows:
  
         Bit 0:  (sign of c1(i)) ^ (odd &  P(i))
	
         Bit 1:  (sign of c1(i))
	
         Bit 2:  same as bit 1
		
  Here ``odd`` and ``P()`` are as in function mat24_op_all_autpl().
*/
// %%EXPORT p
void mat24_op_all_cocode(uint32_t c1, uint8_t *a_out)
{
    uint_fast32_t i;      // exponential counter: 1, 2, 3, 8,...,0x400
    uint_fast32_t j;      // counter from 1 to i-1
    uint_fast32_t sh = 0; // shift factor: i = 2 << sh
    uint_fast8_t ri;     // accumulator for computing a_out[i]
    // We have to to the following:
    a_out[0] = 0; 
    // But we also don't like dummy operations with undefined input
    a_out[1] = a_out[2] = a_out[3] = 0;
    for (i = 1; i < 0x800; i += i) {
        // First compute ri = a_out[i]. ri is equal to the scalar 
        // product of the Golay code element i and  the cocode 
        // element c1.  Note that the Power map bit is 0 for all 
        // basis vectors.
        a_out[i] = ri = (uint8_t)(0 - ((c1 >> sh++) & 1));
        a_out[i+1] = ri ^ a_out[1];
        a_out[i+2] = ri ^ a_out[2];
        a_out[i+3] = ri ^ a_out[3];
        // Next compute a_out[i+j], 1 <= j < i.
        for (j = 4; j < i; j += 4) {
            // Put a_out[i+j] = a_out[i] ^ a_out[j]
            a_out[i+j] = ri ^ a_out[j];      
            a_out[i+j+1] = ri ^ a_out[j+1];      
            a_out[i+j+2] = ri ^ a_out[j+2];      
            a_out[i+j+3] = ri ^ a_out[j+3];      
        }
    }
    if (c1 & 0x800) for (i = 0; i < 0x800;  i += 4) {
        // Adjust bit 12  for power map if c1 is odd   
        a_out[i] ^= (MAT24_THETA_TABLE[i] >> 12) & 0x1;
        a_out[i+1] ^= (MAT24_THETA_TABLE[i+1] >> 12) & 0x1;
        a_out[i+2] ^= (MAT24_THETA_TABLE[i+2] >> 12) & 0x1;
        a_out[i+3] ^= (MAT24_THETA_TABLE[i+3] >> 12) & 0x1;
    }
}








// %%GEN ch
#ifdef __cplusplus
}
#endif
// %%GEN h

/// @endcond  
//  End condition: Do not document C functions in the header file!

#endif  // #ifndef MAT24_FUNCTIONS_H



