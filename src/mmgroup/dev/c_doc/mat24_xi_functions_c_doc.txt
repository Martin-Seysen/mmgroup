// This is a C implementation of the functionality of Python class
// Mat24Xi as described in the sequel. Note that all exported funtions
// in this module are prefixed with 'mat24_xi'



// Support for the subgroup G_x0 = 2**{1+24}.Co_1 of the Monster group
// 
// See [Conw85] for background on the group G_x0. That group contains a
// subgroup N_x0 of shape 2**{1+24}.2**{11}.Mat24, where Mat24 is the Mathieu
// group acting on 24 elements. Mat24 (and also, to some extent, N_x0) is
// supported by class mat24.Mat24.
// 
// G_x0 is generated by N_x0 and an element xi of order 3, which is defined
// in [Seys19], section 9. G_x0 has an extraspecial normal subgroup Q_x0 of
// shape 2**{1+24}. Class Mat24Xi focusses on the operation of xi and x**2
// on Q_x0 by conjugation. We use the notation in [Seys19].
// 
// The so-called short elements of Q_x0 (see [Conw85], sect.7 and [Seys19],
// section 6.2) play an important role as basis vectors in the representa-
// tion 196884_x of the monster in [Conw85] and also in this project.
// Element xi operates on that subset of basis vectors of 196884x by
// conugation. Class Mat24Xi also contains functions for mapping of short
// vectors in  Q_x0 to basis vectors of that representation and vice versa.
// It also supports the generation of tables for the operation of xi and
// xi**2 on sort vectors.
// 
// In [Conw85] the short vector of the Leech lattice are grouped into
// orbits of the subgroup N_x0. In the documentation
// mat24_xi_functions_c_doc.txt  the basis vectors corresponding to short
// Leech lattice vectors are labelled as follows:
// 
//    Name      Tag   Entries                               Remarks
//    X^+(ij)    B    i, j;  0 <= j < i < 24                (2)
//    X^-(ij)    C    i, j;  0 <= j < i < 24                (2)
//    X_o,s      T    o, s;  0 <= o < 759, 0 <= s < 64      (1)
//    X_d,j      X    d, j;  0 <= d < 2**11, 0 <= j < 24    (2,3)
// 
// For the remarks, see file mat24_xi_functions_c_doc.txt.
// 
// We group these basis vectrors into 4 boxes (labelled 1,...,4) with
// each box containing at most 3*2**13 entries. Element xi permutes
// these boxes as follows
// 
//    Box1 -> Box1, Box2 -> Box2,  Box3 -> Box4 -> Box5 -> Box3 . (1)
// 
// The mapping from the basis vectors to entries in boxes is:
// 
// 
//    Basis vector          Box     Entry
//    B[i,j]                 1         0 +  32 * i + j
//    C[i,j]                 1       768 +  32 * i + j
//    T[o,s], o < 15         1      1536 +  64 * o + j             (2)
//    T[o,s], 15 <= o < 375  2        64 * (o - 15) + j
//    T[o,s], o >=  375      3        64 * (o - 375) + j
//    X[d,j], d <  1024      4        32 *  d + j
//    X[d,j], d >= 1024      5        32 * (d - 1024) + j
// 
// This subdivision looks weird, but is has quite a few advantages:
// 
// - The lower index (j or s) has stride 1, and the the stride of the
//   higher index (i, o or d) is the lowest possible power of two. So
//   accessing an entry is easy. In the C code for the rep 196884x
//   entries will be strided in the same way, so that the tables
//   computed in this module can be used in the C code for operator xi.
// 
// - An entry in a box is always less than 2**15, so any entry can be
//   stored in a 16-bit integer, together with a sign bit.
// 
// - Boxes are permuted as above, so 4 tables of 16-bit integers
//   and size <= 3*2**13 are sufficent to encode the operation of xi.
// 
// We remark that boxes 1 and 3 contain the short vectors with even
// Golay code words o, d; and boxes 2 and 4 contain those with odd
// code words. Here the parity (even/odd) of a Golay code word means
// the scalar product with the cocode word omega which has six 1-bits
// in column 0 of the MOG, see [Seys19], section 2.2.
// 
// A similar, but finer subdivision of the whole space 196884_x (and
// not only of the subspace 98280_x spanned by the basis vectors
// corresponding to short Leech lattice vectors) is given in [Ivan09],
// section 3.4.
// 
// 
// Leech lattice encoding of the vectors in Q_x
// --------------------------------------------
// 
// The element X of Q_x0 as coded as an integer x  as follows. In [Conw85]
// and [Seys19] an element X of Q_x0 is given in the form X = X_d * X_delta,
// where d is an element of the Parker loop and delta is an element of the
// Golay cocode. We follow the conventions in  [Seys19] and in  module
// mat24_functions.c  to code a Parker loop element as a 13-bit integer v
// and a Golay cocode element as a 12-bit integer c. Then we put
// 
//         x = 2**12 * v + c.
// 
// The signs and the basis of the Parker loop have been chosen deliberately
// in mat24_functions.c in a way compatible to [Seys19]. For each short
// vector listed in Table 1 the Parker loop part v (with positive sign) and
// the cocode part c can be computed from the information given in [Seys19].
// 
// 
// Short vector encoding of the short vector in Q_x
// ------------------------------------------------
// 
// For each short vector in Q_x we compute the number of the box and the
// entry in the box using the information given in (2). Then we store the
// vector in the lowest 19 bits of a 32-bit integer as follows:
// 
//     Bit 18...16:  number of the box
//     Bit 15:       sign bit (i.e. bit 12 of part c in Leech encoding)
//     bit 14...0:   Entry in the box
// 
// Tables for the operation of xi and xi**2 contain the lower 16 bits
// of that encoding. Bits 18...16 can be reconstruted from (1).
// 
// 
// References
// ----------
// See file references.txt



/*************************************************************************
*** tables
*************************************************************************/



uint32_t mat24_xi_g_gray(uint32_t v1)
// Implement function gamma() in [Seys19], section 3.3.
// 
// Given a Golay code vector v  in 'gcode' representation, see
// module mat24.py, we return the element gamma(v) of the Golay
// cocode, with gamma() as in [Seys19], section 3.3. c is
// returned in 'cocode' representation, see module mat24.py.



uint32_t mat24_xi_w2_gray(uint32_t v1)
// Implement function w2() in [Seys19], section 3.3.
// 
// Given a Golay code vector v  in 'gcode' representation, see
// module mat24.py, we return the bit w2 = w2(c), with w2() as
// defined in [Seys19], section 3.3.



uint32_t mat24_xi_g_cocode(uint32_t v1)
// Inverse of method xi_w2_gray(v)
// 
// Given a cocode vector c in in 'cocode' representation, see
// module mat24.py, the function returns the unique gray Golay
// code vector v such tha cls.xi_w2_gray(v) is the gray part
// of c.



uint32_t mat24_xi_w2_cocode(uint32_t v1)
// Implement function w2() in [Seys19], section 3.3.
// 
// Given a cocode vector c in in 'cocode' representation, see
// module mat24.py, the function returns the bit w2 = w2(c),
// with w2() as defined in [Seys19], section 3.3.



uint32_t mat24_xi_op_leech(uint32_t x1, uint32_t u_exp)
// Operation of  xi**exp  on the element x of the group Q_x0.
// 
// The function returns the element
// 
//     xi**(-exp)  *  x  *  xi**exp
// 
// of the group Q_x0. The element x of Q_x0 as must be given in
// Leech lattice encoding, as described in the header of this
// module.
// 
// The returned result is is coded in the same way.



uint32_t mat24_xi_mul_leech(uint32_t x1, uint32_t x2)
// Return product of two elements the group  Q_x0.
// 
// The two factors X1, X1 are coded as integers x1, x2 as in
// method xi_op_leech. The product is returned in the same form.



uint32_t mat24_xi_leech_to_short(uint32_t x1)
// Convert Leech lattice to short vector encoding.
// 
// Both, Leech lattice and short vector encoding of a short vector
// in Q_x are decribed in the header of this module. The function
// returns the short vector encoding of element x1 given in Leech
// lattice encoding.
// 
// The function returns 0 if the vector x1 is not short.



uint32_t mat24_xi_short_to_leech(uint32_t x1)
// Convert short vector to Leech lattice encoding.
// 
// Both, Leech lattice and short vector encoding of a short vector
// in Q_x are decribed in the header of this module. The function
// returns the Leech lattice encoding of element x1 given in short
// vector encoding.
// 
// The function returns 0 for an illegal input x1.



uint32_t mat24_xi_op_short(uint32_t x1, uint32_t u_exp)
// Operation of  xi**exp  on the element x of the group Q_x0.
// 
// The function returns the element
// 
//     xi**(-exp)  *  x  *  xi**exp
// 
// of the group Q_x0. The element x of Q_x0 as must be given in
// short vector encoding, as described in the header of this
// module.
// 
// The returned result is is coded in the same way.



uint32_t mat24_xi_make_table(uint32_t u_box, uint32_t u_exp, uint16_t *ptab)
// generate table, yet to be documented!!



void mat24_xi_invert_table(uint16_t *ptab, uint32_t len, uint32_t ncols, uint16_t *pres, uint32_t len_res)
// invert table, yet to be documented!!



void mat24_xi_split_table(uint16_t *ptab, uint32_t len, uint32_t mod, uint32_t *psign)
// split table, yet to be documented!!



