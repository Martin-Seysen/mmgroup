/////////////////////////////////////////////////////////////////////////////
// This C file has been created automatically. Do not edit!!!
/////////////////////////////////////////////////////////////////////////////

// %%COMMENT
// This is a C implementation of the functionality of Python class
// Mat24Xi as described in the sequel. Note that all exported funtions
// in this module are prefixed with 'mat24_xi'

// %%COMMENT
// %%PY_DOCSTR Mat24_xi_module_doc
// Support for the subgroup G_x0 = 2**{1+24}.Co_1 of the Monster group
// 
// See [Conw85] for background on the group G_x0. That group contains a
// subgroup N_x0 of shape 2**{1+24}.2**{11}.Mat24, where Mat24 is the Mathieu
// group acting on 24 elements. Mat24 (and also, to some extent, N_x0) is
// supported by class mat24.Mat24.
// 
// G_x0 is generated by N_x0 and an element xi of order 3, which is defined
// in [Seys19], section 9. G_x0 has an extraspecial normal subgroup Q_x0 of
// shape 2**{1+24}. Class Mat24Xi focusses on the operation of xi and x**2
// on Q_x0 by conjugation. We use the notation in [Seys19].
// 
// The so-called short elements of Q_x0 (see [Conw85], sect.7 and [Seys19],
// section 6.2) play an important role as basis vectors in the representa-
// tion 196884_x of the monster in [Conw85] and also in this project.
// Element xi operates on that subset of basis vectors of 196884x by
// conugation. Class Mat24Xi also contains functions for mapping of short
// vectors in  Q_x0 to basis vectors of that representation and vice versa.
// It also supports the generation of tables for the operation of xi and
// xi**2 on sort vectors.
// 
// In [Conw85] the short vector of the Leech lattice are grouped into
// orbits of the subgroup N_x0. In the documentation
// mat24_xi_functions_c_doc.txt  the basis vectors corresponding to short
// Leech lattice vectors are labelled as follows:
// 
//    Name      Tag   Entries                               Remarks
//    X^+(ij)    B    i, j;  0 <= j < i < 24                (2)
//    X^-(ij)    C    i, j;  0 <= j < i < 24                (2)
//    X_o,s      T    o, s;  0 <= o < 759, 0 <= s < 64      (1)
//    X_d,j      X    d, j;  0 <= d < 2**11, 0 <= j < 24    (2,3)
// 
// For the remarks, see file mat24_xi_functions_c_doc.txt.
// 
// We group these basis vectrors into 4 boxes (labelled 1,...,4) with
// each box containing at most 3*2**13 entries. Element xi permutes
// these boxes as follows
// 
//    Box1 -> Box1, Box2 -> Box2,  Box3 -> Box4 -> Box5 -> Box3 . (1)
// 
// The mapping from the basis vectors to entries in boxes is:
// 
// 
//    Basis vector          Box     Entry
//    B[i,j]                 1         0 +  32 * i + j
//    C[i,j]                 1       768 +  32 * i + j
//    T[o,s], o < 15         1      1536 +  64 * o + j             (2)
//    T[o,s], 15 <= o < 375  2        64 * (o - 15) + j
//    T[o,s], o >=  375      3        64 * (o - 375) + j
//    X[d,j], d <  1024      4        32 *  d + j
//    X[d,j], d >= 1024      5        32 * (d - 1024) + j
// 
// This subdivision looks weird, but is has quite a few advantages:
// 
// - The lower index (j or s) has stride 1, and the the stride of the
//   higher index (i, o or d) is the lowest possible power of two. So
//   accessing an entry is easy. In the C code for the rep 196884x
//   entries will be strided in the same way, so that the tables
//   computed in this module can be used in the C code for operator xi.
// 
// - An entry in a box is always less than 2**15, so any entry can be
//   stored in a 16-bit integer, together with a sign bit.
// 
// - Boxes are permuted as above, so 4 tables of 16-bit integers
//   and size <= 3*2**13 are sufficent to encode the operation of xi.
// 
// We remark that boxes 1 and 3 contain the short vectors with even
// Golay code words o, d; and boxes 2 and 4 contain those with odd
// code words. Here the parity (even/odd) of a Golay code word means
// the scalar product with the cocode word omega which has six 1-bits
// in column 0 of the MOG, see [Seys19], section 2.2.
// 
// A similar, but finer subdivision of the whole space 196884_x (and
// not only of the subspace 98280_x spanned by the basis vectors
// corresponding to short Leech lattice vectors) is given in [Ivan09],
// section 3.4.
// 
// 
// Leech lattice encoding of the vectors in Q_x
// --------------------------------------------
// 
// The element X of Q_x0 as coded as an integer x  as follows. In [Conw85]
// and [Seys19] an element X of Q_x0 is given in the form X = X_d * X_delta,
// where d is an element of the Parker loop and delta is an element of the
// Golay cocode. We follow the conventions in  [Seys19] and in  module
// mat24_functions.c  to code a Parker loop element as a 13-bit integer v
// and a Golay cocode element as a 12-bit integer c. Then we put
// 
//         x = 2**12 * v + c.
// 
// The signs and the basis of the Parker loop have been chosen deliberately
// in mat24_functions.c in a way compatible to [Seys19]. For each short
// vector listed in Table 1 the Parker loop part v (with positive sign) and
// the cocode part c can be computed from the information given in [Seys19].
// 
// 
// Short vector encoding of the short vector in Q_x
// ------------------------------------------------
// 
// For each short vector in Q_x we compute the number of the box and the
// entry in the box using the information given in (2). Then we store the
// vector in the lowest 19 bits of a 32-bit integer as follows:
// 
//     Bit 18...16:  number of the box
//     Bit 15:       sign bit (i.e. bit 12 of part c in Leech encoding)
//     bit 14...0:   Entry in the box
// 
// Tables for the operation of xi and xi**2 contain the lower 16 bits
// of that encoding. Bits 18...16 can be reconstruted from (1).
// 
// 
// References
// ----------
// See file references.txt



/*************************************************************************
** External references 
*************************************************************************/



#include <stdint.h>
// #include <stdio.h>
#include <string.h>
#include "mat24_functions.h"
#include "mat24_xi_functions.h"


// %%GEN h
// #ifndef MAT24_XI_FUNCTIONS_H
// #define MAT24_XI_FUNCTIONS_H
// 
// 
// 
// 
// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


// %%COMMENT
/*************************************************************************
*** tables
*************************************************************************/

// %%USE_TABLE
static const uint8_t MAT24_XI_G_GRAY_TABLE[64] = { 
// %%TABLE Mat24_xi_g_gray_table , uint8
0x00,0xa0,0x1c,0xbc,0x1a,0xba,0x86,0x26,
0x16,0xb6,0x8a,0x2a,0x8c,0x2c,0x90,0x30,
0x0e,0xae,0x92,0x32,0x94,0x34,0x88,0x28,
0x98,0x38,0x84,0x24,0x82,0x22,0x1e,0xbe,
0x01,0x21,0x1d,0x3d,0x1b,0x3b,0x87,0xa7,
0x17,0x37,0x8b,0xab,0x8d,0xad,0x91,0xb1,
0x0f,0x2f,0x93,0xb3,0x95,0xb5,0x89,0xa9,
0x99,0xb9,0x85,0xa5,0x83,0xa3,0x1f,0x3f
};


// %%USE_TABLE
static const uint8_t MAT24_XI_G_COCODE_TABLE[64] = { 
// %%TABLE Mat24_xi_g_cocode_table , uint8
0x00,0x20,0x9c,0xbc,0x9a,0xba,0x86,0xa6,
0x96,0xb6,0x8a,0xaa,0x8c,0xac,0x10,0x30,
0x8e,0xae,0x92,0xb2,0x94,0xb4,0x08,0x28,
0x98,0xb8,0x04,0x24,0x02,0x22,0x1e,0x3e,
0x81,0x21,0x1d,0xbd,0x1b,0xbb,0x07,0xa7,
0x17,0xb7,0x0b,0xab,0x0d,0xad,0x91,0x31,
0x0f,0xaf,0x13,0xb3,0x15,0xb5,0x89,0x29,
0x19,0xb9,0x85,0x25,0x83,0x23,0x9f,0x3f
};


#define compress_gray(x) (((x) & 0x1f) + (((x) >> 6) & 0x20))

#define expand_gray(x)  (((x) & 0x1f) + (((x) & 0x20) << 6))

// %%EXPORT p
uint32_t mat24_xi_g_gray(uint32_t v1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_g_gray
// Implement function gamma() in [Seys19], section 3.3.
// 
// Given a Golay code vector v  in 'gcode' representation, see
// module mat24.py, we return the element gamma(v) of the Golay
// cocode, with gamma() as in [Seys19], section 3.3. c is
// returned in 'cocode' representation, see module mat24.py.
{
    return expand_gray(MAT24_XI_G_GRAY_TABLE[compress_gray(v1)]);
}


// %%EXPORT p
uint32_t mat24_xi_w2_gray(uint32_t v1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_w2_gray
// Implement function w2() in [Seys19], section 3.3.
// 
// Given a Golay code vector v  in 'gcode' representation, see
// module mat24.py, we return the bit w2 = w2(c), with w2() as
// defined in [Seys19], section 3.3.
{
    return MAT24_XI_G_GRAY_TABLE[compress_gray(v1)] >> 7;
}


// %%EXPORT p
uint32_t mat24_xi_g_cocode(uint32_t v1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_g_cocode
// Inverse of method xi_w2_gray(v)
// 
// Given a cocode vector c in in 'cocode' representation, see
// module mat24.py, the function returns the unique gray Golay
// code vector v such tha cls.xi_w2_gray(v) is the gray part
// of c.
{
    return expand_gray(MAT24_XI_G_COCODE_TABLE[compress_gray(v1)]);
}


// %%EXPORT p
uint32_t mat24_xi_w2_cocode(uint32_t v1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_w2_cocode
// Implement function w2() in [Seys19], section 3.3.
// 
// Given a cocode vector c in in 'cocode' representation, see
// module mat24.py, the function returns the bit w2 = w2(c),
// with w2() as defined in [Seys19], section 3.3.
{
    return MAT24_XI_G_COCODE_TABLE[compress_gray(v1)] >> 7;
}


// %%EXPORT p
uint32_t mat24_xi_op_leech(uint32_t x1, uint32_t u_exp)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_op_leech
// Operation of  xi**exp  on the element x of the group Q_x0.
// 
// The function returns the element
// 
//     xi**(-exp)  *  x  *  xi**exp
// 
// of the group Q_x0. The element x of Q_x0 as must be given in
// Leech lattice encoding, as described in the header of this
// module.
// 
// The returned result is is coded in the same way.
{
    uint_fast32_t tv, tc; 
    // reduce u_exp mod 3, no action if u_exp is 0 (mod 3)
    if ((u_exp = u_exp % 3) == 0) return x1;
    // map u_exp = 1, 2   to  u_exp = -1,  0
    u_exp -= 2;   
    // transform standard to internal Leech lattice rep
    x1 ^= MAT24_THETA_TABLE[(x1 >> 13) & 0x7ff] & 0xfff; 
    // put tv = scalar product of gray parts of code and cocode
    tv = (x1 >> 12) & x1 & 0x81f;
    tv = 0x96696996UL >> ((tv ^ (tv >> 11)) & 0x1f);
    // xor scalar product to sign
    x1 ^= (tv & 1)  << 24; 
    // tv = w2(code), g(code);   tc = w2(cocode), g(cocode);      
    tv = MAT24_XI_G_GRAY_TABLE[compress_gray(x1 >> 12)]; 
    tc = MAT24_XI_G_COCODE_TABLE[compress_gray(x1)];
    // if old u_exp = 1: x1 &= ~0x81f000, i.e. kill gray code part
    // if old u_exp = 2: x1 &= ~0x81f, i.e. kill gray cocode part
    x1 &= ~(0x81fUL << (u_exp & 12)); 
    // xor g(code) to cocode and g(cocode) to code
    x1 ^= expand_gray(tv);       // xor g(code) to cocode
    x1 ^= expand_gray(tc) << 12; // xor g(cocode) to code
    // if old u_exp = 1: x1 ^= (tc>>7)<<24 // xor w2(cocode) to sign
    // if old u_exp = 2: x1 ^= (tv>>7)<<24 // xor w2(code) to sign
    tv ^= (tc ^ tv) & u_exp; 
    x1 ^= (tv >> 7) << 24;
    // transform back to standard  Leech lattice rep
    x1 ^= MAT24_THETA_TABLE[(x1 >> 13) & 0x7ff] & 0xfff; 
    return x1;
}



// %%EXPORT p
uint32_t mat24_xi_mul_leech(uint32_t x1, uint32_t x2)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_mul_leech
// Return product of two elements the group  Q_x0.
// 
// The two factors X1, X1 are coded as integers x1, x2 as in
// method xi_op_leech. The product is returned in the same form.
{
    uint_fast32_t scalar;      
    x1 ^= MAT24_THETA_TABLE[(x1 >> 13) & 0x7ff] & 0xfff;
    x2 ^= MAT24_THETA_TABLE[(x2 >> 13) & 0x7ff] & 0xfff;
    scalar = (x2 >> 12) &  x1 & 0xfff;
    scalar ^= scalar >> 6;
    scalar ^= scalar >> 3;
    scalar = (0x96 >> (scalar & 7)) & 1;
    x1 ^= x2 ^ (scalar << 24);
    x1 ^= MAT24_THETA_TABLE[(x1 >> 13) & 0x7ff] & 0xfff;
    return x1;
}

// %%EXPORT p
uint32_t mat24_xi_leech_to_short(uint32_t x1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_leech_to_short
// Convert Leech lattice to short vector encoding.
// 
// Both, Leech lattice and short vector encoding of a short vector
// in Q_x are decribed in the header of this module. The function
// returns the short vector encoding of element x1 given in Leech
// lattice encoding.
// 
// The function returns 0 if the vector x1 is not short.
{
    uint32_t  gcodev, cocodev, sign, w, box = 0, code = 0;
    sign = (x1 >> 24) & 1;
    gcodev = mat24_gcode_to_vect(x1 >> 12);
    cocodev = mat24_cocode_syndrome(x1, mat24_lsbit24(gcodev));
    // put w = weight(code word gcodev) / 4
    w = - ((x1 >> 12) & 1);
    w = (((MAT24_THETA_TABLE[(x1>>13) & 0x7ff] >> 12) & 7) ^ w) 
                 + (w & 7);  
    if (x1 & 1) {  // case odd cocode
        uint_fast32_t scalar;      
        if (cocodev & (cocodev - 1)) return 0;
        scalar = (x1 >> 12) &  x1 & 0xfff;
        scalar ^= scalar >> 6;
        scalar ^= scalar >> 3;
        scalar = (0x96 >> (scalar & 7));
        if ((scalar ^ w) & 1) return 0;
        code = ((x1 & 0xffe000) >> 8) | mat24_lsbit24(cocodev);
        box = 4 + (code >> 15);
        code &= 0x7fff;
    } else {       // case even cocode
        uint_fast32_t  c, y1, y2;
        switch (w) {
            case 4:
                gcodev ^= 0xffffff;
                x1 ^= 0x1000;
                // fall through to case 2
            case 2:
                c =  mat24_extract_b24(cocodev, gcodev);
                // put y2 = bitweight(c) (mod 4); here c < 256
                y2 = (c & 0x55) + ((c & 0xaa) >> 1);
                y2 = (y2 & 0x33) + ((y2 & 0xcc) >> 2);
                y2 = (y2 + (y2 >> 4));
                if ( (cocodev & gcodev) != cocodev
                    ||  (y2 ^ 2 ^ w) & 3 ) return 0;
                c ^=  (-(c >> 7)) & 0xff; 
                code = (c >> 1) | (mat24_gcode_to_octad(x1 >> 12) << 6);
                if (code >= 24000) { 
                    //  24000 = (15 + 360) * 64
                    code -= 24000; box = 3;
                } else if (code >= 960) {
                    //  960 = 15 * 64
                    code -= 960; box = 2;
                } else {
                    code += 1536;  box = 1;
                }
                break;
            case 3:
                return 0;
            default:  // can be case 0 or 6 only
                y1 = mat24_lsbit24(cocodev); 
                cocodev ^= 1 << y1;  
                y2 = mat24_lsbit24(cocodev); 
                if (cocodev != (1 << y2) || y1 >= 24)  return 0;
                code = 384 * (w & 2) + (y2 << 5) + y1;
                box = 1;
                break;
        }
    } 
    return (sign << 15) + (box << 16) + code;
}


// %%EXPORT p
uint32_t mat24_xi_short_to_leech(uint32_t x1)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_short_to_leech
// Convert short vector to Leech lattice encoding.
// 
// Both, Leech lattice and short vector encoding of a short vector
// in Q_x are decribed in the header of this module. The function
// returns the Leech lattice encoding of element x1 given in short
// vector encoding.
// 
// The function returns 0 for an illegal input x1.
{
    uint_fast32_t sign = (x1 >> 15) & 1;
    uint_fast32_t code = x1 & 0x7fff;
    uint_fast32_t gcode = 0, cocode = 0, octad = 0xffff;
    switch(x1 >> 16) {
        case 1:
            if (code < 1536) {  
                //  1536 = 2 * 24 * 32 
                uint_fast32_t i, j;
                gcode = code >= 768;
                code -= -gcode & 768;
                i = code >> 5; j = code & 31;
                cocode = mat24_vect_to_cocode((1 << i) ^ (1 << j));
                if (cocode == 0  || cocode & 1) return 0;
            } else if (code < 2496) { 
                // 2496 = 2 * 24 * 32 + 15 * 64 
                octad = code - 1536;
            } else return 0;
            break;
        case 2:
            if (code >= 23040) return 0; // 23040 = 360 * 64     
            octad = code + 960;  //  960 = 15 * 64  
            break;
        case 3:
            if (code >= 24576) return 0; // 24576 = 384 * 64     
            octad = code + 24000;  //  24000 = (15 + 360) * 64  
            break;
        case 5:
            code += 0x8000;
            // fall through to case 3
        case 4:
            {
                uint_fast32_t w;
                cocode = mat24_vect_to_cocode(1 << (code & 31));
                if (cocode == 0) return 0;
                gcode = (code >> 4) & 0xffe;
                //w =  mat24_gcode_weight(gcode) 
                //        ^ mat24_scalar_prod(gcode, cocode); 
                w = ((MAT24_THETA_TABLE[gcode >> 1] >> 12) & 1)
                 ^ (gcode & cocode);
                w ^= w >> 6;
                w ^= w >> 3;
                w = 0x96 >> (w & 7);
                gcode ^= w & 1;
            }
            break;
        default:
            return 0;
    }
    if (octad < 48576) {
        // 48756 = 759 * 64 
        uint_fast32_t cc, w, gcodev;
        cc = octad & 0x3f;
        w = (cc & 0x55) + ((cc & 0xaa) >> 1);
        w = (w & 0x33) + ((w & 0xcc) >> 2);
        w = (w + (w >> 4)) & 0xf;
        cc = (cc << 1) ^ (w & 1);
        w += w & 1;
        gcode = MAT24_OCT_DEC_TABLE[octad >> 6] & 0xfff;
        gcodev = mat24_gcode_to_vect(gcode);
        cocode = mat24_vect_to_cocode(mat24_spread_b24(cc, gcodev));
        gcode ^=  ((w >> 1) & 1);
    }
    return (sign << 24) | (gcode << 12) | cocode; 
}


// %%EXPORT p
uint32_t mat24_xi_op_short(uint32_t x1, uint32_t u_exp)
// %%COMMENT
// %%PY_DOCSTR Mat24Xi_doc.xi_op_short
// Operation of  xi**exp  on the element x of the group Q_x0.
// 
// The function returns the element
// 
//     xi**(-exp)  *  x  *  xi**exp
// 
// of the group Q_x0. The element x of Q_x0 as must be given in
// short vector encoding, as described in the header of this
// module.
// 
// The returned result is is coded in the same way.
{
    uint_fast32_t y = mat24_xi_short_to_leech(x1);
    if (y == 0) return x1;
    y = mat24_xi_op_leech(y, u_exp);
    if (y == 0) return x1;
    y = mat24_xi_leech_to_short(y);
    return y ? y : x1;
}



// %%EXPORT p
uint32_t mat24_xi_make_table(uint32_t u_box, uint32_t u_exp, uint16_t *ptab)
// generate table, yet to be documented!!
{
    static uint16_t t_size[6] = {
        0, 2496, 23040, 24576, 32768, 32768
    };
    uint_fast32_t i, len = u_box < 6 ? t_size[u_box] : 0;
    u_box <<= 16;
    for (i = 0; i < len; ++i) ptab[i] = 
         (uint16_t)(mat24_xi_op_short(u_box + i, u_exp) & 0xffff);
    return len;
}


// %%EXPORT p
void mat24_xi_invert_table(uint16_t *ptab, uint32_t len, uint32_t ncols, uint16_t *pres, uint32_t len_res)
// invert table, yet to be documented!!
{
    uint_fast32_t i, r;
    for (i = 0; i < len_res; ++i) pres[i] = 0;

    for (i = 0; i < len; ++i) {
        r = ptab[i];
        if ((i & 31) < ncols && (r & 0x7fff) < len_res) {
            pres[r & 0x7fff] = i | (r & 0x8000);
        }
    }
}



// %%EXPORT p
void mat24_xi_split_table(uint16_t *ptab, uint32_t len, uint32_t mod, uint32_t *psign)
// split table, yet to be documented!!
{
    uint_fast32_t i, j, r, sign;
    len >>= 5;
    for (i = 0; i < len; ++i) {
         sign = 0;
         for (j = 0; j < 32; ++j) {
             r = *ptab;
             *ptab++ = (uint16_t)((r & 0x7fff) % mod); 
             sign += ((r >> 15) & 1) << j;
         }
         *psign++ = sign;
    }
}



// %%GEN ch
#ifdef __cplusplus
}
#endif
// %%GEN h
// #endif  // #ifndef MAT24_FUNCTIONS_H
// 
// 
// 
// 
