/////////////////////////////////////////////////////////////////////////////
// This C file has been created automatically. Do not edit!!!
/////////////////////////////////////////////////////////////////////////////

// %%COMMENT
// This is a C implementation of the functionality of Python class
// Mat24 as described in the sequel. Note that all exported funtions
// in this module are prefixed with 'mat24_'

// %%COMMENT
// %%PY_DOCSTR Mat24_doc
// Provide functions for the Mathieu group Mat24 and the Parker loop.
// 
// The Golay code C and its codode C*
// ----------------------------------
// 
// The Mathieu group Mat24 operates as a permutation group on a set of
// 24 elements which we label with numbers 0,...,23 for use in Python
// and C. So it also operates on a vector space V = GF(2)**24, with
// GF(2) = {0,1}.
// 
// A vector v in a vector space over GF(2) is called a bit vector. We
// represent a bit vector as an integer, so that the i-th bit of v
// (with valence 2**i) is the i-th component of v.
// 
// Mat24 is the automorphism group of the binary [24,12,8] Golay code C
// So C is a 12-dimensional subspace of V. Code words in C have weight
// 0, 8, 12, 16 or 24. Up to isomorphism there is only one such Golay
// code. Our Golay code in V is compatible to the 'MOG' in [CoSl99],
// Ch. 11 with numbering of the unit vectors in V as follows:
// 
//                      +------------------------+
//                      |  0   4   8  12  16  20 |
//                      |  1   5   9  13  17  21 |
//                      |  2   6  10  14  18  22 |
//                      |  3   7  11  15  19  23 |
//                      +------------------------+
// 
// 
// There are member functions for checking and completing codewords and
// for getting the syndrome or the type (i.e. the orbit under Mat24) of
// a 24-bit vector.
// 
// All relevant functions in this python class are implemented as
// class methods. There are also corresponding funtions implemented
// in C.
// 
// We internally use a basis of GF(2**24) such that the first 12 basis
// vectors are a transversal of the Golay cocode and the last 12 basis
// vectors span the Golay code. Here '**' means exponentiation. Our
// cocode basis is the reciprocal basis of the Golay code basis.
// 
// The assured properties of the (transversal of the) cocode basis are:
// 
//     - All basis vectors except vector 0 have an even number of ones.
//     - Basis vector 0 has a one in row 0, column 0 only.
//     - Basis vectors 0,...,4 and 11 have ones in row 0 only.
//     - The other basis have two nonzero entries in the last 3 rows
//       of exactly one column and zero entries everywhere else.
//     - Basis vector 11 (i.e. the last one) has ones precisely in all
//       six columns of row 1
// 
// The assured properties of the basis of the Golay code are:
// 
//     - Basis vector 0 has 24 ones, all other basis vectors have
//       weight 8 or 16.
//     - All but basis vector 11 are even interpretations of the MOG,
//       i.e. the first MOG row and all MOG columns have even bit weight.
//     - In the first five basis vectors the entries in each column
//       are equal.
//     - Basis vectors 5,...,10  have zero entries in row 0.
//     - Basis vector 11 has ones precisely in row and column 0, except
//       for intersection of row and column 0, where it is zero.
// 
// The user may rely on these properties for operations on the vectors.
// 
// We represent vector in V, C and V* and in sthe subspace of
// octads of C as follows:
// 
// The 759 octads are numbered from 0 to 758. This is not a vector space.
// The 2**12 code words are represented as binary numbers 0 to 4095.
// The 2**12 cocode words are represented as binary numbers 0 to 4095.
// 
// As usual, binary numbers representing bit vectors are added with the
// XOR operation '^'. Unused high bits are ignored. The 2**12 code words
// and the 2**12 cocode words mentioned above can be added with '^'.
// 
// Member functions changing from one representation xxx to another
// representation yyy are named xxx_to_yyy, where xxx, yyy is as follows:
// 
// vect :     standard representation of a bit vector in V = GF(2)**24
//            coded as a 24-bit integer.
// vintern:   internal representation a bit vector in V as a vector in
//            the basis given above, coded as 24-bit integer.
// gcode:     representation of a Golay code word in the basis given
//            given above, coded as 12-bit integer. Here we simply take
//            the upper 12 bits of the internal representation.
// octad:     representation as an octad numbered from 0 to 758
//            (in lexical order given by representation  'gcode')
// cocode:    representation as a cocode word in the basis given above,
//            coded as 12-bit integer. Here we simply take the lower
//            12 bits of the internal representation.
// 
// 
// All these representations are given as integers.
// 
// We implement the following conversion functions:
// 
//     vect_to_vintern, vintern_to_vect, vect_to_cocode,
//     vintern_to_vect, gcode_to_vect, cocode_to_vect.
// 
// Here irrelevant bits of the input are ignored. cocode_to_vect
// returns one of many possible solutions.
// 
// In the following functions the input is checked and an exception
// is raised in case of an error:
// 
//     vect_to_gcode,   vect_to_octad,   gcode_to_octad,
//     octad_to_vect, octad_to_gcode
// 
// Here we raise an exception if the given input is not a code word
// or an octad, as required by the member function. The correspinding
// C functions returns -1 (casted to the appropriate unsigned integer
// type) in case of any error.
// 
// Function syndrome() takes a vector v and calculates its syndrome,
// which is a vector of minimum weight equivalent to v modulo the
// Golay code. Function cocode_syndrome() takes a 'cocode'
// representation as a cocode word instead.
// 
// Function scalar_prod() returns the scalar product of a Golay code
// vector in 'gcode' and a cocode vector in 'cocode' representation.
// 
// 
// The Mathieu group Mat24
// -----------------------
// 
// This class also contains support for the Mathieu group Mat24.
// An element of Mat24 can be represented in one of the following ways:
// 
// perm:     Representation as a array of length 24 encoding a
//           permutation of the integers 0,...,23 as a mapping.
// 
// m24num:   Representation as an integer 0 <= i < 244823040. The
//           identity permutation is coded as 0. Other codes are
//           more or less arbitrary, see function m24num_to_perm().
// 
// matrix:   Representation as a 12 x 12 bit matrix acting on the Golay
//           code by right multiplication. This matrix acts on a Golay
//           code vectors (given in the 'gcode' representation) by
//           right multiplication.
//           Such a matrix is implemented as an array of integers with
//           each integer corresponding to a row vector of the matrix.
//           The raison d'etre of this representation is to support
//           the Parker loop and its automorphism group. Therefore a
//           row vector is implemented as a 32-bit integer.
// 
// We implement the following conversion functions
// 
//     m24num_to_perm, perm_to_m24num, perm_to_matrix, matrix_to_perm.
// 
// There is a function perm_check() for checking if an array of
// length 24 really represents an element of the Mathieu group Mat24.
// All other function operating on Mat24 in any way do not check if
// their inputs are really in Mat24. They will output garbage on bad
// input, but they are not suppused to crash.
// 
// The easiest way to create a random element of Mat24 is to create
// a random integer 0 <= n < 244823040, and to call function
// m24num_to_perm(x). You can use functions perm_from_heptads() or
// perm_complete_heptad() to create specific elements, see
// documentation of these function for details. The group Mat24 is
// discussed in detail in [CoSl99] Ch. 11.
// 
// 
// Operation of the group Mat24 on vectors
// ---------------------------------------
// 
// Elements of Mat24 operate from the right on vectors in V = (2)**24
// or on Golay code or cocode vectors, as usual in finite group theory.
// A function performing such an operation has the name
// 
//         op_<vector>_<group>
// 
// where <vector> indicates the representation of the vector space and
// <group> indicates the representation of the group. We implement the
// functions
// 
//     op_vect_perm, op_gcode_matrix, op_gcode_perm, op_cocode_perm.
// 
// E.g. op_gcode_matrix operates on a Golay code word (in 'gcode'
// representation) by right multiplying an element m of Mat24 with it.
// Here element m is a 12 x 12 matrix (in 'matrix' representation').
// 
// 
// Group operation in the group Mat24
// ----------------------------------
// 
// Multiplication and inversion in the group mat2 is supported for
// the permutation representation 'perm'. Therefore we have functions
// 
//      mul_perm, inv_perm
// 
// 
// 
// The Parker loop Pl
// ------------------
// 
// We support the Parker loop Pl and also its automorphism group.
// 
// The Parker loop Pl is nonassociative loop with a central element
// -1 such that Pl/{1,-1} = C, with C the Golay code. We choose a
// transversal of C in Pl and write the elements of Pl as pairs
// (v, s) with v in C and s in {1,-1} and multiplication rule
// 
//   (v1, s1) * (v2, s2) = (v1 + v2, s1 * s2 * (-1)**theta(v1, v2)),
// 
// where the cocycle theta is quadratic in the first and linear in
// the second element. So theta can also be considered as a
// quadratic form on the Golay code C with values in the cocode C*.
// 
// An element (v, (-1)**i) of the Parker loop Pl is represented as
// a 13-bit integer, with bits 0,...,11 the Golay code word in
// 'gcode' representation, and bit 12 the sign bit s. We call this
// representation of the Parker loo the 'ploop' representation.
// So we can convert and element of C in 'gcode' representation
// to an element pf Pl in 'ploop' representation by adjusting the
// sign in bit 12.
// 
// Function ploop_theta(v) returns the element theta(v) of C* in
// 'cocode' representation. Parameter v must be an element of C
// or Pl in 'gcode' or 'ploop' representation. Similarly, function
// ploop_cocode(v1, v2) returns the value of the coycle
// theta(v1, v2), which is 0 or 1.
// 
// Function mul_ploop() returns the product of two elements of
// the Parker Loop. Function inv_ploop() returns the inverse of
// ab element of the Parker loop.
// 
// 
// The group AutPl of standard automorphisms of the Parker loop Pl
// ---------------------------------------------------------------
// 
// An automorphism of the Parker loop is implemented as an array a
// of twelve 32-bit integers. The lowest 13 bits of a[i] encode the
// image of the i-th basis vector of the Parker loop. Here the basis
// of Parker Loop corresponds to the basis of the Golay code, and
// each basis vector has positive sign.
// 
// The bits 13..24 of the vectors a[i] ancode a quadratic form which
// faciliates computations in AutPl. A description of the quadratic
// form is out of the scope of this document.
// 
// This representation of AutPl is called the 'autpl' representation.
// We only use the 'autpl' representaion for elements of AutPl.
// 
// Function perm_to_autpl(c, p) returns an automorphism of the
// Parker loop created from a element p of Mat24 in 'perm'
// representation and a cocode element c in 'cocode' representation.
// 
// For m = perm_to_autpl(c, p) we can get back p and c be computing
// p = autpl_to_perm(m) and c = autpl_to_cocode(m).
// 
// m = cocode_to_autpl(c) returns the same result as
// m = perm_to_autpl(c, p) with the identity permutation p.
// Note that
// 
//  perm_to_autpl(c, p) = cocode_to_autpl(c) * perm_to_autpl(0, p).
// 
// The automorphism perm_to_autpl(0, p) maps the basis vectors
// (b_i, 0) of the Parker loop to some elements (b'_i, 0) of the
// Parker loop, with the Golay code automorphism b_i -> b'_i given
// by the permutation p.
// 
// Function op_ploop_autpl(v, m) applies Parker loop automorphism m
// to cocode vector v and returns the result. Here all cocode
// vectors are given in 'cocode' representation. We assume that
// Parker loop automorphisms operate by right multiplication on Pl.
// 
// Function mul_autpl(m1, m2) returns the product m1 * m2 of the
// Parker loop automorphisms m1 and m2. Function inv_autpl(m1)
// returns the inverse of the Parker loop automorphism m1.
// 
// 
// Auxiliary functions
// ------------------
// Here is an overview of some auxiliary functions in this class.
// They are described in the corresponding function documentation.
// 
// bw24          bit weight of the lowest 24 bits of an integer
// lsbit24       min(24, least significant bit pos.) for an integer
// gcode_weight  weight of a Golay code word in 'gtype' representation
// vect_type     orbit of a vector in V under the group Mat24
// vect_to_bit_list
//               given a bit vector in V, it returns the lists of
//               the positions of the 0 bits and of the 1 bits of v.
// extract_b24   extract bits from bit vector using a 24-bit mask
// spread_b24    spread bit vector according to a 24-bit mask
// 
// 
// Internal operation
// ------------------
// 
// For switching from the standard representation to the internal
// representation we use 3 tables with 2**8 entries of 24 bit length.
// For switching back from internal to standard representation we use
// 3 other tables of the same format. There are also tables for
// computing the syndrome of a vector in V with respect to the Golay
// code.
// 
// 
// Abbreviations for functions and parameters in this class
// --------------------------------------------------------
// 
// The following list of abbreviations used in names of functions
// allows to guess the action of most functions in this module:
// 
// abbreviation  meaning                                   data type
// 
// assoc         associator (in Golay code or Pl)
// autpl         autmorphism of the Parker loop Pl         uint32_t[12]
// bw24          bit weight of the lowest 24 bits of an int
// cap           intersection (of Golay code elements)
// cocode        element of Golay cocode C*                uint32_t
// cocycle       cocycle:  Pl times Pl  ->  {0,1}
// comm          commutator (in Golay code or Pl)
// gcode         element of Golay code C                   uint32_t
// inv           inversion (in Mat24, Pl, or AutPl)
// lsbit24       least significant bit of an integer,
//               counting bits 0,...,23 only
// m24num        number of an element of Mat24             uint32_t
// matrix        element of Mat24 as binary matrix
//               acting on the Golay code C                uint32_t[12]
// mul           multiplication (in Mat24, Pl, or AutPl)
// net           Benes network for an element of Mat24     uint32_t[9]
// octad         number of an octad, i.e. a Golay code
//               element of weight 8                       uint32_t
// op            op_<vector>_<operation> means:
//               apply <operation> to <vector>
// op_all        apply operation to all vectors
// perm          element of Mat24 as a permutation         uint8_t[24]
// ploop         element of the Parker loop Pl             uint32_t
// pow           power operator (in Pl)
// scalar_prod   scalar product (of Golay code and cocode)
// suboctad      suboctad, see function suboctad_to_cocode
// syndrome      syndrome (after decoding Golay code)      uint32_t
// theta         cocycle theta: Pl -> C^* in Parker loop
// to            <x>_to_<y> means: return representation <y>
//               of an object given in representation <x>
// vect          vector in V = GF(2)**24                   uint32_t
// vintern       vector in V, in internal representation   uint32_t
// 
// 
// Parameters of functions are either integers or arrays of integers.
// Here all integer types are unsigned and of fixed length, such as
// uint8_t, uint16_t or uint32_t.
// 
// The type of a parameter is given by a single letter in the name
// of the parameter:
// 
// name  meaning                                           type
// a     array specified in documentation of function      unspecified
// c     Golay cocode element, represented as 'cocode'     uint32_t
// m     permutation in Mat24 or automorphism of Pl
//       represented as a bit matrix                       uint32_t[12]
// p     permutation in Mat24 represented as 'perm'        uint8_t[24]
// u_<x> unsigned integer, e.g.                            unspecified
//        u_exp:   integer denoting an exponent
//        u_m24:   number of a permutation in Mat24
//        u_octad: number of octad, 0 < u_octad < 259
//        u_width: integer denoting a bit width
// v     vector in V, Golay code C or Parker loop Pl
//       represented as vect, vintern, gcode or ploop      uint32_t
// 
// Integer input parameters have shape u_<x>, e.g. u_m24, u_exp.
// An integer computed by a function is returned as return value.
// Input array parameters have a digit as a suffix, e.g.: v1, v2, m1.
// Output array parameters have the suffix _out, e.g.: p_out.
// Input/output array parameters  have the suffix _io, e.g.: m_io.
// 
// References
// ----------
// 
// See file references.txt


// %%COMMENT
// %%PY_DOCSTR  Mat24_doc_basis
// We list the basis vectors of the Golay code and of its cocode.
// 
// Basis vectors have indices 0,...,11. Each basis vector is displayed
// as a hexadecimal number with bit i (of valence 2**i) corresponding
// to component i of the basis vector in GF(2)^24 for i = 0,...,23.
// Golay cocode vectors are to be understood modulo the Golay code.
// 
// Golay cocode basis
//     000001 000110 001010 010010 100010 000600
//     000a00 000060 0000a0 000006 00000a 111111
// Golay code basis
//     ffffff fff0f0 ff0ff0 f0fff0 0ffff0 aaaa00
//     666600 c6a0a0 ac6060 6ca00a ca6006 11111e


/*************************************************************************
** External references 
*************************************************************************/




#include <stdint.h>
// #include <stdio.h>
#include <string.h>
#include "mat24_functions.h"


// %%EXPORT_KWD MAT24_API


// %%GEN h
// #ifndef MAT24_FUNCTIONS_H
// #define MAT24_FUNCTIONS_H
// 
// #include <stdint.h>
// 
// #define MAT24_DLL  // We want a DLL!!
// 
// 
// // Generic helper definitions for shared library support
// #if defined _WIN32 || defined __CYGWIN__
//   #define MAT24_HELPER_DLL_IMPORT __declspec(dllimport)
//   #define MAT24_HELPER_DLL_EXPORT __declspec(dllexport)
//   #define MAT24_HELPER_DLL_LOCAL
// #else
//   #if __GNUC__ >= 4
//     #define MAT24_HELPER_DLL_IMPORT __attribute__ ((visibility ("default")))
//     #define MAT24_HELPER_DLL_EXPORT __attribute__ ((visibility ("default")))
//     #define MAT24_HELPER_DLL_LOCAL  __attribute__ ((visibility ("hidden")))
//   #else
//     #define MAT24_HELPER_DLL_IMPORT
//     #define MAT24_HELPER_DLL_EXPORT
//     #define MAT24_HELPER_DLL_LOCAL
//   #endif
// #endif
// 
// 
// // Now we use the generic helper definitions above to define MAT24_API 
// // and MAT24_LOCAL.
// // MAT24_API is used for the public API symbols. It either DLL imports 
// // or DLL exports (or does nothing for static build). 
// // MAT24_LOCAL is used for non-api symbols.
// 
// #ifdef MAT24_DLL // defined if FOX is compiled as a DLL
//   #ifdef MAT24_DLL_EXPORTS // defined if we are building the FOX DLL 
//                            // (instead of using it)
//     #define MAT24_API MAT24_HELPER_DLL_EXPORT
//   #else
//     #define MAT24_API MAT24_HELPER_DLL_IMPORT
//   #endif // MAT24_DLL_EXPORTS
//   #define MAT24_LOCAL MAT24_HELPER_DLL_LOCAL
// #else // MAT24_DLL is not defined: this means FOX is a static lib.
//   #define MAT24_API
//   #define MAT24_LOCAL
// #endif // MAT24_DLL
// 
// 
// 
// #define MAT24_ORDER 244823040 // Order of Mathieu group Mat24
// 
// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


// %%COMMENT
/*************************************************************************
*** Some general bit operations
*************************************************************************/

// %%USE_TABLE
static const uint8_t MAT24_LSBIT_TABLE[32] = { 
// %%TABLE Mat24_lsbit_table, uint8
0x18,0x00,0x18,0x01,0x18,0x0d,0x17,0x02,
0x18,0x15,0x13,0x0e,0x18,0x10,0x03,0x07,
0x18,0x18,0x0c,0x16,0x14,0x12,0x0f,0x06,
0x18,0x0b,0x11,0x05,0x0a,0x04,0x09,0x08
};


// Comppute index of least significant bit of an integer v1
// If v1 & 0xffffff is zero then 24 is computed  
#define mat24_def_lsbit24(x) MAT24_LSBIT_TABLE[(0x077cb531UL *  \
        ((x) & -(x)) >> 26) & 0x1f]


// Same as mat24_def_lsbit24(x), assuming that x is a power of two
#define mat24_def_lsbit24_pwr2(x)  MAT24_LSBIT_TABLE[(0x077cb531UL *  \
        (x) >> 26) & 0x1f]


// %%EXPORT p
MAT24_API
uint32_t mat24_lsbit24(uint32_t v1)
// Return index of least significant bit of an integer v1.
// If v1 & 0xffffff is zero then 24 is returned.  
{
    // This is a modification of
    // http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup
    // which returns 24 if v1 & 0xffffff is zero.
    // return MAT24_LSBIT_TABLE[(((v1 & -v1) * 0x077CB531L) >> 26) & 0x1f];
    return MAT24_LSBIT_TABLE[(0x077cb531UL *  \
            ((v1) & -(v1)) >> 26) & 0x1f];
}
        
// %%EXPORT p
MAT24_API
uint32_t mat24_bw24(uint32_t v1)
// returns the bit weight of the lowest 24 bits of v1
{
   v1 = (v1 & 0x555555) + ((v1 & 0xaaaaaa) >> 1); 
   v1 = (v1 & 0x333333) + ((v1 & 0xcccccc) >> 2);
   v1 = (v1 + (v1 >> 4)) & 0xf0f0f;
   return (v1 + (v1 >> 8) + (v1 >> 16)) & 0x1f; 
}    



/*************************************************************************
*** Conversion between bit vectors of GF(2)**24
*************************************************************************/



// %%EXPORT p
MAT24_API
uint32_t mat24_vect_to_bit_list(uint32_t v1, uint8_t *a_out)
// Stores the positions of 1-bits of v to the array referred by a_out).
// 
// Let w be the bit weight of v & 0xffffff, i.e. number n of bits 
// of v at positions < 24 equal  to one. Then the ordered bit
// positions where the corrsponding bit of v is 1 are stored in
// a_out[0],...,a_out[w-1]. 
// Then v & 0xffffff has 24 - w zero bits. The ordered list of the
// positions of these zero bits is stored in a_out[w],...,a_out[23]. 
// 
// The function returns w.
{
    uint_fast32_t w, i, j;

    // put w = bit_weight(v1 & 0xffffff)
    w = (v1 & 0x555555) + ((v1 & 0xaaaaaa) >> 1);
    w = (w & 0x333333) + ((w & 0xcccccc) >> 2);
    w = (w + (w >> 4)) & 0xf0f0f;
    w = (w + (w >> 8) + (w >> 16)) & 0x1f; 
  
    // Separate bits:
    // i is the position and  o  is the value of the current bit of
    // the input vector v being processed (0 coded as 0, 1 coded as 8).
    // j & 0x1f is the position of the next index of the output vector 
    // where to write the position i in case o = 0.
    // (j >> 8) & 0x1f is the position of the next index of the output 
    // vector where to write the position i in case o != 0.
    v1 <<= 3;  // bit 0 of v1 is now at bit position 3
    j = w;    // start writing to pos. 0 if o = 0, to pos. w if o != 0
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = v1 & 8;   // o = value of current bit of v1
        a_out[(j >> o) & 0x1f] = i;  // write index i to the
                                     // appropriate output position
        j += 1 << o;                 // update both output positions
        v1 >>= 1;                    // process next bit of v1
    }
    return w;
}



// %%EXPORT p
MAT24_API
uint32_t mat24_extract_b24(uint32_t v1, uint32_t u_mask)
// Extract the bits of 24-bit vector v1 given by the mask u_mask
// 
// If u_mask has bits equal to one at positions i_0, i_1, ..., i_k
// (in ascending order) then the bit of v1 at position i_j is copied 
// to the bit at position j of the return value for j = 0,...,k.
{
    uint_fast32_t res = 0, sh = 0, i;
    v1 &= u_mask;
    for (i = 0; i < 24; ++i) {
        res |= ((v1 >> i) & 1) << sh;
        sh += (u_mask >> i) & 1;
    } 
    return res;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_spread_b24(uint32_t v1, uint32_t u_mask)
// Spread the bits of 24-bit vector v1 according to the mask u_mask
// 
// If u_mask has bits equal to one at positions i_0, i_1, ..., i_k,
// (in ascending order) then the bit of v1 at position i is copied 
// to the bit at position i_j of the return value for j = 0,...,k.
{
    uint_fast32_t res = 0, sh = 0, i;
    for (i = 0; i < 24; ++i) {
        res |= (((v1 >> sh) & 1) << i) & u_mask;
        sh += (u_mask >> i) & 1;
    } 
    return res;
}


// %%COMMENT
/*************************************************************************
*** Conversion between representations of GF(2)**24, Golay code, etc.
*************************************************************************/


// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE0[256] = {
// %%TABLE Mat24_enc_table0, uint32
0x00000000UL,0x00000001UL,0x00800e01UL,0x00800e00UL,
0x00800c01UL,0x00800c00UL,0x00000200UL,0x00000201UL,
0x00800a01UL,0x00800a00UL,0x00000400UL,0x00000401UL,
0x00000600UL,0x00000601UL,0x00800801UL,0x00800800UL,
0x0000081fUL,0x0000081eUL,0x0080061eUL,0x0080061fUL,
0x0080041eUL,0x0080041fUL,0x00000a1fUL,0x00000a1eUL,
0x0080021eUL,0x0080021fUL,0x00000c1fUL,0x00000c1eUL,
0x00000e1fUL,0x00000e1eUL,0x0080001eUL,0x0080001fUL,
0x0081f19fUL,0x0081f19eUL,0x0001ff9eUL,0x0001ff9fUL,
0x0001fd9eUL,0x0001fd9fUL,0x0081f39fUL,0x0081f39eUL,
0x0001fb9eUL,0x0001fb9fUL,0x0081f59fUL,0x0081f59eUL,
0x0081f79fUL,0x0081f79eUL,0x0001f99eUL,0x0001f99fUL,
0x0081f980UL,0x0081f981UL,0x0001f781UL,0x0001f780UL,
0x0001f581UL,0x0001f580UL,0x0081fb80UL,0x0081fb81UL,
0x0001f381UL,0x0001f380UL,0x0081fd80UL,0x0081fd81UL,
0x0081ff80UL,0x0081ff81UL,0x0001f181UL,0x0001f180UL,
0x0081f11fUL,0x0081f11eUL,0x0001ff1eUL,0x0001ff1fUL,
0x0001fd1eUL,0x0001fd1fUL,0x0081f31fUL,0x0081f31eUL,
0x0001fb1eUL,0x0001fb1fUL,0x0081f51fUL,0x0081f51eUL,
0x0081f71fUL,0x0081f71eUL,0x0001f91eUL,0x0001f91fUL,
0x0081f900UL,0x0081f901UL,0x0001f701UL,0x0001f700UL,
0x0001f501UL,0x0001f500UL,0x0081fb00UL,0x0081fb01UL,
0x0001f301UL,0x0001f300UL,0x0081fd00UL,0x0081fd01UL,
0x0081ff00UL,0x0081ff01UL,0x0001f101UL,0x0001f100UL,
0x00000080UL,0x00000081UL,0x00800e81UL,0x00800e80UL,
0x00800c81UL,0x00800c80UL,0x00000280UL,0x00000281UL,
0x00800a81UL,0x00800a80UL,0x00000480UL,0x00000481UL,
0x00000680UL,0x00000681UL,0x00800881UL,0x00800880UL,
0x0000089fUL,0x0000089eUL,0x0080069eUL,0x0080069fUL,
0x0080049eUL,0x0080049fUL,0x00000a9fUL,0x00000a9eUL,
0x0080029eUL,0x0080029fUL,0x00000c9fUL,0x00000c9eUL,
0x00000e9fUL,0x00000e9eUL,0x0080009eUL,0x0080009fUL,
0x0081f09fUL,0x0081f09eUL,0x0001fe9eUL,0x0001fe9fUL,
0x0001fc9eUL,0x0001fc9fUL,0x0081f29fUL,0x0081f29eUL,
0x0001fa9eUL,0x0001fa9fUL,0x0081f49fUL,0x0081f49eUL,
0x0081f69fUL,0x0081f69eUL,0x0001f89eUL,0x0001f89fUL,
0x0081f880UL,0x0081f881UL,0x0001f681UL,0x0001f680UL,
0x0001f481UL,0x0001f480UL,0x0081fa80UL,0x0081fa81UL,
0x0001f281UL,0x0001f280UL,0x0081fc80UL,0x0081fc81UL,
0x0081fe80UL,0x0081fe81UL,0x0001f081UL,0x0001f080UL,
0x00000100UL,0x00000101UL,0x00800f01UL,0x00800f00UL,
0x00800d01UL,0x00800d00UL,0x00000300UL,0x00000301UL,
0x00800b01UL,0x00800b00UL,0x00000500UL,0x00000501UL,
0x00000700UL,0x00000701UL,0x00800901UL,0x00800900UL,
0x0000091fUL,0x0000091eUL,0x0080071eUL,0x0080071fUL,
0x0080051eUL,0x0080051fUL,0x00000b1fUL,0x00000b1eUL,
0x0080031eUL,0x0080031fUL,0x00000d1fUL,0x00000d1eUL,
0x00000f1fUL,0x00000f1eUL,0x0080011eUL,0x0080011fUL,
0x00000180UL,0x00000181UL,0x00800f81UL,0x00800f80UL,
0x00800d81UL,0x00800d80UL,0x00000380UL,0x00000381UL,
0x00800b81UL,0x00800b80UL,0x00000580UL,0x00000581UL,
0x00000780UL,0x00000781UL,0x00800981UL,0x00800980UL,
0x0000099fUL,0x0000099eUL,0x0080079eUL,0x0080079fUL,
0x0080059eUL,0x0080059fUL,0x00000b9fUL,0x00000b9eUL,
0x0080039eUL,0x0080039fUL,0x00000d9fUL,0x00000d9eUL,
0x00000f9fUL,0x00000f9eUL,0x0080019eUL,0x0080019fUL,
0x0081f01fUL,0x0081f01eUL,0x0001fe1eUL,0x0001fe1fUL,
0x0001fc1eUL,0x0001fc1fUL,0x0081f21fUL,0x0081f21eUL,
0x0001fa1eUL,0x0001fa1fUL,0x0081f41fUL,0x0081f41eUL,
0x0081f61fUL,0x0081f61eUL,0x0001f81eUL,0x0001f81fUL,
0x0081f800UL,0x0081f801UL,0x0001f601UL,0x0001f600UL,
0x0001f401UL,0x0001f400UL,0x0081fa00UL,0x0081fa01UL,
0x0001f201UL,0x0001f200UL,0x0081fc00UL,0x0081fc01UL,
0x0081fe00UL,0x0081fe01UL,0x0001f001UL,0x0001f000UL
};

// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE1[256] = {
// %%TABLE Mat24_enc_table1, uint32
0x00000000UL,0x0000081dUL,0x0080307dUL,0x00803860UL,
0x0080305dUL,0x00803840UL,0x00000020UL,0x0000083dUL,
0x0080303dUL,0x00803820UL,0x00000040UL,0x0000085dUL,
0x00000060UL,0x0000087dUL,0x0080301dUL,0x00803800UL,
0x0000081bUL,0x00000006UL,0x00803866UL,0x0080307bUL,
0x00803846UL,0x0080305bUL,0x0000083bUL,0x00000026UL,
0x00803826UL,0x0080303bUL,0x0000085bUL,0x00000046UL,
0x0000087bUL,0x00000066UL,0x00803806UL,0x0080301bUL,
0x00fe57fbUL,0x00fe5fe6UL,0x007e6786UL,0x007e6f9bUL,
0x007e67a6UL,0x007e6fbbUL,0x00fe57dbUL,0x00fe5fc6UL,
0x007e67c6UL,0x007e6fdbUL,0x00fe57bbUL,0x00fe5fa6UL,
0x00fe579bUL,0x00fe5f86UL,0x007e67e6UL,0x007e6ffbUL,
0x00fe5fe0UL,0x00fe57fdUL,0x007e6f9dUL,0x007e6780UL,
0x007e6fbdUL,0x007e67a0UL,0x00fe5fc0UL,0x00fe57ddUL,
0x007e6fddUL,0x007e67c0UL,0x00fe5fa0UL,0x00fe57bdUL,
0x00fe5f80UL,0x00fe579dUL,0x007e6ffdUL,0x007e67e0UL,
0x00aa555bUL,0x00aa5d46UL,0x002a6526UL,0x002a6d3bUL,
0x002a6506UL,0x002a6d1bUL,0x00aa557bUL,0x00aa5d66UL,
0x002a6566UL,0x002a6d7bUL,0x00aa551bUL,0x00aa5d06UL,
0x00aa553bUL,0x00aa5d26UL,0x002a6546UL,0x002a6d5bUL,
0x00aa5d40UL,0x00aa555dUL,0x002a6d3dUL,0x002a6520UL,
0x002a6d1dUL,0x002a6500UL,0x00aa5d60UL,0x00aa557dUL,
0x002a6d7dUL,0x002a6560UL,0x00aa5d00UL,0x00aa551dUL,
0x00aa5d20UL,0x00aa553dUL,0x002a6d5dUL,0x002a6540UL,
0x005402a0UL,0x00540abdUL,0x00d432ddUL,0x00d43ac0UL,
0x00d432fdUL,0x00d43ae0UL,0x00540280UL,0x00540a9dUL,
0x00d4329dUL,0x00d43a80UL,0x005402e0UL,0x00540afdUL,
0x005402c0UL,0x00540addUL,0x00d432bdUL,0x00d43aa0UL,
0x00540abbUL,0x005402a6UL,0x00d43ac6UL,0x00d432dbUL,
0x00d43ae6UL,0x00d432fbUL,0x00540a9bUL,0x00540286UL,
0x00d43a86UL,0x00d4329bUL,0x00540afbUL,0x005402e6UL,
0x00540adbUL,0x005402c6UL,0x00d43aa6UL,0x00d432bbUL,
0x00d452bbUL,0x00d45aa6UL,0x005462c6UL,0x00546adbUL,
0x005462e6UL,0x00546afbUL,0x00d4529bUL,0x00d45a86UL,
0x00546286UL,0x00546a9bUL,0x00d452fbUL,0x00d45ae6UL,
0x00d452dbUL,0x00d45ac6UL,0x005462a6UL,0x00546abbUL,
0x00d45aa0UL,0x00d452bdUL,0x00546addUL,0x005462c0UL,
0x00546afdUL,0x005462e0UL,0x00d45a80UL,0x00d4529dUL,
0x00546a9dUL,0x00546280UL,0x00d45ae0UL,0x00d452fdUL,
0x00d45ac0UL,0x00d452ddUL,0x00546abdUL,0x005462a0UL,
0x002a0540UL,0x002a0d5dUL,0x00aa353dUL,0x00aa3d20UL,
0x00aa351dUL,0x00aa3d00UL,0x002a0560UL,0x002a0d7dUL,
0x00aa357dUL,0x00aa3d60UL,0x002a0500UL,0x002a0d1dUL,
0x002a0520UL,0x002a0d3dUL,0x00aa355dUL,0x00aa3d40UL,
0x002a0d5bUL,0x002a0546UL,0x00aa3d26UL,0x00aa353bUL,
0x00aa3d06UL,0x00aa351bUL,0x002a0d7bUL,0x002a0566UL,
0x00aa3d66UL,0x00aa357bUL,0x002a0d1bUL,0x002a0506UL,
0x002a0d3bUL,0x002a0526UL,0x00aa3d46UL,0x00aa355bUL,
0x007e07e0UL,0x007e0ffdUL,0x00fe379dUL,0x00fe3f80UL,
0x00fe37bdUL,0x00fe3fa0UL,0x007e07c0UL,0x007e0fddUL,
0x00fe37ddUL,0x00fe3fc0UL,0x007e07a0UL,0x007e0fbdUL,
0x007e0780UL,0x007e0f9dUL,0x00fe37fdUL,0x00fe3fe0UL,
0x007e0ffbUL,0x007e07e6UL,0x00fe3f86UL,0x00fe379bUL,
0x00fe3fa6UL,0x00fe37bbUL,0x007e0fdbUL,0x007e07c6UL,
0x00fe3fc6UL,0x00fe37dbUL,0x007e0fbbUL,0x007e07a6UL,
0x007e0f9bUL,0x007e0786UL,0x00fe3fe6UL,0x00fe37fbUL,
0x0080501bUL,0x00805806UL,0x00006066UL,0x0000687bUL,
0x00006046UL,0x0000685bUL,0x0080503bUL,0x00805826UL,
0x00006026UL,0x0000683bUL,0x0080505bUL,0x00805846UL,
0x0080507bUL,0x00805866UL,0x00006006UL,0x0000681bUL,
0x00805800UL,0x0080501dUL,0x0000687dUL,0x00006060UL,
0x0000685dUL,0x00006040UL,0x00805820UL,0x0080503dUL,
0x0000683dUL,0x00006020UL,0x00805840UL,0x0080505dUL,
0x00805860UL,0x0080507dUL,0x0000681dUL,0x00006000UL
};

// %%USE_TABLE
static const uint32_t MAT24_ENC_TABLE2[256] = {
// %%TABLE Mat24_enc_table2, uint32
0x00000000UL,0x00000817UL,0x00b694f7UL,0x00b69ce0UL,
0x00da93d7UL,0x00da9bc0UL,0x006c0720UL,0x006c0f37UL,
0x00ec9737UL,0x00ec9f20UL,0x005a03c0UL,0x005a0bd7UL,
0x003604e0UL,0x00360cf7UL,0x00809017UL,0x00809800UL,
0x0000080fUL,0x00000018UL,0x00b69cf8UL,0x00b694efUL,
0x00da9bd8UL,0x00da93cfUL,0x006c0f2fUL,0x006c0738UL,
0x00ec9f38UL,0x00ec972fUL,0x005a0bcfUL,0x005a03d8UL,
0x00360cefUL,0x003604f8UL,0x00809818UL,0x0080900fUL,
0x00cf136fUL,0x00cf1b78UL,0x00798798UL,0x00798f8fUL,
0x001580b8UL,0x001588afUL,0x00a3144fUL,0x00a31c58UL,
0x00238458UL,0x00238c4fUL,0x009510afUL,0x009518b8UL,
0x00f9178fUL,0x00f91f98UL,0x004f8378UL,0x004f8b6fUL,
0x00cf1b60UL,0x00cf1377UL,0x00798f97UL,0x00798780UL,
0x001588b7UL,0x001580a0UL,0x00a31c40UL,0x00a31457UL,
0x00238c57UL,0x00238440UL,0x009518a0UL,0x009510b7UL,
0x00f91f80UL,0x00f91797UL,0x004f8b77UL,0x004f8360UL,
0x00f316cfUL,0x00f31ed8UL,0x00458238UL,0x00458a2fUL,
0x00298518UL,0x00298d0fUL,0x009f11efUL,0x009f19f8UL,
0x001f81f8UL,0x001f89efUL,0x00a9150fUL,0x00a91d18UL,
0x00c5122fUL,0x00c51a38UL,0x007386d8UL,0x00738ecfUL,
0x00f31ec0UL,0x00f316d7UL,0x00458a37UL,0x00458220UL,
0x00298d17UL,0x00298500UL,0x009f19e0UL,0x009f11f7UL,
0x001f89f7UL,0x001f81e0UL,0x00a91d00UL,0x00a91517UL,
0x00c51a20UL,0x00c51237UL,0x00738ed7UL,0x007386c0UL,
0x003c05a0UL,0x003c0db7UL,0x008a9157UL,0x008a9940UL,
0x00e69677UL,0x00e69e60UL,0x00500280UL,0x00500a97UL,
0x00d09297UL,0x00d09a80UL,0x00660660UL,0x00660e77UL,
0x000a0140UL,0x000a0957UL,0x00bc95b7UL,0x00bc9da0UL,
0x003c0dafUL,0x003c05b8UL,0x008a9958UL,0x008a914fUL,
0x00e69e78UL,0x00e6966fUL,0x00500a8fUL,0x00500298UL,
0x00d09a98UL,0x00d0928fUL,0x00660e6fUL,0x00660678UL,
0x000a094fUL,0x000a0158UL,0x00bc9db8UL,0x00bc95afUL,
0x00bd15afUL,0x00bd1db8UL,0x000b8158UL,0x000b894fUL,
0x00678678UL,0x00678e6fUL,0x00d1128fUL,0x00d11a98UL,
0x00518298UL,0x00518a8fUL,0x00e7166fUL,0x00e71e78UL,
0x008b114fUL,0x008b1958UL,0x003d85b8UL,0x003d8dafUL,
0x00bd1da0UL,0x00bd15b7UL,0x000b8957UL,0x000b8140UL,
0x00678e77UL,0x00678660UL,0x00d11a80UL,0x00d11297UL,
0x00518a97UL,0x00518280UL,0x00e71e60UL,0x00e71677UL,
0x008b1940UL,0x008b1157UL,0x003d8db7UL,0x003d85a0UL,
0x007206c0UL,0x00720ed7UL,0x00c49237UL,0x00c49a20UL,
0x00a89517UL,0x00a89d00UL,0x001e01e0UL,0x001e09f7UL,
0x009e91f7UL,0x009e99e0UL,0x00280500UL,0x00280d17UL,
0x00440220UL,0x00440a37UL,0x00f296d7UL,0x00f29ec0UL,
0x00720ecfUL,0x007206d8UL,0x00c49a38UL,0x00c4922fUL,
0x00a89d18UL,0x00a8950fUL,0x001e09efUL,0x001e01f8UL,
0x009e99f8UL,0x009e91efUL,0x00280d0fUL,0x00280518UL,
0x00440a2fUL,0x00440238UL,0x00f29ed8UL,0x00f296cfUL,
0x004e0360UL,0x004e0b77UL,0x00f89797UL,0x00f89f80UL,
0x009490b7UL,0x009498a0UL,0x00220440UL,0x00220c57UL,
0x00a29457UL,0x00a29c40UL,0x001400a0UL,0x001408b7UL,
0x00780780UL,0x00780f97UL,0x00ce9377UL,0x00ce9b60UL,
0x004e0b6fUL,0x004e0378UL,0x00f89f98UL,0x00f8978fUL,
0x009498b8UL,0x009490afUL,0x00220c4fUL,0x00220458UL,
0x00a29c58UL,0x00a2944fUL,0x001408afUL,0x001400b8UL,
0x00780f8fUL,0x00780798UL,0x00ce9b78UL,0x00ce936fUL,
0x0081100fUL,0x00811818UL,0x003784f8UL,0x00378cefUL,
0x005b83d8UL,0x005b8bcfUL,0x00ed172fUL,0x00ed1f38UL,
0x006d8738UL,0x006d8f2fUL,0x00db13cfUL,0x00db1bd8UL,
0x00b714efUL,0x00b71cf8UL,0x00018018UL,0x0001880fUL,
0x00811800UL,0x00811017UL,0x00378cf7UL,0x003784e0UL,
0x005b8bd7UL,0x005b83c0UL,0x00ed1f20UL,0x00ed1737UL,
0x006d8f37UL,0x006d8720UL,0x00db1bc0UL,0x00db13d7UL,
0x00b71ce0UL,0x00b714f7UL,0x00018817UL,0x00018000UL
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE0[256] = {
// %%TABLE Mat24_dec_table0, uint32
0x00000000UL,0x00000001UL,0x00000110UL,0x00000111UL,
0x00001010UL,0x00001011UL,0x00001100UL,0x00001101UL,
0x00010010UL,0x00010011UL,0x00010100UL,0x00010101UL,
0x00011000UL,0x00011001UL,0x00011110UL,0x00011111UL,
0x00100010UL,0x00100011UL,0x00100100UL,0x00100101UL,
0x00101000UL,0x00101001UL,0x00101110UL,0x00101111UL,
0x00110000UL,0x00110001UL,0x00110110UL,0x00110111UL,
0x00111010UL,0x00111011UL,0x00111100UL,0x00111101UL,
0x00000600UL,0x00000601UL,0x00000710UL,0x00000711UL,
0x00001610UL,0x00001611UL,0x00001700UL,0x00001701UL,
0x00010610UL,0x00010611UL,0x00010700UL,0x00010701UL,
0x00011600UL,0x00011601UL,0x00011710UL,0x00011711UL,
0x00100610UL,0x00100611UL,0x00100700UL,0x00100701UL,
0x00101600UL,0x00101601UL,0x00101710UL,0x00101711UL,
0x00110600UL,0x00110601UL,0x00110710UL,0x00110711UL,
0x00111610UL,0x00111611UL,0x00111700UL,0x00111701UL,
0x00000a00UL,0x00000a01UL,0x00000b10UL,0x00000b11UL,
0x00001a10UL,0x00001a11UL,0x00001b00UL,0x00001b01UL,
0x00010a10UL,0x00010a11UL,0x00010b00UL,0x00010b01UL,
0x00011a00UL,0x00011a01UL,0x00011b10UL,0x00011b11UL,
0x00100a10UL,0x00100a11UL,0x00100b00UL,0x00100b01UL,
0x00101a00UL,0x00101a01UL,0x00101b10UL,0x00101b11UL,
0x00110a00UL,0x00110a01UL,0x00110b10UL,0x00110b11UL,
0x00111a10UL,0x00111a11UL,0x00111b00UL,0x00111b01UL,
0x00000c00UL,0x00000c01UL,0x00000d10UL,0x00000d11UL,
0x00001c10UL,0x00001c11UL,0x00001d00UL,0x00001d01UL,
0x00010c10UL,0x00010c11UL,0x00010d00UL,0x00010d01UL,
0x00011c00UL,0x00011c01UL,0x00011d10UL,0x00011d11UL,
0x00100c10UL,0x00100c11UL,0x00100d00UL,0x00100d01UL,
0x00101c00UL,0x00101c01UL,0x00101d10UL,0x00101d11UL,
0x00110c00UL,0x00110c01UL,0x00110d10UL,0x00110d11UL,
0x00111c10UL,0x00111c11UL,0x00111d00UL,0x00111d01UL,
0x00000060UL,0x00000061UL,0x00000170UL,0x00000171UL,
0x00001070UL,0x00001071UL,0x00001160UL,0x00001161UL,
0x00010070UL,0x00010071UL,0x00010160UL,0x00010161UL,
0x00011060UL,0x00011061UL,0x00011170UL,0x00011171UL,
0x00100070UL,0x00100071UL,0x00100160UL,0x00100161UL,
0x00101060UL,0x00101061UL,0x00101170UL,0x00101171UL,
0x00110060UL,0x00110061UL,0x00110170UL,0x00110171UL,
0x00111070UL,0x00111071UL,0x00111160UL,0x00111161UL,
0x00000660UL,0x00000661UL,0x00000770UL,0x00000771UL,
0x00001670UL,0x00001671UL,0x00001760UL,0x00001761UL,
0x00010670UL,0x00010671UL,0x00010760UL,0x00010761UL,
0x00011660UL,0x00011661UL,0x00011770UL,0x00011771UL,
0x00100670UL,0x00100671UL,0x00100760UL,0x00100761UL,
0x00101660UL,0x00101661UL,0x00101770UL,0x00101771UL,
0x00110660UL,0x00110661UL,0x00110770UL,0x00110771UL,
0x00111670UL,0x00111671UL,0x00111760UL,0x00111761UL,
0x00000a60UL,0x00000a61UL,0x00000b70UL,0x00000b71UL,
0x00001a70UL,0x00001a71UL,0x00001b60UL,0x00001b61UL,
0x00010a70UL,0x00010a71UL,0x00010b60UL,0x00010b61UL,
0x00011a60UL,0x00011a61UL,0x00011b70UL,0x00011b71UL,
0x00100a70UL,0x00100a71UL,0x00100b60UL,0x00100b61UL,
0x00101a60UL,0x00101a61UL,0x00101b70UL,0x00101b71UL,
0x00110a60UL,0x00110a61UL,0x00110b70UL,0x00110b71UL,
0x00111a70UL,0x00111a71UL,0x00111b60UL,0x00111b61UL,
0x00000c60UL,0x00000c61UL,0x00000d70UL,0x00000d71UL,
0x00001c70UL,0x00001c71UL,0x00001d60UL,0x00001d61UL,
0x00010c70UL,0x00010c71UL,0x00010d60UL,0x00010d61UL,
0x00011c60UL,0x00011c61UL,0x00011d70UL,0x00011d71UL,
0x00100c70UL,0x00100c71UL,0x00100d60UL,0x00100d61UL,
0x00101c60UL,0x00101c61UL,0x00101d70UL,0x00101d71UL,
0x00110c60UL,0x00110c61UL,0x00110d70UL,0x00110d71UL,
0x00111c70UL,0x00111c71UL,0x00111d60UL,0x00111d61UL
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE1[256] = {
// %%TABLE Mat24_dec_table1, uint32
0x00000000UL,0x000000a0UL,0x00000006UL,0x000000a6UL,
0x0000000aUL,0x000000aaUL,0x0000000cUL,0x000000acUL,
0x00111111UL,0x001111b1UL,0x00111117UL,0x001111b7UL,
0x0011111bUL,0x001111bbUL,0x0011111dUL,0x001111bdUL,
0x00ffffffUL,0x00ffff5fUL,0x00fffff9UL,0x00ffff59UL,
0x00fffff5UL,0x00ffff55UL,0x00fffff3UL,0x00ffff53UL,
0x00eeeeeeUL,0x00eeee4eUL,0x00eeeee8UL,0x00eeee48UL,
0x00eeeee4UL,0x00eeee44UL,0x00eeeee2UL,0x00eeee42UL,
0x00fff0f0UL,0x00fff050UL,0x00fff0f6UL,0x00fff056UL,
0x00fff0faUL,0x00fff05aUL,0x00fff0fcUL,0x00fff05cUL,
0x00eee1e1UL,0x00eee141UL,0x00eee1e7UL,0x00eee147UL,
0x00eee1ebUL,0x00eee14bUL,0x00eee1edUL,0x00eee14dUL,
0x00000f0fUL,0x00000fafUL,0x00000f09UL,0x00000fa9UL,
0x00000f05UL,0x00000fa5UL,0x00000f03UL,0x00000fa3UL,
0x00111e1eUL,0x00111ebeUL,0x00111e18UL,0x00111eb8UL,
0x00111e14UL,0x00111eb4UL,0x00111e12UL,0x00111eb2UL,
0x00ff0ff0UL,0x00ff0f50UL,0x00ff0ff6UL,0x00ff0f56UL,
0x00ff0ffaUL,0x00ff0f5aUL,0x00ff0ffcUL,0x00ff0f5cUL,
0x00ee1ee1UL,0x00ee1e41UL,0x00ee1ee7UL,0x00ee1e47UL,
0x00ee1eebUL,0x00ee1e4bUL,0x00ee1eedUL,0x00ee1e4dUL,
0x0000f00fUL,0x0000f0afUL,0x0000f009UL,0x0000f0a9UL,
0x0000f005UL,0x0000f0a5UL,0x0000f003UL,0x0000f0a3UL,
0x0011e11eUL,0x0011e1beUL,0x0011e118UL,0x0011e1b8UL,
0x0011e114UL,0x0011e1b4UL,0x0011e112UL,0x0011e1b2UL,
0x0000ff00UL,0x0000ffa0UL,0x0000ff06UL,0x0000ffa6UL,
0x0000ff0aUL,0x0000ffaaUL,0x0000ff0cUL,0x0000ffacUL,
0x0011ee11UL,0x0011eeb1UL,0x0011ee17UL,0x0011eeb7UL,
0x0011ee1bUL,0x0011eebbUL,0x0011ee1dUL,0x0011eebdUL,
0x00ff00ffUL,0x00ff005fUL,0x00ff00f9UL,0x00ff0059UL,
0x00ff00f5UL,0x00ff0055UL,0x00ff00f3UL,0x00ff0053UL,
0x00ee11eeUL,0x00ee114eUL,0x00ee11e8UL,0x00ee1148UL,
0x00ee11e4UL,0x00ee1144UL,0x00ee11e2UL,0x00ee1142UL,
0x00f0fff0UL,0x00f0ff50UL,0x00f0fff6UL,0x00f0ff56UL,
0x00f0fffaUL,0x00f0ff5aUL,0x00f0fffcUL,0x00f0ff5cUL,
0x00e1eee1UL,0x00e1ee41UL,0x00e1eee7UL,0x00e1ee47UL,
0x00e1eeebUL,0x00e1ee4bUL,0x00e1eeedUL,0x00e1ee4dUL,
0x000f000fUL,0x000f00afUL,0x000f0009UL,0x000f00a9UL,
0x000f0005UL,0x000f00a5UL,0x000f0003UL,0x000f00a3UL,
0x001e111eUL,0x001e11beUL,0x001e1118UL,0x001e11b8UL,
0x001e1114UL,0x001e11b4UL,0x001e1112UL,0x001e11b2UL,
0x000f0f00UL,0x000f0fa0UL,0x000f0f06UL,0x000f0fa6UL,
0x000f0f0aUL,0x000f0faaUL,0x000f0f0cUL,0x000f0facUL,
0x001e1e11UL,0x001e1eb1UL,0x001e1e17UL,0x001e1eb7UL,
0x001e1e1bUL,0x001e1ebbUL,0x001e1e1dUL,0x001e1ebdUL,
0x00f0f0ffUL,0x00f0f05fUL,0x00f0f0f9UL,0x00f0f059UL,
0x00f0f0f5UL,0x00f0f055UL,0x00f0f0f3UL,0x00f0f053UL,
0x00e1e1eeUL,0x00e1e14eUL,0x00e1e1e8UL,0x00e1e148UL,
0x00e1e1e4UL,0x00e1e144UL,0x00e1e1e2UL,0x00e1e142UL,
0x000ff000UL,0x000ff0a0UL,0x000ff006UL,0x000ff0a6UL,
0x000ff00aUL,0x000ff0aaUL,0x000ff00cUL,0x000ff0acUL,
0x001ee111UL,0x001ee1b1UL,0x001ee117UL,0x001ee1b7UL,
0x001ee11bUL,0x001ee1bbUL,0x001ee11dUL,0x001ee1bdUL,
0x00f00fffUL,0x00f00f5fUL,0x00f00ff9UL,0x00f00f59UL,
0x00f00ff5UL,0x00f00f55UL,0x00f00ff3UL,0x00f00f53UL,
0x00e11eeeUL,0x00e11e4eUL,0x00e11ee8UL,0x00e11e48UL,
0x00e11ee4UL,0x00e11e44UL,0x00e11ee2UL,0x00e11e42UL,
0x00f000f0UL,0x00f00050UL,0x00f000f6UL,0x00f00056UL,
0x00f000faUL,0x00f0005aUL,0x00f000fcUL,0x00f0005cUL,
0x00e111e1UL,0x00e11141UL,0x00e111e7UL,0x00e11147UL,
0x00e111ebUL,0x00e1114bUL,0x00e111edUL,0x00e1114dUL,
0x000fff0fUL,0x000fffafUL,0x000fff09UL,0x000fffa9UL,
0x000fff05UL,0x000fffa5UL,0x000fff03UL,0x000fffa3UL,
0x001eee1eUL,0x001eeebeUL,0x001eee18UL,0x001eeeb8UL,
0x001eee14UL,0x001eeeb4UL,0x001eee12UL,0x001eeeb2UL
};

// %%USE_TABLE
static const uint32_t MAT24_DEC_TABLE2[256] = {
// %%TABLE Mat24_dec_table2, uint32
0x00000000UL,0x000ffff0UL,0x00aaaa00UL,0x00a555f0UL,
0x00666600UL,0x006999f0UL,0x00cccc00UL,0x00c333f0UL,
0x00c6a0a0UL,0x00c95f50UL,0x006c0aa0UL,0x0063f550UL,
0x00a0c6a0UL,0x00af3950UL,0x000a6ca0UL,0x00059350UL,
0x00ac6060UL,0x00a39f90UL,0x0006ca60UL,0x00093590UL,
0x00ca0660UL,0x00c5f990UL,0x0060ac60UL,0x006f5390UL,
0x006ac0c0UL,0x00653f30UL,0x00c06ac0UL,0x00cf9530UL,
0x000ca6c0UL,0x00035930UL,0x00a60cc0UL,0x00a9f330UL,
0x006ca00aUL,0x00635ffaUL,0x00c60a0aUL,0x00c9f5faUL,
0x000ac60aUL,0x000539faUL,0x00a06c0aUL,0x00af93faUL,
0x00aa00aaUL,0x00a5ff5aUL,0x0000aaaaUL,0x000f555aUL,
0x00cc66aaUL,0x00c3995aUL,0x0066ccaaUL,0x0069335aUL,
0x00c0c06aUL,0x00cf3f9aUL,0x006a6a6aUL,0x0065959aUL,
0x00a6a66aUL,0x00a9599aUL,0x000c0c6aUL,0x0003f39aUL,
0x000660caUL,0x00099f3aUL,0x00accacaUL,0x00a3353aUL,
0x006006caUL,0x006ff93aUL,0x00caaccaUL,0x00c5533aUL,
0x00ca6006UL,0x00c59ff6UL,0x0060ca06UL,0x006f35f6UL,
0x00ac0606UL,0x00a3f9f6UL,0x0006ac06UL,0x000953f6UL,
0x000cc0a6UL,0x00033f56UL,0x00a66aa6UL,0x00a99556UL,
0x006aa6a6UL,0x00655956UL,0x00c00ca6UL,0x00cff356UL,
0x00660066UL,0x0069ff96UL,0x00ccaa66UL,0x00c35596UL,
0x00006666UL,0x000f9996UL,0x00aacc66UL,0x00a53396UL,
0x00a0a0c6UL,0x00af5f36UL,0x000a0ac6UL,0x0005f536UL,
0x00c6c6c6UL,0x00c93936UL,0x006c6cc6UL,0x00639336UL,
0x00a6c00cUL,0x00a93ffcUL,0x000c6a0cUL,0x000395fcUL,
0x00c0a60cUL,0x00cf59fcUL,0x006a0c0cUL,0x0065f3fcUL,
0x006060acUL,0x006f9f5cUL,0x00cacaacUL,0x00c5355cUL,
0x000606acUL,0x0009f95cUL,0x00acacacUL,0x00a3535cUL,
0x000aa06cUL,0x00055f9cUL,0x00a00a6cUL,0x00aff59cUL,
0x006cc66cUL,0x0063399cUL,0x00c66c6cUL,0x00c9939cUL,
0x00cc00ccUL,0x00c3ff3cUL,0x0066aaccUL,0x0069553cUL,
0x00aa66ccUL,0x00a5993cUL,0x0000ccccUL,0x000f333cUL,
0x0011111eUL,0x001eeeeeUL,0x00bbbb1eUL,0x00b444eeUL,
0x0077771eUL,0x007888eeUL,0x00dddd1eUL,0x00d222eeUL,
0x00d7b1beUL,0x00d84e4eUL,0x007d1bbeUL,0x0072e44eUL,
0x00b1d7beUL,0x00be284eUL,0x001b7dbeUL,0x0014824eUL,
0x00bd717eUL,0x00b28e8eUL,0x0017db7eUL,0x0018248eUL,
0x00db177eUL,0x00d4e88eUL,0x0071bd7eUL,0x007e428eUL,
0x007bd1deUL,0x00742e2eUL,0x00d17bdeUL,0x00de842eUL,
0x001db7deUL,0x0012482eUL,0x00b71ddeUL,0x00b8e22eUL,
0x007db114UL,0x00724ee4UL,0x00d71b14UL,0x00d8e4e4UL,
0x001bd714UL,0x001428e4UL,0x00b17d14UL,0x00be82e4UL,
0x00bb11b4UL,0x00b4ee44UL,0x0011bbb4UL,0x001e4444UL,
0x00dd77b4UL,0x00d28844UL,0x0077ddb4UL,0x00782244UL,
0x00d1d174UL,0x00de2e84UL,0x007b7b74UL,0x00748484UL,
0x00b7b774UL,0x00b84884UL,0x001d1d74UL,0x0012e284UL,
0x001771d4UL,0x00188e24UL,0x00bddbd4UL,0x00b22424UL,
0x007117d4UL,0x007ee824UL,0x00dbbdd4UL,0x00d44224UL,
0x00db7118UL,0x00d48ee8UL,0x0071db18UL,0x007e24e8UL,
0x00bd1718UL,0x00b2e8e8UL,0x0017bd18UL,0x001842e8UL,
0x001dd1b8UL,0x00122e48UL,0x00b77bb8UL,0x00b88448UL,
0x007bb7b8UL,0x00744848UL,0x00d11db8UL,0x00dee248UL,
0x00771178UL,0x0078ee88UL,0x00ddbb78UL,0x00d24488UL,
0x00117778UL,0x001e8888UL,0x00bbdd78UL,0x00b42288UL,
0x00b1b1d8UL,0x00be4e28UL,0x001b1bd8UL,0x0014e428UL,
0x00d7d7d8UL,0x00d82828UL,0x007d7dd8UL,0x00728228UL,
0x00b7d112UL,0x00b82ee2UL,0x001d7b12UL,0x001284e2UL,
0x00d1b712UL,0x00de48e2UL,0x007b1d12UL,0x0074e2e2UL,
0x007171b2UL,0x007e8e42UL,0x00dbdbb2UL,0x00d42442UL,
0x001717b2UL,0x0018e842UL,0x00bdbdb2UL,0x00b24242UL,
0x001bb172UL,0x00144e82UL,0x00b11b72UL,0x00bee482UL,
0x007dd772UL,0x00722882UL,0x00d77d72UL,0x00d88282UL,
0x00dd11d2UL,0x00d2ee22UL,0x0077bbd2UL,0x00784422UL,
0x00bb77d2UL,0x00b48822UL,0x0011ddd2UL,0x001e2222UL
};


// %%COMMENT
// The following table MAT24_BASIS contains the used basis of the 
// Golay cocode (12 bit vectors of type uint32_t) followed by the 
// used basis of the Golay code (12 bit vectors).

// %%EXPORT_TABLE p
MAT24_API
const uint32_t MAT24_BASIS[24] = { 
// %%TABLE Mat24_basis, uint32
0x00000001UL,0x00000110UL,0x00001010UL,0x00010010UL,
0x00100010UL,0x00000600UL,0x00000a00UL,0x00000060UL,
0x000000a0UL,0x00000006UL,0x0000000aUL,0x00111111UL,
0x00ffffffUL,0x00fff0f0UL,0x00ff0ff0UL,0x00f0fff0UL,
0x000ffff0UL,0x00aaaa00UL,0x00666600UL,0x00c6a0a0UL,
0x00ac6060UL,0x006ca00aUL,0x00ca6006UL,0x0011111eUL
};

// %%EXPORT_TABLE p
MAT24_API
const uint32_t MAT24_RECIP_BASIS[24+8] = { 
// %%TABLE Mat24_recip_basis, uint32
0x00000001UL,0x00800e01UL,0x00800c01UL,0x00800a01UL,
0x0000081fUL,0x0081f19fUL,0x0081f11fUL,0x0081f09fUL,
0x0000081dUL,0x0080307dUL,0x0080305dUL,0x0080303dUL,
0x0000081bUL,0x00fe57fbUL,0x00aa555bUL,0x00d452bbUL,
0x00000817UL,0x00b694f7UL,0x00da93d7UL,0x00ec9737UL,
0x0000080fUL,0x00cf136fUL,0x00f316cfUL,0x00bd15afUL,
0x00000000UL,0x00000000UL,0x00000000UL,0x00000000UL,
0x00000000UL,0x00000000UL,0x00000000UL,0x00000000UL
};

// %%USE_TABLE
static const uint16_t MAT24_SYNDROME_TABLE[0x800] = { 
// %%TABLE Mat24_syndrome_table, uint16
0x6300,0x2080,0x3080,0x3100,0x4080,0x4100,0x4180,0x5ed5,
0x5080,0x5100,0x5180,0x4e51,0x5200,0x3dcd,0x2d49,0x1cc5,
0x2920,0x5e6f,0x520b,0x5647,0x518b,0x59a6,0x5164,0x5168,
0x418b,0x45c5,0x4164,0x4168,0x3164,0x3168,0x630b,0x2d04,
0x2d20,0x5a4e,0x520a,0x5e26,0x518a,0x55e5,0x5144,0x5148,
0x418a,0x4da7,0x4144,0x4148,0x3144,0x3148,0x630a,0x2904,
0x2d40,0x562d,0x5209,0x5a65,0x5189,0x5dc7,0x5124,0x5128,
0x4189,0x49e6,0x4124,0x4128,0x3124,0x3128,0x6309,0x2504,
0x18a0,0x5a2f,0x564b,0x5207,0x5dc9,0x5187,0x5107,0x50e4,
0x4daa,0x4187,0x4107,0x40e4,0x3107,0x30e4,0x20e4,0x6307,
0x3d83,0x2ce0,0x3c83,0x3d03,0x5dca,0x59a5,0x41e3,0x5671,
0x4da9,0x45c6,0x51e3,0x5ed2,0x5640,0x3c41,0x2cc5,0x2927,
0x5a81,0x28e0,0x5649,0x5e25,0x5dcb,0x55e6,0x4da0,0x5862,
0x5881,0x5901,0x5981,0x4dee,0x5a01,0x4a2d,0x28c5,0x2d27,
0x4602,0x24e0,0x564a,0x5a66,0x4482,0x4502,0x4582,0x5ded,
0x4dab,0x49e5,0x5dc0,0x4461,0x5222,0x5aae,0x24c5,0x2d47,
0x1ca0,0x566e,0x5e2a,0x5206,0x59ab,0x5186,0x5106,0x50c4,
0x49e9,0x4186,0x4106,0x40c4,0x3106,0x30c4,0x20c4,0x6306,
0x4e01,0x2cc0,0x5e29,0x5645,0x4c81,0x4d01,0x4d81,0x59ee,
0x49ea,0x45c7,0x59a0,0x4c62,0x5261,0x5ead,0x2ce5,0x2926,
0x3982,0x28c0,0x3882,0x3902,0x59a9,0x55e7,0x41c2,0x5e72,
0x49eb,0x4da5,0x51c2,0x5ab1,0x5e20,0x3861,0x28e5,0x2d26,
0x5683,0x24c0,0x5e2b,0x5a67,0x59aa,0x5dc5,0x49e0,0x5441,
0x5483,0x5503,0x5583,0x49cd,0x5603,0x4e2f,0x24e5,0x2d46,
0x1cc0,0x5e4d,0x5a69,0x5205,0x55ea,0x5185,0x5105,0x50a4,
0x45cb,0x4185,0x4105,0x40a4,0x3105,0x30a4,0x20a4,0x6305,
0x5e82,0x2ca0,0x5a6a,0x5646,0x55e9,0x59a7,0x45c0,0x5c61,
0x5c82,0x5d02,0x5d82,0x45ed,0x5e02,0x4e4e,0x2ce6,0x2925,
0x4a03,0x28a0,0x5a6b,0x5e27,0x4883,0x4903,0x4983,0x55cd,
0x45c9,0x4da6,0x55e0,0x4841,0x5243,0x5ecf,0x28e6,0x2d25,
0x3581,0x24a0,0x3481,0x3501,0x55eb,0x5dc6,0x41a1,0x5a51,
0x45ca,0x49e7,0x51a1,0x5eb3,0x5a60,0x3462,0x24e6,0x2d45,
0x0820,0x564f,0x5a2b,0x5e67,0x5daa,0x59c5,0x5526,0x5060,
0x4dc9,0x45a6,0x4945,0x4060,0x3d67,0x3060,0x2060,0x1060,
0x2d03,0x2c83,0x3ce0,0x3163,0x5da9,0x4163,0x5546,0x5a72,
0x4dca,0x5163,0x4925,0x5eb1,0x5a20,0x3cc5,0x2c41,0x39a7,
0x2903,0x2883,0x5a29,0x3143,0x48a0,0x4143,0x5566,0x5dee,
0x4dcb,0x5143,0x5da0,0x48e6,0x3d27,0x5aad,0x2841,0x4e25,
0x2503,0x2483,0x5a2a,0x3123,0x5dab,0x4123,0x4dc0,0x54e5,
0x54c0,0x5123,0x4965,0x4ded,0x3d47,0x4a2e,0x2441,0x5ec6,
0x1c83,0x20e3,0x30e3,0x3d60,0x40e3,0x59c6,0x5525,0x5e51,
0x50e3,0x45a5,0x4946,0x5ab3,0x5e60,0x3d49,0x39ab,0x1c41,
0x39a0,0x520f,0x5e6b,0x5a27,0x51e8,0x51e4,0x5545,0x51ec,
0x41e8,0x41e4,0x4926,0x41ec,0x3d04,0x630f,0x3d88,0x3d84,
0x5a82,0x562e,0x5e6a,0x3d20,0x48c0,0x5da7,0x5565,0x5861,
0x5882,0x5902,0x5982,0x48e5,0x5a02,0x3d6a,0x39a9,0x4e26,
0x4601,0x5a4d,0x5e69,0x3d40,0x4481,0x4501,0x4581,0x54e6,
0x54a0,0x4dc7,0x4966,0x4462,0x5221,0x3d69,0x39aa,0x5ec5,
0x1883,0x20c3,0x30c3,0x5e65,0x40c3,0x59c7,0x45a0,0x556a,
0x50c3,0x5520,0x4947,0x45ee,0x3d65,0x4e4d,0x5ec9,0x1841,
0x4e02,0x5e4e,0x3ca0,0x5a26,0x4c82,0x4d02,0x4d82,0x5569,
0x45ab,0x5540,0x4927,0x4c61,0x5262,0x3ce6,0x5eca,0x39a5,
0x3981,0x5a6f,0x3881,0x3901,0x48e0,0x5da6,0x41c1,0x5549,
0x45aa,0x5560,0x51c1,0x48c5,0x3d25,0x3862,0x5ecb,0x4e27,
0x5ec0,0x560c,0x5608,0x5604,0x5588,0x5584,0x5504,0x6315,
0x45a9,0x4dc6,0x4967,0x5690,0x3d45,0x568c,0x5688,0x5684,
0x1483,0x20a3,0x30a3,0x5e66,0x40a3,0x4940,0x5527,0x59ed,
0x50a3,0x45a7,0x59c0,0x4969,0x3d66,0x5eae,0x4e2a,0x1441,
0x5e81,0x566d,0x3cc0,0x5a25,0x59cb,0x4920,0x5547,0x5c62,
0x5c81,0x5d01,0x5d81,0x496a,0x5e01,0x3ce5,0x4e29,0x39a6,
0x4e20,0x524c,0x5248,0x5244,0x59ca,0x5da5,0x5567,0x5250,
0x4988,0x4984,0x4904,0x6312,0x3d26,0x4a0c,0x4a08,0x4a04,
0x3582,0x5e2f,0x3482,0x3502,0x59c9,0x4960,0x41a2,0x54c5,
0x54e0,0x4dc5,0x51a2,0x4949,0x3d46,0x3461,0x4e2b,0x5ec7,
0x0c20,0x5e2e,0x566a,0x5a46,0x59e9,0x55a7,0x5d65,0x5040,
0x49ab,0x4de5,0x4527,0x4040,0x3946,0x3040,0x2040,0x1040,
0x2d02,0x2c82,0x5669,0x3162,0x59ea,0x4162,0x49a0,0x5ce6,
0x5ca0,0x5162,0x4547,0x49ee,0x3926,0x4e2d,0x2c61,0x5aa5,
0x2902,0x2882,0x38c0,0x3142,0x59eb,0x4142,0x5d25,0x5651,
0x49a9,0x5142,0x4567,0x5ed3,0x5660,0x38e5,0x2861,0x3da6,
0x2502,0x2482,0x566b,0x3122,0x44e0,0x4122,0x5d45,0x59cd,
0x49aa,0x5122,0x59e0,0x44c5,0x3966,0x5eaf,0x2461,0x4e47,
0x1c82,0x20e2,0x30e2,0x5a45,0x40e2,0x4520,0x5d66,0x55ee,
0x50e2,0x4de6,0x55a0,0x456a,0x3945,0x5ecd,0x4e49,0x1c61,
0x3d81,0x5a6e,0x3c81,0x3d01,0x55ab,0x4540,0x41e1,0x5ce5,
0x5cc0,0x49a7,0x51e1,0x4569,0x3925,0x3c62,0x4e4a,0x5aa6,
0x5a83,0x5e4f,0x38a0,0x5667,0x55aa,0x4560,0x5d26,0x5841,
0x5883,0x5903,0x5983,0x4549,0x5a03,0x38e6,0x4e4b,0x3da5,
0x4e40,0x522c,0x5228,0x5224,0x55a9,0x59e7,0x5d46,0x5230,
0x4588,0x4584,0x4504,0x6311,0x3965,0x460c,0x4608,0x4604,
0x1882,0x20c2,0x30c2,0x3940,0x40c2,0x55a5,0x5d67,0x5a71,
0x50c2,0x4de7,0x4525,0x5eb2,0x5a40,0x3969,0x3daa,0x1861,
0x4e03,0x562f,0x5a4b,0x3920,0x4c83,0x4d03,0x4d83,0x5cc5,
0x5ce0,0x49a6,0x4545,0x4c41,0x5263,0x396a,0x3da9,0x5aa7,
0x3da0,0x520e,0x5a4a,0x5666,0x51c8,0x51c4,0x5d27,0x51cc,
0x41c8,0x41c4,0x4565,0x41cc,0x3904,0x630e,0x3988,0x3984,
0x5681,0x5e6d,0x5a49,0x3960,0x44a0,0x59e6,0x5d47,0x5462,
0x5481,0x5501,0x5581,0x44e6,0x5601,0x3949,0x3dab,0x4e45,
0x1482,0x20a2,0x30a2,0x5a47,0x40a2,0x55a6,0x4de0,0x5d49,
0x50a2,0x5d60,0x4526,0x4dcd,0x3947,0x4a2f,0x5aab,0x1461,
0x5aa0,0x5e0c,0x5e08,0x5e04,0x5d88,0x5d84,0x5d04,0x6317,
0x4deb,0x49a5,0x4546,0x5e90,0x3927,0x5e8c,0x5e88,0x5e84,
0x4a01,0x5a2d,0x38e0,0x5665,0x4881,0x4901,0x4981,0x5d6a,
0x4dea,0x5d20,0x4566,0x4862,0x5241,0x38c5,0x5aa9,0x3da7,
0x3583,0x564e,0x3483,0x3503,0x44c0,0x59e5,0x41a3,0x5d69,
0x4de9,0x5d40,0x51a3,0x44e5,0x3967,0x3441,0x5aaa,0x4e46,
0x0c40,0x5a6d,0x5e49,0x5625,0x55cb,0x5de6,0x5947,0x5020,
0x45ea,0x49c7,0x4d66,0x4020,0x3525,0x3020,0x2020,0x1020,
0x2d01,0x2c81,0x5e4a,0x3161,0x4cc0,0x4161,0x5927,0x55ed,
0x45e9,0x5161,0x55c0,0x4ce5,0x3545,0x5ece,0x2c62,0x4a26,
0x2901,0x2881,0x5e4b,0x3141,0x55c9,0x4141,0x45e0,0x58c5,
0x58e0,0x5141,0x4d26,0x45cd,0x3565,0x4e4f,0x2862,0x5ea7,
0x2501,0x2481,0x34a0,0x3121,0x55ca,0x4121,0x5967,0x5e71,
0x45eb,0x5121,0x4d46,0x5ab2,0x5e40,0x34e6,0x2462,0x3dc5,
0x1c81,0x20e1,0x30e1,0x5626,0x40e1,0x5de5,0x49c0,0x5969,
0x50e1,0x5940,0x4d65,0x49ed,0x3526,0x4e2e,0x5eaa,0x1c62,
0x3d82,0x5e2d,0x3c82,0x3d02,0x4ca0,0x55c7,0x41e2,0x596a,
0x49cb,0x5920,0x51e2,0x4ce6,0x3546,0x3c61,0x5ea9,0x4a25,
0x5ea0,0x5a0c,0x5a08,0x5a04,0x5988,0x5984,0x5904,0x6316,
0x49ca,0x45e7,0x4d25,0x5a90,0x3566,0x5a8c,0x5a88,0x5a84,
0x4603,0x566f,0x34c0,0x5e47,0x4483,0x4503,0x4583,0x5949,
0x49c9,0x5960,0x4d45,0x4441,0x5223,0x34e5,0x5eab,0x3dc6,
0x1881,0x20c1,0x30c1,0x5627,0x40c1,0x4d60,0x5945,0x5dcd,
0x50c1,0x49c5,0x5de0,0x4d49,0x3527,0x5aaf,0x4a2b,0x1862,
0x4a20,0x526c,0x5268,0x5264,0x5deb,0x55c6,0x5925,0x5270,
0x4d88,0x4d84,0x4d04,0x6313,0x3547,0x4e0c,0x4e08,0x4e04,
0x3983,0x564d,0x3883,0x3903,0x5dea,0x4d20,0x41c3,0x58e6,
0x58a0,0x45e6,0x51c3,0x4d6a,0x3567,0x3841,0x4a29,0x5ea5,
0x5682,0x5a2e,0x34e0,0x5e46,0x5de9,0x4d40,0x5965,0x5461,
0x5482,0x5502,0x5582,0x4d69,0x5602,0x34c5,0x4a2a,0x3dc7,
0x1481,0x20a1,0x30a1,0x3520,0x40a1,0x5de7,0x5946,0x5672,
0x50a1,0x49c6,0x4d67,0x5ed1,0x5620,0x356a,0x3dc9,0x1462,
0x5e83,0x5a4f,0x562b,0x3540,0x4ce0,0x55c5,0x5926,0x5c41,
0x5c83,0x5d03,0x5d83,0x4cc5,0x5e03,0x3569,0x3dca,0x4a27,
0x4a02,0x5e6e,0x562a,0x3560,0x4882,0x4902,0x4982,0x58e5,
0x58c0,0x45e5,0x4d27,0x4861,0x5242,0x3549,0x3dcb,0x5ea6,
0x3dc0,0x520d,0x5629,0x5e45,0x51a8,0x51a4,0x5966,0x51ac,
0x41a8,0x41a4,0x4d47,0x41ac,0x3504,0x630d,0x3588,0x3584,
0x0c41,0x520c,0x5208,0x5204,0x5188,0x5184,0x5104,0x6314,
0x4188,0x4184,0x4104,0x6310,0x3104,0x630c,0x6308,0x6304,
0x2d00,0x2c80,0x3ce3,0x3160,0x4cc1,0x4160,0x49a2,0x5149,
0x5ca2,0x5160,0x55c1,0x4149,0x5a23,0x3149,0x2928,0x2924,
0x2900,0x2880,0x38c2,0x3140,0x48a3,0x4140,0x45e1,0x5169,
0x58e1,0x5140,0x5da3,0x4169,0x5662,0x3169,0x2d28,0x2d24,
0x2500,0x2480,0x34a1,0x3120,0x44e2,0x4120,0x4dc3,0x516a,
0x54c3,0x5120,0x59e2,0x416a,0x5e41,0x316a,0x2d48,0x2d44,
0x1c80,0x20e0,0x30e0,0x3d63,0x40e0,0x4522,0x49c1,0x50c5,
0x50e0,0x5941,0x55a2,0x40c5,0x5e63,0x30c5,0x20c5,0x18a4,
0x39a3,0x564c,0x5648,0x5644,0x4ca1,0x4542,0x5167,0x5650,
0x5cc2,0x5921,0x4167,0x5692,0x3167,0x3c60,0x2ce4,0x2d07,
0x5ea1,0x526d,0x38a2,0x3d23,0x48c3,0x4562,0x5147,0x5820,
0x4da8,0x4da4,0x4147,0x4dac,0x3147,0x4e0d,0x28e4,0x2907,
0x4e42,0x5e0e,0x34c1,0x3d43,0x5dc8,0x5dc4,0x5127,0x5dcc,
0x54a3,0x5961,0x4127,0x4440,0x3127,0x5e8e,0x24e4,0x2507,
0x1880,0x20c0,0x30c0,0x3942,0x40c0,0x4d61,0x45a3,0x50e5,
0x50c0,0x5523,0x5de1,0x40e5,0x5a42,0x30e5,0x20e5,0x1ca4,
0x4a21,0x5a0d,0x3ca3,0x3922,0x59a8,0x59a4,0x5166,0x59ac,
0x5ce2,0x5543,0x4166,0x4c20,0x3166,0x5a8d,0x2cc4,0x2d06,
0x3da2,0x5e2c,0x5e28,0x5e24,0x48e3,0x4d21,0x5146,0x5e30,
0x58a1,0x5563,0x4146,0x5e91,0x3146,0x3840,0x28c4,0x2906,
0x5ec3,0x524f,0x34e1,0x3962,0x44a2,0x4d41,0x5126,0x5460,
0x49e8,0x49e4,0x4126,0x49ec,0x3126,0x4a0f,0x24c4,0x2506,
0x1480,0x20a0,0x30a0,0x3521,0x40a0,0x4943,0x4de2,0x50e6,
0x50a0,0x5d62,0x59c3,0x40e6,0x5621,0x30e6,0x20e6,0x1cc4,
0x5aa2,0x522e,0x3cc3,0x3541,0x4ce1,0x4923,0x5165,0x5c40,
0x45c8,0x45c4,0x4165,0x45cc,0x3165,0x460e,0x2ca4,0x2d05,
0x4e23,0x560f,0x38e2,0x3561,0x55e8,0x55e4,0x5145,0x55ec,
0x58c1,0x5d22,0x4145,0x4860,0x3145,0x568f,0x28a4,0x2905,
0x3dc1,0x5a6c,0x5a68,0x5a64,0x44c2,0x4963,0x5125,0x5a70,
0x54e3,0x5d42,0x4125,0x5a93,0x3125,0x3420,0x24a4,0x2505,
0x6303,0x2083,0x3083,0x3103,0x4083,0x4103,0x4183,0x5041,
0x5083,0x5103,0x5183,0x4041,0x5203,0x3041,0x2041,0x1041,
0x2923,0x5a2c,0x5a28,0x5a24,0x4cc2,0x51e7,0x49a1,0x5a30,
0x5ca1,0x41e7,0x55c2,0x5a91,0x3d07,0x3ce4,0x2c60,0x3d87,
0x2d23,0x5e0d,0x38c1,0x5245,0x5da8,0x5da4,0x45e2,0x5dac,
0x58e2,0x4985,0x4905,0x48a4,0x5661,0x5e8d,0x2860,0x4a05,
0x2d43,0x526e,0x34a2,0x5606,0x44e1,0x5586,0x5506,0x54c4,
0x4dc8,0x4dc4,0x59e1,0x4dcc,0x5e42,0x4e0e,0x2460,0x5686,
0x18a3,0x5e6c,0x5e68,0x5e64,0x51eb,0x4521,0x49c2,0x5e70,
0x41eb,0x5942,0x55a1,0x5e93,0x3d64,0x3d68,0x3d8b,0x1c60,
0x3d80,0x2ce3,0x3c80,0x3d00,0x4ca2,0x4541,0x41e0,0x51cd,
0x5cc1,0x5922,0x51e0,0x41cd,0x5643,0x39ac,0x39a8,0x39a4,
0x5ea2,0x28e3,0x38a1,0x5246,0x51e9,0x4561,0x4da3,0x5840,
0x41e9,0x4986,0x4906,0x48c4,0x3d24,0x3d28,0x3d89,0x4a06,
0x4e41,0x24e3,0x34c2,0x5605,0x51ea,0x5585,0x5505,0x54a4,
0x41ea,0x5962,0x5dc3,0x4420,0x3d44,0x3d48,0x3d8a,0x5685,
0x1ca3,0x522d,0x5609,0x3941,0x5589,0x4d62,0x5524,0x5528,
0x45a8,0x45a4,0x5de2,0x45ac,0x5a41,0x460d,0x5689,0x1860,
0x4a22,0x2cc3,0x560a,0x3921,0x558a,0x51e5,0x5544,0x5548,
0x5ce1,0x41e5,0x59a3,0x4c40,0x3d05,0x3ca4,0x568a,0x3d85,
0x3da1,0x28c3,0x560b,0x5247,0x558b,0x4d22,0x5564,0x5568,
0x58a2,0x4987,0x4907,0x48e4,0x5e23,0x3820,0x568b,0x4a07,
0x5680,0x24c3,0x34e2,0x3961,0x44a1,0x4d42,0x49e3,0x5ed4,
0x5480,0x5500,0x5580,0x5ed0,0x5600,0x5ecc,0x5ec8,0x5ec4,
0x1cc3,0x5a0e,0x524a,0x3522,0x59c8,0x59c4,0x4de1,0x59cc,
0x498a,0x5d61,0x4944,0x4948,0x5622,0x5a8e,0x4a0a,0x1460,
0x5aa1,0x2ca3,0x5249,0x3542,0x4ce2,0x51e6,0x45c3,0x5c20,
0x4989,0x41e6,0x4924,0x4928,0x3d06,0x3cc4,0x4a09,0x3d86,
0x4a00,0x28a3,0x38e1,0x3562,0x4880,0x4900,0x4980,0x5271,
0x58c2,0x5d21,0x55e3,0x4e30,0x5240,0x4e2c,0x4e28,0x4e24,
0x3dc2,0x24a3,0x524b,0x5607,0x44c1,0x5587,0x5507,0x54e4,
0x498b,0x5d41,0x4964,0x4968,0x5a63,0x3440,0x4a0b,0x5687,
0x6302,0x2082,0x3082,0x3102,0x4082,0x4102,0x4182,0x5061,
0x5082,0x5102,0x5182,0x4061,0x5202,0x3061,0x2061,0x1061,
0x2922,0x524d,0x3ce1,0x5e05,0x4cc3,0x5d85,0x5d05,0x5ca4,
0x49a8,0x49a4,0x55c3,0x49ac,0x5a21,0x4a0d,0x2c40,0x5e85,
0x2d22,0x566c,0x5668,0x5664,0x48a1,0x51c6,0x45e3,0x5670,
0x58e3,0x41c6,0x5da1,0x5693,0x3906,0x38c4,0x2840,0x3986,
0x2d42,0x5a0f,0x34a3,0x5227,0x59e8,0x59e4,0x4dc1,0x59ec,
0x54c1,0x4587,0x4507,0x44e4,0x5e43,0x5a8f,0x2440,0x4607,
0x18a2,0x560d,0x5229,0x3d61,0x55a8,0x55a4,0x49c3,0x55ac,
0x4589,0x5943,0x4524,0x4528,0x5e61,0x568d,0x4609,0x1c40,
0x39a1,0x2ce2,0x522a,0x5e06,0x4ca3,0x5d86,0x5d06,0x5cc4,
0x458a,0x5923,0x4544,0x4548,0x5642,0x3c20,0x460a,0x5e86,
0x5ea3,0x28e2,0x522b,0x3d21,0x48c1,0x51c5,0x4da2,0x5860,
0x458b,0x41c5,0x4564,0x4568,0x3905,0x38a4,0x460b,0x3985,
0x4600,0x24e2,0x34c3,0x3d41,0x4480,0x4500,0x4580,0x5272,
0x54a1,0x5963,0x5dc2,0x4e50,0x5220,0x4e4c,0x4e48,0x4e44,
0x1ca2,0x5a4c,0x5a48,0x5a44,0x51ca,0x4d63,0x45a1,0x5a50,
0x41ca,0x5521,0x5de3,0x5a92,0x3944,0x3948,0x398a,0x1840,
0x4a23,0x2cc2,0x3ca1,0x5e07,0x51c9,0x5d87,0x5d07,0x5ce4,
0x41c9,0x5541,0x59a2,0x4c60,0x3924,0x3928,0x3989,0x5e87,
0x3980,0x28c2,0x3880,0x3900,0x48e1,0x4d23,0x41c0,0x51ed,
0x58a3,0x5561,0x51c0,0x41ed,0x5e22,0x3dac,0x3da8,0x3da4,
0x5ec1,0x24c2,0x34e3,0x5225,0x51cb,0x4d43,0x49e2,0x5420,
0x41cb,0x4585,0x4505,0x44a4,0x3964,0x3968,0x398b,0x4605,
0x1cc2,0x526f,0x5e0b,0x3523,0x5d8b,0x4941,0x5d64,0x5d68,
0x4de8,0x4de4,0x59c1,0x4dec,0x5623,0x4e0f,0x5e8b,0x1440,
0x5e80,0x2ca2,0x3cc1,0x3543,0x4ce3,0x4921,0x45c2,0x5ab4,
0x5c80,0x5d00,0x5d80,0x5ab0,0x5e00,0x5aac,0x5aa8,0x5aa4,
0x4e21,0x28a2,0x5e09,0x3563,0x5d89,0x51c7,0x5d24,0x5d28,
0x58c3,0x41c7,0x55e2,0x4820,0x3907,0x38e4,0x5e89,0x3987,
0x3dc3,0x24a2,0x5e0a,0x5226,0x5d8a,0x4961,0x5d44,0x5d48,
0x54e1,0x4586,0x4506,0x44c4,0x5a62,0x3460,0x5e8a,0x4606,
0x6301,0x2081,0x3081,0x3101,0x4081,0x4101,0x4181,0x5062,
0x5081,0x5101,0x5181,0x4062,0x5201,0x3062,0x2062,0x1062,
0x2921,0x560e,0x3ce2,0x5266,0x55c8,0x55c4,0x49a3,0x55cc,
0x5ca3,0x4d86,0x4d06,0x4cc4,0x5a22,0x568e,0x2c20,0x4e06,
0x2d21,0x522f,0x38c3,0x5a07,0x48a2,0x5987,0x5907,0x58e4,
0x45e8,0x45e4,0x5da2,0x45ec,0x5663,0x460f,0x2820,0x5a87,
0x2d41,0x5e4c,0x5e48,0x5e44,0x44e3,0x51a5,0x4dc2,0x5e50,
0x54c2,0x41a5,0x59e3,0x5e92,0x3505,0x34a4,0x2420,0x3585,
0x18a1,0x524e,0x5a0a,0x3d62,0x598a,0x4523,0x5944,0x5948,
0x49c8,0x49c4,0x55a3,0x49cc,0x5e62,0x4a0e,0x5a8a,0x1c20,
0x39a2,0x2ce1,0x5a09,0x5265,0x5989,0x4543,0x5924,0x5928,
0x5cc3,0x4d85,0x4d05,0x4ca4,0x5641,0x3c40,0x5a89,0x4e05,
0x5a80,0x28e1,0x38a3,0x3d22,0x48c2,0x4563,0x4da1,0x5eb4,
0x5880,0x5900,0x5980,0x5eb0,0x5a00,0x5eac,0x5ea8,0x5ea4,
0x4e43,0x24e1,0x5a0b,0x3d42,0x598b,0x51a6,0x5964,0x5968,
0x54a2,0x41a6,0x5dc1,0x4460,0x3506,0x34c4,0x5a8b,0x3586,
0x1ca1,0x5e0f,0x526b,0x3943,0x5de8,0x5de4,0x45a2,0x5dec,
0x4d8b,0x5522,0x4d64,0x4d68,0x5a43,0x5e8f,0x4e0b,0x1820,
0x4e00,0x2cc1,0x3ca2,0x3923,0x4c80,0x4d00,0x4d80,0x5251,
0x5ce3,0x5542,0x59a1,0x4a30,0x5260,0x4a2c,0x4a28,0x4a24,
0x3da3,0x28c1,0x5269,0x5a05,0x48e2,0x5985,0x5905,0x58a4,
0x4d89,0x5562,0x4d24,0x4d28,0x5e21,0x3860,0x4e09,0x5a85,
0x5ec2,0x24c1,0x526a,0x3963,0x44a3,0x51a7,0x49e1,0x5440,
0x4d8a,0x41a7,0x4d44,0x4d48,0x3507,0x34e4,0x4e0a,0x3587,
0x1cc1,0x562c,0x5628,0x5624,0x51a9,0x4942,0x4de3,0x5630,
0x41a9,0x5d63,0x59c2,0x5691,0x3524,0x3528,0x3589,0x1420,
0x5aa3,0x2ca1,0x3cc2,0x5267,0x51aa,0x4922,0x45c1,0x5c60,
0x41aa,0x4d87,0x4d07,0x4ce4,0x3544,0x3548,0x358a,0x4e07,
0x4e22,0x28a1,0x38e3,0x5a06,0x51ab,0x5986,0x5906,0x58c4,
0x41ab,0x5d23,0x55e1,0x4840,0x3564,0x3568,0x358b,0x5a86,
0x3580,0x24a1,0x3480,0x3500,0x44c3,0x4962,0x41a0,0x51ee,
0x54e2,0x5d43,0x51a0,0x41ee,0x5a61,0x3dcc,0x3dc8,0x3dc4
};



// %%COMMENT
// The #define macro mat24_def_octad_to_gcode(o) returns the  number 
// of the Golay code word corresponding to octad o. This is equivalent
// to mat24_octad_to_gcode(o) without parameter check.
//
// The #define macro mat24_def_gcode_to_octad(v) return the number
// of the octad corresponding to Golay code vector v, with v in 'gcode'
// representation. It returns garbage if v is not an octad.
//
// These macros use the public tables MAT24_OCT_DEC_TABLE and
// MAT24_OCT_ENC_TABLE.

// %%GEN h
// #define mat24_def_octad_to_gcode(o) (MAT24_OCT_DEC_TABLE[o])
// #define mat24_def_gcode_to_octad(v) \ //
//   ((MAT24_OCT_ENC_TABLE[(v) >> 1] >> 1) \ //
//     + 3 * ((v) >> 4) - 11)
// %%GEN c


// %%EXPORT_TABLE p
MAT24_API
const uint16_t MAT24_OCT_DEC_TABLE[759] = { 
// %%TABLE Mat24_oct_dec_table, uint16
0x0003,0x0005,0x0006,0x0009,0x000a,0x000c,0x000e,0x0011,
0x0012,0x0014,0x0016,0x0018,0x001a,0x001c,0x001f,0x0020,
0x0026,0x002a,0x002c,0x0032,0x0034,0x0038,0x003e,0x0040,
0x0046,0x004a,0x004c,0x0052,0x0054,0x0058,0x005e,0x0060,
0x0066,0x006a,0x006c,0x0072,0x0074,0x0078,0x007e,0x0080,
0x0082,0x008c,0x008e,0x0094,0x0096,0x0098,0x009a,0x00a0,
0x00a4,0x00aa,0x00ae,0x00b2,0x00b6,0x00b8,0x00bc,0x00c0,
0x00c6,0x00c8,0x00ce,0x00d2,0x00d4,0x00da,0x00dc,0x00e0,
0x00e6,0x00ea,0x00ec,0x00f0,0x00f6,0x00fa,0x00fc,0x0100,
0x0102,0x010c,0x010e,0x0114,0x0116,0x0118,0x011a,0x0120,
0x0126,0x012a,0x012c,0x0130,0x0136,0x013a,0x013c,0x0140,
0x0144,0x014a,0x014e,0x0152,0x0156,0x0158,0x015c,0x0160,
0x0166,0x0168,0x016e,0x0172,0x0174,0x017a,0x017c,0x0180,
0x0182,0x018c,0x018e,0x0194,0x0196,0x0198,0x019a,0x01a0,
0x01a6,0x01a8,0x01ae,0x01b2,0x01b4,0x01ba,0x01bc,0x01c0,
0x01c6,0x01ca,0x01cc,0x01d0,0x01d6,0x01da,0x01dc,0x01e0,
0x01e4,0x01ea,0x01ee,0x01f2,0x01f6,0x01f8,0x01fc,0x0200,
0x0205,0x0209,0x020c,0x0211,0x0214,0x0218,0x021d,0x0220,
0x0223,0x0229,0x022a,0x0231,0x0232,0x0238,0x023b,0x0240,
0x0243,0x0245,0x0246,0x0249,0x024a,0x024c,0x024f,0x0260,
0x0263,0x0265,0x0266,0x0271,0x0272,0x0274,0x0277,0x0280,
0x0287,0x0289,0x028e,0x0291,0x0296,0x0298,0x029f,0x02a0,
0x02a3,0x02a5,0x02a6,0x02b9,0x02ba,0x02bc,0x02bf,0x0300,
0x0305,0x030b,0x030e,0x0311,0x0314,0x031a,0x031f,0x0360,
0x0363,0x0369,0x036a,0x0375,0x0376,0x037c,0x037f,0x0380,
0x0385,0x0389,0x038c,0x0393,0x0396,0x039a,0x039f,0x03c0,
0x03c3,0x03cd,0x03ce,0x03d1,0x03d2,0x03dc,0x03df,0x0400,
0x0405,0x0409,0x040c,0x0411,0x0414,0x0418,0x041d,0x0420,
0x0423,0x0425,0x0426,0x0431,0x0432,0x0434,0x0437,0x0440,
0x0443,0x0449,0x044a,0x0451,0x0452,0x0458,0x045b,0x0460,
0x0463,0x0465,0x0466,0x0469,0x046a,0x046c,0x046f,0x0480,
0x0485,0x0489,0x048c,0x0493,0x0496,0x049a,0x049f,0x04e0,
0x04e3,0x04ed,0x04ee,0x04f1,0x04f2,0x04fc,0x04ff,0x0500,
0x0507,0x0509,0x050e,0x0511,0x0516,0x0518,0x051f,0x0540,
0x0543,0x0545,0x0546,0x0559,0x055a,0x055c,0x055f,0x0580,
0x0585,0x058b,0x058e,0x0591,0x0594,0x059a,0x059f,0x05a0,
0x05a3,0x05a9,0x05aa,0x05b5,0x05b6,0x05bc,0x05bf,0x0600,
0x0605,0x0609,0x060c,0x0611,0x0614,0x0618,0x061d,0x0620,
0x0623,0x0625,0x0626,0x0629,0x062a,0x062c,0x062f,0x0640,
0x0643,0x0645,0x0646,0x0651,0x0652,0x0654,0x0657,0x0660,
0x0663,0x0669,0x066a,0x0671,0x0672,0x0678,0x067b,0x0680,
0x0685,0x068b,0x068e,0x0691,0x0694,0x069a,0x069f,0x06c0,
0x06c3,0x06c9,0x06ca,0x06d5,0x06d6,0x06dc,0x06df,0x0700,
0x0705,0x0709,0x070c,0x0713,0x0716,0x071a,0x071f,0x0720,
0x0723,0x072d,0x072e,0x0731,0x0732,0x073c,0x073f,0x0780,
0x0787,0x0789,0x078e,0x0791,0x0796,0x0798,0x079f,0x07e0,
0x07e3,0x07e5,0x07e6,0x07f9,0x07fa,0x07fc,0x07ff,0x0800,
0x0803,0x0805,0x0809,0x0811,0x081f,0x0821,0x082f,0x0837,
0x083b,0x083d,0x083e,0x0841,0x084f,0x0857,0x085b,0x085d,
0x085e,0x0861,0x086f,0x0877,0x087b,0x087d,0x087e,0x0881,
0x0882,0x0887,0x088b,0x0893,0x089d,0x08a1,0x08a4,0x08a7,
0x08ad,0x08b5,0x08bb,0x08c1,0x08c8,0x08cb,0x08cd,0x08d7,
0x08d9,0x08e1,0x08ef,0x08f0,0x08f3,0x08f5,0x08f9,0x0901,
0x0902,0x0907,0x090b,0x0913,0x091d,0x0921,0x092f,0x0930,
0x0933,0x0935,0x0939,0x0941,0x0944,0x0947,0x094d,0x0955,
0x095b,0x0961,0x0968,0x096b,0x096d,0x0977,0x0979,0x0981,
0x0982,0x0987,0x098b,0x0993,0x099d,0x09a1,0x09a8,0x09ab,
0x09ad,0x09b7,0x09b9,0x09c1,0x09cf,0x09d0,0x09d3,0x09d5,
0x09d9,0x09e1,0x09e4,0x09e7,0x09ed,0x09f5,0x09fb,0x0a02,
0x0a0c,0x0a14,0x0a18,0x0a1d,0x0a1e,0x0a24,0x0a2a,0x0a32,
0x0a38,0x0a3b,0x0a3e,0x0a46,0x0a4a,0x0a4c,0x0a4f,0x0a50,
0x0a5e,0x0a66,0x0a68,0x0a72,0x0a74,0x0a77,0x0a7e,0x0a82,
0x0a84,0x0a87,0x0a8e,0x0a96,0x0a98,0x0aa6,0x0aa8,0x0ab0,
0x0ab9,0x0aba,0x0abc,0x0ac1,0x0ac2,0x0ac4,0x0ac8,0x0ad0,
0x0ade,0x0ae1,0x0ae2,0x0ae4,0x0ae8,0x0af0,0x0afe,0x0b02,
0x0b08,0x0b0b,0x0b0e,0x0b14,0x0b1a,0x0b21,0x0b22,0x0b24,
0x0b28,0x0b30,0x0b3e,0x0b41,0x0b42,0x0b44,0x0b48,0x0b50,
0x0b5e,0x0b64,0x0b6a,0x0b70,0x0b75,0x0b76,0x0b7c,0x0b82,
0x0b8c,0x0b90,0x0b93,0x0b96,0x0b9a,0x0ba1,0x0ba2,0x0ba4,
0x0ba8,0x0bb0,0x0bbe,0x0bc4,0x0bc8,0x0bcd,0x0bce,0x0bd2,
0x0bdc,0x0be1,0x0be2,0x0be4,0x0be8,0x0bf0,0x0bfe,0x0c02,
0x0c0c,0x0c14,0x0c18,0x0c1d,0x0c1e,0x0c26,0x0c28,0x0c32,
0x0c34,0x0c37,0x0c3e,0x0c44,0x0c4a,0x0c52,0x0c58,0x0c5b,
0x0c5e,0x0c66,0x0c6a,0x0c6c,0x0c6f,0x0c70,0x0c7e,0x0c82,
0x0c8c,0x0c90,0x0c93,0x0c96,0x0c9a,0x0ca1,0x0ca2,0x0ca4,
0x0ca8,0x0cb0,0x0cbe,0x0cc1,0x0cc2,0x0cc4,0x0cc8,0x0cd0,
0x0cde,0x0ce4,0x0ce8,0x0ced,0x0cee,0x0cf2,0x0cfc,0x0d02,
0x0d04,0x0d07,0x0d0e,0x0d16,0x0d18,0x0d21,0x0d22,0x0d24,
0x0d28,0x0d30,0x0d3e,0x0d46,0x0d48,0x0d50,0x0d59,0x0d5a,
0x0d5c,0x0d61,0x0d62,0x0d64,0x0d68,0x0d70,0x0d7e,0x0d82,
0x0d88,0x0d8b,0x0d8e,0x0d94,0x0d9a,0x0da4,0x0daa,0x0db0,
0x0db5,0x0db6,0x0dbc,0x0dc1,0x0dc2,0x0dc4,0x0dc8,0x0dd0,
0x0dde,0x0de1,0x0de2,0x0de4,0x0de8,0x0df0,0x0dfe,0x0e02,
0x0e0c,0x0e14,0x0e18,0x0e1d,0x0e1e,0x0e26,0x0e2a,0x0e2c,
0x0e2f,0x0e30,0x0e3e,0x0e46,0x0e48,0x0e52,0x0e54,0x0e57,
0x0e5e,0x0e64,0x0e6a,0x0e72,0x0e78,0x0e7b,0x0e7e,0x0e82,
0x0e88,0x0e8b,0x0e8e,0x0e94,0x0e9a,0x0ea1,0x0ea2,0x0ea4,
0x0ea8,0x0eb0,0x0ebe,0x0ec4,0x0eca,0x0ed0,0x0ed5,0x0ed6,
0x0edc,0x0ee1,0x0ee2,0x0ee4,0x0ee8,0x0ef0,0x0efe,0x0f02,
0x0f0c,0x0f10,0x0f13,0x0f16,0x0f1a,0x0f24,0x0f28,0x0f2d,
0x0f2e,0x0f32,0x0f3c,0x0f41,0x0f42,0x0f44,0x0f48,0x0f50,
0x0f5e,0x0f61,0x0f62,0x0f64,0x0f68,0x0f70,0x0f7e,0x0f82,
0x0f84,0x0f87,0x0f8e,0x0f96,0x0f98,0x0fa1,0x0fa2,0x0fa4,
0x0fa8,0x0fb0,0x0fbe,0x0fc1,0x0fc2,0x0fc4,0x0fc8,0x0fd0,
0x0fde,0x0fe6,0x0fe8,0x0ff0,0x0ff9,0x0ffa,0x0ffc
};

// %%EXPORT_TABLE p
MAT24_API
const uint8_t MAT24_OCT_ENC_TABLE[2048] = { 
// %%TABLE Mat24_oct_enc_table, uint8
0xff,0x17,0x19,0x1a,0x1d,0x1e,0x20,0x22,
0x1f,0x20,0x22,0x24,0x26,0x28,0x2a,0x2d,
0x28,0xff,0xff,0x2a,0xff,0x2c,0x2e,0xff,
0xff,0x2a,0x2c,0xff,0x2e,0xff,0xff,0x30,
0x2c,0xff,0xff,0x2e,0xff,0x30,0x32,0xff,
0xff,0x2e,0x30,0xff,0x32,0xff,0xff,0x34,
0x30,0xff,0xff,0x32,0xff,0x34,0x36,0xff,
0xff,0x32,0x34,0xff,0x36,0xff,0xff,0x38,
0x34,0x36,0xff,0xff,0xff,0xff,0x38,0x3a,
0xff,0xff,0x36,0x38,0x3a,0x3c,0xff,0xff,
0x38,0xff,0x3a,0xff,0xff,0x3c,0xff,0x3e,
0xff,0x3a,0xff,0x3c,0x3e,0xff,0x40,0xff,
0x3c,0xff,0xff,0x3e,0x40,0xff,0xff,0x42,
0xff,0x3e,0x40,0xff,0xff,0x42,0x44,0xff,
0x40,0xff,0xff,0x42,0xff,0x44,0x46,0xff,
0x42,0xff,0xff,0x44,0xff,0x46,0x48,0xff,
0x44,0x46,0xff,0xff,0xff,0xff,0x48,0x4a,
0xff,0xff,0x46,0x48,0x4a,0x4c,0xff,0xff,
0x48,0xff,0xff,0x4a,0xff,0x4c,0x4e,0xff,
0x4a,0xff,0xff,0x4c,0xff,0x4e,0x50,0xff,
0x4c,0xff,0x4e,0xff,0xff,0x50,0xff,0x52,
0xff,0x4e,0xff,0x50,0x52,0xff,0x54,0xff,
0x50,0xff,0xff,0x52,0x54,0xff,0xff,0x56,
0xff,0x52,0x54,0xff,0xff,0x56,0x58,0xff,
0x54,0x56,0xff,0xff,0xff,0xff,0x58,0x5a,
0xff,0xff,0x56,0x58,0x5a,0x5c,0xff,0xff,
0x58,0xff,0xff,0x5a,0x5c,0xff,0xff,0x5e,
0xff,0x5a,0x5c,0xff,0xff,0x5e,0x60,0xff,
0x5c,0xff,0xff,0x5e,0xff,0x60,0x62,0xff,
0x5e,0xff,0xff,0x60,0xff,0x62,0x64,0xff,
0x60,0xff,0x62,0xff,0xff,0x64,0xff,0x66,
0xff,0x62,0xff,0x64,0x66,0xff,0x68,0xff,
0x64,0xff,0x67,0xff,0x69,0xff,0x6a,0xff,
0x67,0xff,0x68,0xff,0x6a,0xff,0x6d,0xff,
0x68,0x6b,0xff,0xff,0x6d,0x6e,0xff,0xff,
0x6b,0x6c,0xff,0xff,0x6e,0x71,0xff,0xff,
0x6c,0x6f,0x71,0x72,0x75,0x76,0x78,0x7b,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x70,0x73,0x75,0x76,0xff,0xff,0xff,0xff,
0x73,0x74,0x76,0x79,0xff,0xff,0xff,0xff,
0x74,0xff,0xff,0x77,0x79,0xff,0xff,0x7a,
0x77,0xff,0xff,0x78,0x7a,0xff,0xff,0x7d,
0x78,0x7b,0x7d,0x7e,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0x7b,0x7c,0x7e,0x81,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x64,0xff,0x67,0xff,0xff,0x69,0xff,0x6a,
0x67,0xff,0x68,0xff,0xff,0x6a,0xff,0x6d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x50,0x53,0xff,0xff,0x55,0x56,0xff,0xff,
0xff,0xff,0x53,0x54,0xff,0xff,0x56,0x59,
0x54,0xff,0x57,0xff,0x59,0xff,0x5a,0xff,
0xff,0x57,0xff,0x58,0xff,0x5a,0xff,0x5d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x4c,0x4f,0xff,0xff,0xff,0xff,0x51,0x52,
0x4f,0x50,0xff,0xff,0xff,0xff,0x52,0x55,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x44,0xff,0x47,0xff,0x49,0xff,0x4a,0xff,
0x47,0xff,0x48,0xff,0x4a,0xff,0x4d,0xff,
0x48,0x4b,0x4d,0x4e,0xff,0xff,0xff,0xff,
0x4b,0x4c,0x4e,0x51,0xff,0xff,0xff,0xff,
0x4c,0x4f,0xff,0xff,0x51,0x52,0xff,0xff,
0x4f,0x50,0xff,0xff,0x52,0x55,0xff,0xff,
0x50,0x53,0x55,0x56,0x59,0x5a,0x5c,0x5f,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x54,0xff,0x57,0xff,0x59,0xff,0x5a,0xff,
0xff,0x57,0xff,0x58,0xff,0x5a,0xff,0x5d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x40,0x43,0xff,0xff,0xff,0xff,0x45,0x46,
0x43,0x44,0xff,0xff,0xff,0xff,0x46,0x49,
0x44,0xff,0xff,0x47,0x49,0xff,0xff,0x4a,
0x47,0xff,0xff,0x48,0x4a,0xff,0xff,0x4d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x3c,0x3f,0x41,0x42,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0x3f,0x40,0x42,0x45,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x34,0xff,0x37,0xff,0xff,0x39,0xff,0x3a,
0x37,0xff,0x38,0xff,0xff,0x3a,0xff,0x3d,
0x38,0x3b,0xff,0xff,0x3d,0x3e,0xff,0xff,
0xff,0xff,0x3b,0x3c,0xff,0xff,0x3e,0x41,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x24,0xff,0x27,0xff,0x29,0xff,0x2a,0xff,
0x27,0xff,0x28,0xff,0x2a,0xff,0x2d,0xff,
0x28,0x2b,0x2d,0x2e,0x31,0x32,0x34,0x37,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x2c,0x2f,0x31,0x32,0xff,0xff,0xff,0xff,
0x2f,0x30,0x32,0x35,0xff,0xff,0xff,0xff,
0x30,0x33,0xff,0xff,0x35,0x36,0xff,0xff,
0x33,0x34,0xff,0xff,0x36,0x39,0xff,0xff,
0x34,0xff,0x37,0xff,0xff,0x39,0xff,0x3a,
0x37,0xff,0x38,0xff,0xff,0x3a,0xff,0x3d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x2c,0x2f,0xff,0xff,0x31,0x32,0xff,0xff,
0xff,0xff,0x2f,0x30,0xff,0xff,0x32,0x35,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x24,0xff,0x27,0xff,0x29,0xff,0x2a,0xff,
0xff,0x27,0xff,0x28,0xff,0x2a,0xff,0x2d,
0x28,0x2b,0xff,0xff,0xff,0xff,0x2d,0x2e,
0x2b,0x2c,0xff,0xff,0xff,0xff,0x2e,0x31,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x14,0xff,0xff,0x17,0x19,0xff,0xff,0x1a,
0x17,0xff,0xff,0x18,0x1a,0xff,0xff,0x1d,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x00,0x03,0x05,0x06,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0x03,0x04,0x06,0x09,
0x04,0x07,0x09,0xff,0x0b,0xff,0xff,0xff,
0x07,0xff,0xff,0xff,0xff,0xff,0xff,0x09,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0xff,0xff,0xff,0x03,0xff,0x05,0x07,0x08,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0xff,0xff,0xff,0x03,0xff,0x05,0x07,0x08,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0xff,0xff,0xff,0x03,0xff,0x05,0x07,0x08,
0x05,0x06,0xff,0x09,0xff,0x0b,0xff,0xff,
0xff,0x07,0xff,0xff,0xff,0xff,0x09,0xff,
0x05,0xff,0x06,0x09,0xff,0xff,0x0b,0xff,
0xff,0xff,0x07,0xff,0xff,0x09,0xff,0xff,
0x05,0xff,0xff,0xff,0x06,0x09,0x0b,0xff,
0xff,0xff,0xff,0x07,0x09,0xff,0xff,0xff,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0x02,0x05,0x07,0xff,0x09,0xff,0xff,0xff,
0x05,0x06,0xff,0x09,0xff,0x0b,0xff,0xff,
0xff,0x07,0xff,0xff,0xff,0xff,0x09,0xff,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0x02,0x05,0x07,0xff,0x09,0xff,0xff,0xff,
0x05,0xff,0x06,0x09,0xff,0xff,0x0b,0xff,
0xff,0xff,0x07,0xff,0xff,0x09,0xff,0xff,
0x05,0xff,0xff,0xff,0x06,0x09,0x0b,0xff,
0xff,0xff,0xff,0x07,0x09,0xff,0xff,0xff,
0x05,0x06,0xff,0x09,0xff,0x0b,0xff,0xff,
0xff,0x07,0xff,0xff,0xff,0xff,0x09,0xff,
0x05,0xff,0xff,0xff,0x06,0x09,0x0b,0xff,
0xff,0xff,0xff,0x07,0x09,0xff,0xff,0xff,
0x05,0xff,0xff,0xff,0xff,0xff,0xff,0x07,
0x02,0x05,0x07,0xff,0x09,0xff,0xff,0xff,
0x05,0xff,0x06,0x09,0xff,0xff,0x0b,0xff,
0xff,0xff,0x07,0xff,0xff,0x09,0xff,0xff,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0xff,0xff,0x02,0xff,0x04,0xff,0x07,0x08,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0xff,0x02,0xff,0xff,0x04,0x07,0xff,0x08,
0xff,0xff,0xff,0x04,0xff,0x06,0x08,0x0b,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0xff,0x02,0x04,0x07,0xff,0xff,0xff,0x08,
0xff,0x04,0x06,0x09,0xff,0xff,0xff,0x0a,
0xff,0xff,0xff,0x06,0x08,0xff,0xff,0xff,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0x02,0xff,0xff,0xff,0x05,0x06,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0x06,0x09,0xff,0x0a,
0xff,0xff,0x06,0xff,0xff,0x08,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0x02,0xff,0x05,0x06,0xff,0xff,0x08,0xff,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0x02,0x05,0xff,0x06,0xff,0x08,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0x06,0xff,0x09,0x0a,
0xff,0x06,0xff,0xff,0xff,0xff,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0xff,0xff,0x02,0xff,0x04,0xff,0x07,0x08,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0xff,0x02,0x04,0x07,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0xff,0x02,0xff,0xff,0x04,0x07,0xff,0x08,
0xff,0xff,0xff,0x04,0xff,0x06,0x08,0x0b,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0x02,0x05,0xff,0x06,0xff,0x08,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0x06,0xff,0x09,0x0a,
0xff,0x06,0xff,0xff,0xff,0xff,0x08,0xff,
0xff,0x04,0x06,0x09,0xff,0xff,0xff,0x0a,
0xff,0xff,0xff,0x06,0x08,0xff,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0x02,0xff,0xff,0xff,0x05,0x06,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0x06,0x09,0xff,0x0a,
0xff,0xff,0x06,0xff,0xff,0x08,0xff,0xff,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0x02,0xff,0x05,0x06,0xff,0xff,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0xff,0xff,0x02,0xff,0x04,0xff,0x07,0x08,
0xff,0xff,0xff,0x04,0xff,0x06,0x08,0x0b,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0xff,0x02,0x04,0x07,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0xff,0x02,0xff,0xff,0x04,0x07,0xff,0x08,
0xff,0x04,0xff,0xff,0x06,0x09,0xff,0x0a,
0xff,0xff,0x06,0xff,0xff,0x08,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0x04,0xff,0xff,0x06,0xff,0xff,
0x02,0xff,0x05,0x06,0xff,0xff,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0xff,0xff,0xff,0xff,0x06,0xff,
0x02,0x05,0xff,0x06,0xff,0x08,0xff,0xff,
0xff,0xff,0x04,0xff,0x06,0xff,0x09,0x0a,
0xff,0x06,0xff,0xff,0xff,0xff,0x08,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0x04,0x06,0x09,0xff,0xff,0xff,0x0a,
0xff,0xff,0xff,0x06,0x08,0xff,0xff,0xff,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0x05,0x06,0x08,0xff,0x0a,0xff,0xff,0xff,
0x06,0xff,0xff,0xff,0xff,0xff,0xff,0x08,
0xff,0xff,0xff,0x04,0x06,0xff,0xff,0xff,
0x02,0xff,0xff,0xff,0x05,0x06,0x08,0xff
};








// %%COMMENT:
// The public table MAT24_THETA_TABLE contains data about the Golay 
// code. Entry i contains the following information the code word d,
// (with d = 2*i in 'gcode' representation):
// Bit 11,...,0:   mat24_ploop_theta(d)
// Bit 14,...,12:  Bit weight of code word d in GF(2)**24 divided by 4
// Bit 15:         reserved
// 
// We have d**2 = (-1)**<Bit 12 of i> for d = 2*i in the Parker loop.

// %%EXPORT_TABLE
MAT24_API
const uint16_t MAT24_THETA_TABLE[] = { 
// %%TABLE Mat24_theta_table, uint16
0x0000,0x401c,0x401a,0x2806,0x4016,0x280a,0x280c,0x2810,
0x400e,0x2812,0x2814,0x2808,0x2818,0x2804,0x2802,0x401e,
0x201e,0x3042,0x3544,0x2d18,0x33c8,0x2b94,0x2e92,0x3ece,
0x36d0,0x2e8c,0x2b8a,0x3bd6,0x2d06,0x3d5a,0x385c,0x2000,
0x201e,0x3022,0x32a4,0x2a98,0x3728,0x2f14,0x2d92,0x3dae,
0x35b0,0x2d8c,0x2f0a,0x3f36,0x2a86,0x3aba,0x383c,0x2000,
0x201e,0x3062,0x37e4,0x2f98,0x34e8,0x2c94,0x2b12,0x3b6e,
0x3370,0x2b0c,0x2c8a,0x3cf6,0x2f86,0x3ffa,0x387c,0x2000,
0x201c,0x2000,0x3546,0x3d5a,0x372a,0x3f36,0x2a70,0x2a6c,
0x3372,0x3b6e,0x2e28,0x2e34,0x2c44,0x2c58,0x391e,0x3102,
0x241a,0x3446,0x2400,0x3c5c,0x30ec,0x28b0,0x38f6,0x28aa,
0x31b4,0x29e8,0x39ae,0x29f2,0x2d42,0x3d1e,0x2d58,0x3504,
0x2616,0x362a,0x31ec,0x29d0,0x2600,0x3e3c,0x39fa,0x29c6,
0x30d8,0x28e4,0x2f22,0x3f1e,0x38ce,0x28f2,0x2f34,0x3708,
0x220e,0x3272,0x30b4,0x28c8,0x31d8,0x29a4,0x2b62,0x3b1e,
0x2200,0x3a7c,0x38ba,0x28c6,0x39d6,0x29aa,0x2b6c,0x3310,
0x201c,0x2000,0x32a6,0x3aba,0x34ea,0x3cf6,0x2e50,0x2e4c,
0x36d2,0x3ece,0x2c68,0x2c74,0x2a24,0x2a38,0x389e,0x3082,
0x260e,0x3652,0x31f4,0x29a8,0x3138,0x2964,0x2ec2,0x3e9e,
0x2600,0x3e5c,0x39fa,0x29a6,0x3936,0x296a,0x2ecc,0x3690,
0x221a,0x3226,0x2200,0x3a3c,0x31cc,0x29f0,0x39d6,0x29ea,
0x3174,0x2948,0x396e,0x2952,0x2aa2,0x3a9e,0x2ab8,0x3284,
0x2416,0x346a,0x314c,0x2930,0x2400,0x3c7c,0x395a,0x2926,
0x31b8,0x29c4,0x2ce2,0x3c9e,0x39ae,0x29d2,0x2cf4,0x3488,
0x201c,0x2000,0x37e6,0x3ffa,0x33ca,0x3bd6,0x2c30,0x2c2c,
0x35b2,0x3dae,0x2a48,0x2a54,0x2e64,0x2e78,0x399e,0x3182,
0x2216,0x324a,0x30ac,0x28f0,0x2200,0x3a5c,0x38ba,0x28e6,
0x3178,0x2924,0x2bc2,0x3b9e,0x396e,0x2932,0x2bd4,0x3388,
0x240e,0x3432,0x3154,0x2968,0x30f8,0x28c4,0x2da2,0x3d9e,
0x2400,0x3c3c,0x395a,0x2966,0x38f6,0x28ca,0x2dac,0x3590,
0x261a,0x3666,0x2600,0x3e7c,0x312c,0x2950,0x3936,0x294a,
0x30d4,0x28a8,0x38ce,0x28b2,0x2fe2,0x3f9e,0x2ff8,0x3784,
0x2802,0x3c1e,0x4958,0x3544,0x48f4,0x34e8,0x21ae,0x35b2,
0x49ac,0x35b0,0x20f6,0x34ea,0x215a,0x3546,0x4000,0x3c1c,
0x2904,0x4d58,0x3d1e,0x3142,0x4a32,0x266e,0x3628,0x3274,
0x4e6a,0x2236,0x3270,0x362c,0x255c,0x4100,0x3146,0x3d1a,
0x2990,0x4dac,0x4a6a,0x2656,0x4e46,0x227a,0x25bc,0x4180,
0x3d9e,0x31a2,0x3664,0x3258,0x3248,0x3674,0x31b2,0x3d8e,
0x2888,0x4cf4,0x4e32,0x224e,0x3c9e,0x30e2,0x3224,0x3658,
0x4a46,0x263a,0x24fc,0x4080,0x3650,0x322c,0x30ea,0x3c96,
0x2846,0x3c5a,0x3c5c,0x4040,0x4f90,0x338c,0x338a,0x2796,
0x4a88,0x3694,0x3692,0x228e,0x255e,0x3142,0x3144,0x4d58,
0x2d58,0x4904,0x4c02,0x205e,0x394e,0x3512,0x3014,0x3448,
0x3956,0x350a,0x300c,0x3450,0x4540,0x211c,0x241a,0x4846,
0x3fc0,0x3bfc,0x397a,0x3546,0x3f36,0x330a,0x318c,0x35b0,
0x38ae,0x3492,0x3614,0x3228,0x3058,0x3464,0x36e2,0x3ade,
0x3ac0,0x3ebc,0x393a,0x3546,0x39f6,0x358a,0x320c,0x3670,
0x3b6e,0x3712,0x3094,0x34e8,0x3058,0x3424,0x33a2,0x3fde,
0x286a,0x3c76,0x4b90,0x378c,0x3c7c,0x4060,0x3786,0x239a,
0x4f04,0x3318,0x24fe,0x30e2,0x3312,0x270e,0x30e8,0x4cf4,
0x3f60,0x3b3c,0x39da,0x3586,0x38b6,0x34ea,0x360c,0x3250,
0x3ece,0x3292,0x3074,0x3428,0x3118,0x3544,0x37a2,0x3bfe,
0x3be0,0x3fdc,0x3aba,0x3686,0x38d6,0x34ea,0x318c,0x35b0,
0x392e,0x3512,0x3074,0x3448,0x3218,0x3624,0x3342,0x3f7e,
0x2cf4,0x4888,0x38ee,0x3492,0x4c02,0x207e,0x3018,0x3464,
0x38fa,0x3486,0x44e0,0x209c,0x300c,0x3470,0x2416,0x486a,
0x2832,0x3c2e,0x4e88,0x3294,0x4b04,0x3718,0x25be,0x31a2,
0x3c3c,0x4020,0x3286,0x269a,0x370a,0x2316,0x31b0,0x4dac,
0x3b20,0x3f7c,0x38da,0x3486,0x3bd6,0x378a,0x302c,0x3470,
0x39ee,0x35b2,0x3214,0x3648,0x3118,0x3544,0x32e2,0x3ebe,
0x2dac,0x4990,0x39b6,0x358a,0x39ba,0x3586,0x45a0,0x219c,
0x4c02,0x203e,0x3018,0x3424,0x3014,0x3428,0x240e,0x4832,
0x3ea0,0x3adc,0x3ffa,0x3386,0x3976,0x350a,0x302c,0x3450,
0x39ce,0x35b2,0x3094,0x34e8,0x3618,0x3264,0x3742,0x3b3e,
0x2802,0x3a1e,0x48b8,0x32a4,0x49d4,0x33c8,0x216e,0x3372,
0x496c,0x3370,0x21d6,0x33ca,0x20ba,0x32a6,0x4000,0x3a1c,
0x2988,0x4bd4,0x4c72,0x262e,0x3b9e,0x31c2,0x3664,0x3438,
0x4e26,0x247a,0x23dc,0x4180,0x3430,0x366c,0x31ca,0x3b96,
0x2884,0x4ab8,0x3a9e,0x30a2,0x4e72,0x244e,0x3468,0x3654,
0x4c4a,0x2676,0x3650,0x346c,0x22bc,0x4080,0x30a6,0x3a9a,
0x2910,0x4b6c,0x4e4a,0x2436,0x4c26,0x265a,0x237c,0x4100,
0x3b1e,0x3162,0x3444,0x3638,0x3628,0x3454,0x3172,0x3b0e,
0x2872,0x3a6e,0x4d88,0x3794,0x4e84,0x3498,0x237e,0x3162,
0x3a7c,0x4060,0x3786,0x259a,0x348a,0x2696,0x3170,0x4b6c,
0x3de0,0x3fbc,0x3d5a,0x3706,0x38d6,0x328a,0x306c,0x3230,
0x392e,0x3372,0x3194,0x33c8,0x3418,0x3644,0x34a2,0x3efe,
0x3ee0,0x3cdc,0x39ba,0x3386,0x3f36,0x350a,0x306c,0x3250,
0x394e,0x3372,0x3614,0x3428,0x3098,0x32a4,0x37c2,0x3dfe,
0x2b6c,0x4910,0x3976,0x330a,0x397a,0x3306,0x4360,0x211c,
0x4a02,0x207e,0x3018,0x3264,0x3014,0x3268,0x220e,0x4872,
0x2826,0x3a3a,0x3a3c,0x4020,0x4d10,0x370c,0x370a,0x2516,
0x4f88,0x3594,0x3592,0x278e,0x22be,0x30a2,0x30a4,0x4ab8,
0x3fa0,0x3dfc,0x38fa,0x32a6,0x3956,0x330a,0x360c,0x3450,
0x3ece,0x3492,0x3194,0x33c8,0x3038,0x3264,0x3762,0x3d3e,
0x2ab8,0x4884,0x4a02,0x203e,0x38ae,0x3292,0x3014,0x3228,
0x38b6,0x328a,0x300c,0x3230,0x42a0,0x209c,0x221a,0x4826,
0x3d20,0x3f5c,0x38da,0x32a6,0x3cf6,0x368a,0x310c,0x3370,
0x39ee,0x3392,0x3414,0x3668,0x3038,0x3244,0x35c2,0x3fbe,
0x284a,0x3a56,0x4f10,0x350c,0x3a5c,0x4040,0x3506,0x271a,
0x4c84,0x3698,0x23de,0x31c2,0x3692,0x248e,0x31c8,0x4bd4,
0x2bd4,0x4988,0x39ce,0x3392,0x4a02,0x205e,0x3018,0x3244,
0x39da,0x3386,0x43c0,0x219c,0x300c,0x3250,0x2216,0x484a,
0x3cc0,0x3efc,0x393a,0x3306,0x39f6,0x33ca,0x340c,0x3630,
0x3dae,0x3792,0x3054,0x3268,0x3098,0x32a4,0x3562,0x3f5e,
0x3f40,0x3d3c,0x3ffa,0x3586,0x39b6,0x33ca,0x310c,0x3370,
0x38ee,0x3292,0x3054,0x3228,0x3618,0x3464,0x36a2,0x3cde,
0x2802,0x3e1e,0x49f8,0x37e4,0x4934,0x3728,0x20ce,0x36d2,
0x48cc,0x36d0,0x2136,0x372a,0x21fa,0x37e6,0x4000,0x3e1c,
0x2890,0x4ecc,0x4c2a,0x2276,0x4a66,0x243a,0x26dc,0x4080,
0x3e9e,0x30c2,0x3224,0x3478,0x3468,0x3234,0x30d2,0x3e8e,
0x2908,0x4f34,0x4a52,0x246e,0x3f1e,0x3122,0x3444,0x3278,
0x4c66,0x225a,0x273c,0x4100,0x3270,0x344c,0x312a,0x3f16,
0x2984,0x4ff8,0x3f9e,0x31e2,0x4c52,0x222e,0x3248,0x3434,
0x4a2a,0x2456,0x3430,0x324c,0x27fc,0x4180,0x31e6,0x3f9a,
0x282a,0x3e36,0x4c90,0x328c,0x3e3c,0x4020,0x3286,0x249a,
0x4b84,0x3598,0x273e,0x3122,0x3592,0x238e,0x3128,0x4f34,
0x3ca0,0x3afc,0x3d5a,0x3306,0x3976,0x372a,0x308c,0x36d0,
0x39ce,0x3792,0x3034,0x3668,0x3418,0x3244,0x35e2,0x3bbe,
0x2f34,0x4908,0x392e,0x3712,0x4e02,0x203e,0x3018,0x3624,
0x393a,0x3706,0x4720,0x211c,0x300c,0x3630,0x2616,0x482a,
0x3ba0,0x3ddc,0x38fa,0x3686,0x3956,0x372a,0x320c,0x3470,
0x3b6e,0x3512,0x3034,0x3648,0x3198,0x37e4,0x32c2,0x3cbe,
0x2852,0x3e4e,0x4b08,0x3514,0x4d84,0x3398,0x26de,0x30c2,
0x3e5c,0x4040,0x3506,0x231a,0x338a,0x2596,0x30d0,0x4ecc,
0x2ecc,0x4890,0x38d6,0x368a,0x38da,0x3686,0x46c0,0x209c,
0x4e02,0x205e,0x3018,0x3644,0x3014,0x3648,0x260e,0x4852,
0x3b40,0x3d7c,0x3aba,0x3486,0x39b6,0x378a,0x304c,0x3670,
0x38ee,0x36d2,0x3114,0x3728,0x3218,0x3424,0x33e2,0x3dde,
0x3dc0,0x3bbc,0x397a,0x3706,0x3cf6,0x328a,0x304c,0x3630,
0x38ae,0x36d2,0x3414,0x3268,0x3198,0x37e4,0x3522,0x3b5e,
0x2866,0x3e7a,0x3e7c,0x4060,0x4a90,0x348c,0x348a,0x2296,
0x4d08,0x3314,0x3312,0x250e,0x27fe,0x31e2,0x31e4,0x4ff8,
0x3ae0,0x3cbc,0x39ba,0x37e6,0x3bd6,0x358a,0x308c,0x36d0,
0x394e,0x3712,0x3214,0x3448,0x3078,0x3624,0x3322,0x3d7e,
0x3d60,0x3b5c,0x39da,0x37e6,0x38b6,0x368a,0x340c,0x3230,
0x3dae,0x3392,0x3114,0x3728,0x3078,0x3644,0x34c2,0x3afe,
0x2ff8,0x4984,0x4e02,0x207e,0x39ee,0x3792,0x3014,0x3668,
0x39f6,0x378a,0x300c,0x3670,0x47e0,0x219c,0x261a,0x4866,
0x2000,0x4000,0x4000,0x3800,0x4000,0x3800,0x3800,0x3800,
0x4000,0x3800,0x3800,0x3800,0x3800,0x3800,0x3800,0x4000,
0x401e,0x305e,0x355e,0x3d1e,0x33de,0x3b9e,0x3e9e,0x4ede,
0x36de,0x3e9e,0x3b9e,0x4bde,0x3d1e,0x4d5e,0x485e,0x201e,
0x401e,0x303e,0x32be,0x3a9e,0x373e,0x3f1e,0x3d9e,0x4dbe,
0x35be,0x3d9e,0x3f1e,0x4f3e,0x3a9e,0x4abe,0x483e,0x201e,
0x401e,0x307e,0x37fe,0x3f9e,0x34fe,0x3c9e,0x3b1e,0x4b7e,
0x337e,0x3b1e,0x3c9e,0x4cfe,0x3f9e,0x4ffe,0x487e,0x201e,
0x401c,0x201c,0x355c,0x4d5c,0x373c,0x4f3c,0x3a7c,0x3a7c,
0x337c,0x4b7c,0x3e3c,0x3e3c,0x3c5c,0x3c5c,0x491c,0x311c,
0x441a,0x345a,0x241a,0x4c5a,0x30fa,0x38ba,0x48fa,0x38ba,
0x31ba,0x39fa,0x49ba,0x39fa,0x3d5a,0x4d1a,0x3d5a,0x351a,
0x4616,0x3636,0x31f6,0x39d6,0x2616,0x4e36,0x49f6,0x39d6,
0x30d6,0x38f6,0x3f36,0x4f16,0x48d6,0x38f6,0x3f36,0x3716,
0x420e,0x326e,0x30ae,0x38ce,0x31ce,0x39ae,0x3b6e,0x4b0e,
0x220e,0x4a6e,0x48ae,0x38ce,0x49ce,0x39ae,0x3b6e,0x330e,
0x401c,0x201c,0x32bc,0x4abc,0x34fc,0x4cfc,0x3e5c,0x3e5c,
0x36dc,0x4edc,0x3c7c,0x3c7c,0x3a3c,0x3a3c,0x489c,0x309c,
0x460e,0x364e,0x31ee,0x39ae,0x312e,0x396e,0x3ece,0x4e8e,
0x260e,0x4e4e,0x49ee,0x39ae,0x492e,0x396e,0x3ece,0x368e,
0x421a,0x323a,0x221a,0x4a3a,0x31da,0x39fa,0x49da,0x39fa,
0x317a,0x395a,0x497a,0x395a,0x3aba,0x4a9a,0x3aba,0x329a,
0x4416,0x3476,0x3156,0x3936,0x2416,0x4c76,0x4956,0x3936,
0x31b6,0x39d6,0x3cf6,0x4c96,0x49b6,0x39d6,0x3cf6,0x3496,
0x401c,0x201c,0x37fc,0x4ffc,0x33dc,0x4bdc,0x3c3c,0x3c3c,
0x35bc,0x4dbc,0x3a5c,0x3a5c,0x3e7c,0x3e7c,0x499c,0x319c,
0x4216,0x3256,0x30b6,0x38f6,0x2216,0x4a56,0x48b6,0x38f6,
0x3176,0x3936,0x3bd6,0x4b96,0x4976,0x3936,0x3bd6,0x3396,
0x440e,0x342e,0x314e,0x396e,0x30ee,0x38ce,0x3dae,0x4d8e,
0x240e,0x4c2e,0x494e,0x396e,0x48ee,0x38ce,0x3dae,0x358e,
0x461a,0x367a,0x261a,0x4e7a,0x313a,0x395a,0x493a,0x395a,
0x30da,0x38ba,0x48da,0x38ba,0x3ffa,0x4f9a,0x3ffa,0x379a,
0x3c02,0x2802,0x3d42,0x3142,0x3ce2,0x30e2,0x25a2,0x31a2,
0x3da2,0x31a2,0x24e2,0x30e2,0x2542,0x3142,0x4402,0x2802,
0x3d04,0x3944,0x2904,0x3544,0x3e24,0x2264,0x3224,0x3664,
0x3a64,0x2624,0x3664,0x3224,0x2144,0x4504,0x3544,0x2904,
0x3d90,0x39b0,0x3e70,0x2250,0x3a50,0x2670,0x21b0,0x4590,
0x2990,0x35b0,0x3270,0x3650,0x3650,0x3270,0x35b0,0x2990,
0x3c88,0x38e8,0x3a28,0x2648,0x2888,0x34e8,0x3628,0x3248,
0x3e48,0x2228,0x20e8,0x4488,0x3248,0x3628,0x34e8,0x2888,
0x3c46,0x2846,0x2846,0x4446,0x3b86,0x3786,0x3786,0x2386,
0x3e86,0x3286,0x3286,0x2686,0x2146,0x3546,0x3546,0x3946,
0x3958,0x3d18,0x3818,0x2458,0x2d58,0x3118,0x3418,0x3058,
0x2d58,0x3118,0x3418,0x3058,0x4158,0x2518,0x2018,0x3c58,
0x4bc0,0x2fe0,0x2d60,0x3140,0x2b20,0x3700,0x3580,0x31a0,
0x2ca0,0x3080,0x3200,0x3620,0x3440,0x3060,0x32e0,0x2ec0,
0x4ec0,0x2aa0,0x2d20,0x3140,0x2de0,0x3180,0x3600,0x3260,
0x2f60,0x3300,0x3480,0x30e0,0x3440,0x3020,0x37a0,0x2bc0,
0x3c6a,0x286a,0x3f8a,0x338a,0x286a,0x446a,0x338a,0x278a,
0x3b0a,0x370a,0x20ea,0x34ea,0x370a,0x230a,0x34ea,0x38ea,
0x4b60,0x2f20,0x2dc0,0x3180,0x2ca0,0x30e0,0x3200,0x3640,
0x2ac0,0x3680,0x3460,0x3020,0x3500,0x3140,0x33a0,0x2fe0,
0x4fe0,0x2bc0,0x2ea0,0x3280,0x2cc0,0x30e0,0x3580,0x31a0,
0x2d20,0x3100,0x3460,0x3040,0x3600,0x3220,0x3740,0x2b60,
0x38f4,0x3c94,0x2cf4,0x3094,0x3814,0x2474,0x3414,0x3074,
0x2cf4,0x3094,0x40f4,0x2494,0x3414,0x3074,0x2014,0x3c74,
0x3c32,0x2832,0x3a92,0x3692,0x3f12,0x3312,0x21b2,0x35b2,
0x2832,0x4432,0x3692,0x2292,0x3312,0x2712,0x35b2,0x39b2,
0x4f20,0x2b60,0x2cc0,0x3080,0x2fc0,0x3380,0x3420,0x3060,
0x2de0,0x31a0,0x3600,0x3240,0x3500,0x3140,0x36e0,0x2aa0,
0x39ac,0x3d8c,0x2dac,0x318c,0x2dac,0x318c,0x41ac,0x258c,
0x380c,0x242c,0x340c,0x302c,0x340c,0x302c,0x200c,0x3c2c,
0x4aa0,0x2ec0,0x2be0,0x3780,0x2d60,0x3100,0x3420,0x3040,
0x2dc0,0x31a0,0x3480,0x30e0,0x3200,0x3660,0x3340,0x2f20,
0x3a02,0x2802,0x3aa2,0x30a2,0x3bc2,0x31c2,0x2362,0x3162,
0x3b62,0x3162,0x23c2,0x31c2,0x22a2,0x30a2,0x4202,0x2802,
0x3b88,0x39c8,0x3e68,0x2428,0x2988,0x33c8,0x3468,0x3628,
0x3c28,0x2668,0x21c8,0x4388,0x3628,0x3468,0x33c8,0x2988,
0x3a84,0x38a4,0x2884,0x32a4,0x3c64,0x2644,0x3664,0x3444,
0x3e44,0x2464,0x3444,0x3664,0x20a4,0x4284,0x32a4,0x2884,
0x3b10,0x3970,0x3c50,0x2630,0x3e30,0x2450,0x2170,0x4310,
0x2910,0x3370,0x3650,0x3430,0x3430,0x3650,0x3370,0x2910,
0x3a72,0x2872,0x3f92,0x3592,0x3c92,0x3692,0x2172,0x3372,
0x2872,0x4272,0x3592,0x2792,0x3692,0x2492,0x3372,0x3972,
0x4fe0,0x2da0,0x2f40,0x3500,0x2ac0,0x3080,0x3260,0x3020,
0x2b20,0x3160,0x3380,0x31c0,0x3600,0x3440,0x36a0,0x2ce0,
0x4ce0,0x2ec0,0x2ba0,0x3180,0x2d20,0x3700,0x3260,0x3040,
0x2b40,0x3160,0x3400,0x3620,0x3280,0x30a0,0x35c0,0x2fe0,
0x396c,0x3b0c,0x2b6c,0x310c,0x2b6c,0x310c,0x416c,0x230c,
0x380c,0x226c,0x320c,0x306c,0x320c,0x306c,0x200c,0x3a6c,
0x3a26,0x2826,0x2826,0x4226,0x3f06,0x3506,0x3506,0x2706,
0x3d86,0x3786,0x3786,0x2586,0x20a6,0x32a6,0x32a6,0x38a6,
0x4da0,0x2fe0,0x2ae0,0x30a0,0x2b40,0x3100,0x3400,0x3640,
0x2cc0,0x3680,0x3380,0x31c0,0x3220,0x3060,0x3560,0x2f20,
0x38b8,0x3a98,0x3818,0x2238,0x2ab8,0x3098,0x3218,0x3038,
0x2ab8,0x3098,0x3218,0x3038,0x40b8,0x2298,0x2018,0x3a38,
0x4f20,0x2d40,0x2ac0,0x30a0,0x2ee0,0x3480,0x3300,0x3160,
0x2be0,0x3180,0x3600,0x3460,0x3220,0x3040,0x37c0,0x2da0,
0x3a4a,0x284a,0x3d0a,0x370a,0x284a,0x424a,0x370a,0x250a,
0x3e8a,0x348a,0x21ca,0x33ca,0x348a,0x268a,0x33ca,0x39ca,
0x39d4,0x3b94,0x2bd4,0x3194,0x3814,0x2254,0x3214,0x3054,
0x2bd4,0x3194,0x41d4,0x2394,0x3214,0x3054,0x2014,0x3a54,
0x4ec0,0x2ce0,0x2b20,0x3100,0x2be0,0x31c0,0x3600,0x3420,
0x2fa0,0x3580,0x3240,0x3060,0x3280,0x30a0,0x3760,0x2d40,
0x4d40,0x2f20,0x2de0,0x3780,0x2ba0,0x31c0,0x3300,0x3160,
0x2ae0,0x3080,0x3240,0x3020,0x3400,0x3660,0x34a0,0x2ec0,
0x3e02,0x2802,0x3fe2,0x31e2,0x3f22,0x3122,0x26c2,0x30c2,
0x3ec2,0x30c2,0x2722,0x3122,0x27e2,0x31e2,0x4602,0x2802,
0x3e90,0x38d0,0x3a30,0x2470,0x3c70,0x2230,0x20d0,0x4690,
0x2890,0x36d0,0x3430,0x3270,0x3270,0x3430,0x36d0,0x2890,
0x3f08,0x3928,0x3c48,0x2268,0x2908,0x3728,0x3248,0x3468,
0x3a68,0x2448,0x2128,0x4708,0x3468,0x3248,0x3728,0x2908,
0x3f84,0x39e4,0x2984,0x37e4,0x3a44,0x2424,0x3444,0x3224,
0x3c24,0x2244,0x3224,0x3444,0x21e4,0x4784,0x37e4,0x2984,
0x3e2a,0x282a,0x3a8a,0x348a,0x282a,0x462a,0x348a,0x228a,
0x3d8a,0x338a,0x212a,0x372a,0x338a,0x258a,0x372a,0x392a,
0x4aa0,0x2ce0,0x2b40,0x3500,0x2f60,0x3120,0x3680,0x30c0,
0x2fc0,0x3180,0x3620,0x3060,0x3200,0x3440,0x33e0,0x2da0,
0x3934,0x3f14,0x2f34,0x3114,0x3814,0x2634,0x3614,0x3034,
0x2f34,0x3114,0x4134,0x2714,0x3614,0x3034,0x2014,0x3e34,
0x4da0,0x2bc0,0x2ee0,0x3080,0x2f40,0x3120,0x3400,0x3260,
0x2d60,0x3300,0x3620,0x3040,0x3780,0x31e0,0x34c0,0x2aa0,
0x3e52,0x2852,0x3d12,0x3312,0x3b92,0x3592,0x20d2,0x36d2,
0x2852,0x4652,0x3312,0x2512,0x3592,0x2392,0x36d2,0x38d2,
0x38cc,0x3e8c,0x2ecc,0x308c,0x2ecc,0x308c,0x40cc,0x268c,
0x380c,0x264c,0x360c,0x304c,0x360c,0x304c,0x200c,0x3e4c,
0x4d40,0x2b60,0x2ca0,0x3280,0x2fa0,0x3180,0x3640,0x3060,
0x2ee0,0x30c0,0x3700,0x3120,0x3400,0x3220,0x35e0,0x2bc0,
0x4bc0,0x2da0,0x2f60,0x3100,0x2ae0,0x3480,0x3640,0x3020,
0x2ea0,0x30c0,0x3200,0x3460,0x3780,0x31e0,0x3320,0x2d40,
0x3e66,0x2866,0x2866,0x4666,0x3c86,0x3286,0x3286,0x2486,
0x3b06,0x3506,0x3506,0x2306,0x21e6,0x37e6,0x37e6,0x39e6,
0x4ce0,0x2aa0,0x2fa0,0x31e0,0x2dc0,0x3380,0x3680,0x30c0,
0x2f40,0x3100,0x3400,0x3240,0x3660,0x3020,0x3520,0x2b60,
0x4b60,0x2d40,0x2fc0,0x31e0,0x2ea0,0x3080,0x3200,0x3420,
0x2ba0,0x3580,0x3700,0x3120,0x3660,0x3040,0x32c0,0x2ce0,
0x39f8,0x3f98,0x3818,0x2678,0x2ff8,0x3198,0x3618,0x3078,
0x2ff8,0x3198,0x3618,0x3078,0x41f8,0x2798,0x2018,0x3e78
};


// %%EXPORT p
MAT24_API
uint32_t mat24_vect_to_vintern(uint32_t v1)
// Convert bit vector v1 in GF(2)^24 from vector to vintern rep.
{
    return  MAT24_ENC_TABLE0[v1 & 0xff]
          ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
}

// %%EXPORT p
MAT24_API
uint32_t mat24_vintern_to_vect(uint32_t v1)
// Convert bit vector v1 in GF(2)^24 from vintern to vector rep.
{
    return  MAT24_DEC_TABLE0[v1 & 0xff]
           ^ MAT24_DEC_TABLE1[(v1 >> 8) & 0xff]
           ^ MAT24_DEC_TABLE2[(v1 >> 16) & 0xff];
}

// %%EXPORT p
MAT24_API
uint32_t mat24_vect_to_cocode(uint32_t v1)
// Return number of Golay cocode element for a vector v1 in GF(2)^24
{
    return  (MAT24_ENC_TABLE0[v1 & 0xff]
          ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff]) & 0xfff;
}

// %%EXPORT p
MAT24_API
uint32_t mat24_gcode_to_vect(uint32_t v1)
// Convert Golay code element number v1 to a vector in GF(2)^24
{
    return  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff];
}

// %%EXPORT p
MAT24_API
uint32_t mat24_cocode_to_vect(uint32_t c1)
// Return vector in GF(2)^24 corresponding to cocode element number 
// c1. One of 2**12 possible vectors with this property is returned.
{
    return mat24_vintern_to_vect(c1);
}

// %%EXPORT p
MAT24_API
uint32_t mat24_vect_to_gcode(uint32_t v1)
// Return gcode(v1) if v1 is a Golay code word and (uint32_t)(-1) 
// otherwise.
// Here 0 <= gcode(v1) < 4096 is the number of a Golay code word.
{
    uint_fast32_t  cn =  mat24_vect_to_vintern(v1);
    return cn & 0xfff ? (uint32_t)(-1)   : cn >> 12;
}




// %%EXPORT p
MAT24_API
uint32_t mat24_gcode_to_octad(uint32_t v1)
// Return octad(v1) if v1 is an octad and (uint32_t)(-1) otherwise.
// Here 0 <= v1 < 4096 is the number of a Golay code element
// and 0 <= octad(v1) < 759 is the number of an octad. 
{
    uint_fast32_t y;
    v1 &= 0xfff;
    y = MAT24_OCT_ENC_TABLE[v1 >> 1];
    if (((y ^ (v1 & 1)) + 2) & 0x101) return  (uint32_t)(-1);
    return (y >> 1) + 3 * (v1 >> 4) - 11;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_vect_to_octad(uint32_t v1)
// Return octad(v1) if v1 is an octad and (uint32_t)(-1) otherwise.
// Here v1 is a vector in GF(2)**24 and
// 0 <= octad(v1) < 759 is the number of an octad. 
{
    uint_fast32_t y, err;
    err = MAT24_ENC_TABLE0[v1 & 0xff]
             ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
             ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
    v1 = err >> 12;
    err &= 0xfff;
    y = MAT24_OCT_ENC_TABLE[v1 >> 1];
    err |=  (((y ^ (v1 & 1)) + 2) & 0x101);
    if (err) return  (uint32_t)(-1);
    return (y >> 1) + 3 * (v1 >> 4) - 11;
}

// %%EXPORT p
MAT24_API
uint32_t mat24_octad_to_gcode(uint32_t u_octad)
// Return number of Golay code word corresponding to octad u_octad.
// Return (uint32_t)(-1) if not 0 <= v1 < 759.
{   
    return u_octad < 759 ? MAT24_OCT_DEC_TABLE[u_octad] & 0xfff 
                         : (uint32_t)(-1);
}

// %%EXPORT p
MAT24_API
uint32_t mat24_octad_to_vect(uint32_t u_octad)
// Return vector in GF(2)**24 corresponding to octad u_octad.
// Return (uint32_t)(-1) if not 0 <= u_octad < 759.
{
    uint_fast32_t u;
    if (u_octad >= 759) return (uint32_t)(-1);
    u = MAT24_OCT_DEC_TABLE[u_octad] & 0xfff;
    return  MAT24_DEC_TABLE1[(u << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(u >> 4) & 0xff];
}


// %%COMMENT
/*************************************************************************
*** Golay code syndoms and weights
*************************************************************************/


// %%EXPORT p
MAT24_API
uint32_t mat24_cocode_syndrome(uint32_t c1, uint32_t u_tetrad)
// Same as mat24_syndrome(mat24_cocode_to_vect(c1), u_tetrad).  
{
        uint_fast32_t  y, syn, bad; 
        if (u_tetrad > 24) return (uint32_t)(-1L);
        bad = (u_tetrad + 8) >> 5;       // bad = (u_tetrad >= 24)
        u_tetrad -= bad;                 // change 24 to 23
        y = - ((c1 + 1) & 1);            // y = 0 if c1 is odd else -1
        bad &= y;                        // bad  &= (weight(c1) even)
        c1 ^= MAT24_RECIP_BASIS[u_tetrad & 31] & y;
            // if even: flip bit 'u_tetrad' in cocode repr. 'c1'
        y  &=  1 << u_tetrad;            // y = 1 << u_tetrad if even
        syn = MAT24_SYNDROME_TABLE[ (c1 >> 1) & 0x7ff ];
        syn = (1 << (syn & 31)) | (1 << ((syn >> 5) & 31))   
                               | (1 << ((syn >> 10) & 31));
        // Now syn is the syndrome of the odd word c1. Thus syn has
        // odd parity. Bit 24 of syn is set if weight(syn) == 1.
        bad &= ((syn & (y | 0x1000000)) - 1) >> 25; 
            // bad &= weight(syn) > 1 and y & syn == 0
        syn ^= y;                        // the final syndrome
        return (syn & 0xffffff) | -(bad & 1);
            // clear high bits, return syndrome of ok, else -1
}



// %%EXPORT p
MAT24_API
uint32_t mat24_syndrome(uint32_t v1, uint32_t u_tetrad)
// Return Golay code syndrome of word 'v1'.
//
// Here 'v1' is an arbitrary word in GF(2)**24. The function 
// returns a Golay code syndrome of v1 of length at most four.
// That syndrome is unique if it has langth < 4. If the syndrome
// has length four then we return the following value:
//  - A sydnrome with bit 'u_tetrad' set if  0 <= u_tetrad < 24, 
//  - The value uint32_t(-1)  if  'u_tetrad' == 24.
// It is illegal to put 'u_tetrad' >= 24.
{
        uint_fast32_t as_cocode;

        as_cocode = MAT24_ENC_TABLE0[v1 & 0xff]
                  ^ MAT24_ENC_TABLE1[(v1 >> 8) & 0xff]
                  ^ MAT24_ENC_TABLE2[(v1 >> 16) & 0xff];
                  // This is  mat24_vect_to_vintern(v1)
        return  mat24_cocode_syndrome(as_cocode, u_tetrad);
}




// %%EXPORT p
MAT24_API
uint32_t mat24_gcode_weight(uint32_t v1)
// returns bit weight of Golay code word v1 divided by 4
//
// Here 0 <= v1 < 4096 is the number of a Golay code word.
{
   register uint_fast32_t  t = - (v1 & 1);
   return (((MAT24_THETA_TABLE[(v1 & 0xfff) >> 1] >> 12) & 7) ^ t) 
                 + (t & 7);  
}



// %%EXPORT p
MAT24_API
uint32_t mat24_cocode_weight(uint32_t c1)
// Return minimum possible weight of cocode vector c1.  
//
// Here c1 is a cocode vector in cocode representation.

{
        uint_fast32_t  y, syn, w; 
        y = - ((c1 + 1) & 1);            // y = 0 if c1 is odd else -1
        c1 ^= MAT24_RECIP_BASIS[0] & y;
            // if even: flip bit 0 in cocode repr. 'c1'
        syn = MAT24_SYNDROME_TABLE[ (c1 >> 1) & 0x7ff ];
        w = 3 - (((syn + 0x2000) >> 15) << 1);
           // weight of odd syndrome (syn >= 0x6000 iff weight == 1)
        w -= y;                         // weight of complete syndrome
        y &= (((syn & 31) - 1) >> 5) & 1;
           // y = 1 if bit 0 has been counted twice in syndrome
           // (syn & 31 == 0 iff bit 0 is set in syndrome)
        w -= y << 1;                    // correct if counted twice 
        return w;
}


// %%COMMENT
/*************************************************************************
*** Scalar product of Golay code and cocode
*************************************************************************/


// %%EXPORT p
MAT24_API
uint32_t mat24_scalar_prod(uint32_t v1, uint32_t c1)
// Return scalar product (v1,c1) of Golay code and cocode vector
//
// v1 is a Golay code vector in 'gcode' representation, c1 is a
// cocode vector in cocode representation.
{
    v1 &= c1;
    v1 ^= v1 >> 6;  v1 ^= v1 >> 3;
    return (0x96 >> (v1 & 7)) & 1;
}



// %%COMMENT
/*************************************************************************
*** Conversion from and to suboctads
*************************************************************************/

// %%EXPORT p
MAT24_API
uint32_t mat24_suboctad_to_cocode(uint32_t u_sub, uint32_t v1)
// Convert even suboctad u_sub of octad v1 to cocode representation
//
// Each octad v1 has 64 even subsets, when a subset x of v1 is identified
// with its complement v1 \ x. These subsets are called suboctads.
// Let b_0,...,b_7 be the elements of the octad v1 in natural order. 
// Then the even subset (b_0 , b_i)  has suboctad number 2**(i-1) for 
// i = 1,...,6. Combining suboctads by disjoint union corresponds to 
// combining their numbers by xor. The empty subocatad has number 0.
// This yields a 1:1 correspondence between the integers 0,...,63 and
// the suboctads of a fixed octad v1, when identifying a suboctad with
// its complement. 
//
// The function returns the suboctad of v1 with number u_sub in 'cocode'
// representation. Octad v1 must be given in 'gcode' representation. The 
// function returns (uint32_t)(-1) if v1 does not represent an octad.
{
    // Let oct = vector of v1 in 'vect' representation
    uint_fast32_t oct =  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
                       ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff]; 
    // Abort if w = gcode_to_vect(v1) is not an octad. 
    uint_fast32_t l = (MAT24_THETA_TABLE[(v1 & 0xfff) >> 1] >> 12) & 7;
        // Now l =  weight(w0)/4,  w = w0 + w1,  w1 = Omega * (v1 & 1)
    if (l != 2 << (v1 & 1)) return (uint32_t)(-1);
    // Put l = parity of u_sub
    l =  (0x96 >> ((u_sub ^ (u_sub >> 3)) & 7)) & 1;  
    // Let u_sub be a vector representing the suboctad of w with No u_sub
    u_sub = l + ((u_sub & 0x3f) << 1); 
    u_sub = mat24_spread_b24(u_sub, oct);
    // Finally, convert that vector to cocode representation
    return  (MAT24_ENC_TABLE0[u_sub & 0xff]
          ^ MAT24_ENC_TABLE1[(u_sub >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(u_sub >> 16) & 0xff]) & 0xfff;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_cocode_to_suboctad(uint32_t c1, uint32_t v1)
// Convert cocode element c1 to suboctad of octad v1.
//
// This is an inverse of function mat24_suboctad_to_cocode().
// The function returns the suboctad number corresponding to the
// cocode element c1, if v1 is an octad and c1 is an even subset 
// of v1. c1 and v1 must be given in 'cocode' and 'gcode'
// representation, respectively. The function returns (uint32_t)(-1)
// if v1 is not an octad or c1 cannot be represented as an even
// subset of v1.
{
    // Let oct = vector of v1 in 'vect' representation
    uint_fast32_t syn, oct =  MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
                       ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff]; 
    // Abort if w = gcode_to_vect(v1) is not an octad. 
    uint_fast32_t l = (MAT24_THETA_TABLE[(v1 & 0xfff) >> 1] >> 12) & 7;
        // Now l =  weight(w0)/4,  w = w0 + w1,  w1 = Omega * (v1 & 1)
    if (l != 2 << (v1 & 1)) return (uint32_t)(-1);
    // Abort if c1 is not even
    if (c1 & 1) return (uint32_t)(-1);
    // l = lsbit of oct
    l = mat24_def_lsbit24(oct);
    // compute syndrome of (odd) vector w ^ 2**l, w = gcode_to_vect(v1)
    c1 ^= MAT24_RECIP_BASIS[l];
    syn = MAT24_SYNDROME_TABLE[ (c1 >> 1) & 0x7ff ];
    syn = (1 << (syn & 31)) ^ (1 << ((syn>>5) & 31))   
                               ^ (1 << ((syn>>10) & 31));
    // Abort if syndrome is not a sbset of the octad oct
    if ((syn & oct) != syn) return (uint32_t)(-1);
    // compress syndrome to suboctad number
    syn = mat24_extract_b24(syn, oct) >> 1;
    // complement suboctad number if highest bit is set
    l = (syn >> 6) & 1;
    return (syn ^ (-l)) & 0x3f;
}    


// %%EXPORT p
MAT24_API
uint32_t mat24_suboctad_weight(uint32_t u_sub)
// Return parity of halved bit weight ofthe even suboctad u_sub
//    
// See member function mat24_suboctad_to_cocode for documentation of 
// suboctads. The function returns 0 is the bit weight of a suboctad 
// with number u_sub is divisible by four and 1 othewise.
{
   uint_fast32_t w = (u_sub & 0x15) + ((u_sub & 0x2a) >> 1);
   w = w + (w >> 2) + (w >> 4) + 1;
   return (w >> 1) & 1; 
}

// %%EXPORT p
MAT24_API
uint32_t mat24_suboctad_scalar_prod(uint32_t u_sub1, uint32_t u_sub2)
// Return scalar product of suboctads u_sub1, u_sub2
//    
// Here the scalar product is the parity of the vector  u_sub1 & u_sub2 
// when u_sub1 and u_sub2 are given as subsets of an octad in vector 
// notation.
//
// But in this functions parameters u_sub1, u_sub2 are suboctad 
// numbers as described in function suboctad_to_cocode.
{
   uint_fast32_t wp = (0x96 >> ((u_sub1 ^ (u_sub1 >> 3)) & 7)) 
                    & (0x96 >> ((u_sub2 ^ (u_sub2 >> 3)) & 7));
   u_sub1 &= u_sub2;
   wp ^= (0x96 >> ((u_sub1 ^ (u_sub1 >> 3)) & 7));
   return wp & 1;
}


// %%COMMENT
/*************************************************************************
*** Parker Loop
*************************************************************************/

// %%EXPORT p
MAT24_API
uint32_t mat24_ploop_theta(uint32_t v1)
// returns the theta function for the Parker loop as given in [SPLG]:
//
// theta is a quadratic from from the Golay code C to the cocode C*.
// Here parameter v1 of function theta is represented as a Golay code 
// word. The result of the function is represented as a Golay cocode 
// word. The cocycle of the Parker loop is given by:
//
//          cocycle(v1,v2) =   scalar_prod(theta(v1), v2)
//        
// with  scalar_prod(.,.) the scalar product.
{
   return MAT24_THETA_TABLE[(v1 >> 1) & 0x7ff] & 0xfff;
}

// %%EXPORT p
MAT24_API
uint32_t mat24_ploop_cocycle(uint32_t v1, uint32_t v2)
// Returns the cocycle of the Parker loop.
//
// Then the Parker Loop product is given by
//
//      v1 (*) v2  =  v1 ^ v2 * (-1)**cocycle(v1, v2) . 
{
    uint_fast32_t s;
    s = MAT24_THETA_TABLE[(v1 >> 1) & 0x7ff] & v2 & 0xfff;
    s ^= s >> 6;
    s ^= s >> 3;
    s = 0x96 >> (s & 7);
    return s & 1; 
}


// %%EXPORT p
MAT24_API
uint32_t mat24_mul_ploop(uint32_t v1, uint32_t v2)
// Returns the Parker loop product v1 (*) v2
//
// Here v1 and v2 are integers coded as follows:
// bit 0,...,11:   representation as Golay code word
// bit 12:         Parker loop sign
// otther bits:    ignored
{

   return v1 ^ v2 ^ (mat24_ploop_cocycle(v1, v2) << 12);
}


// %%EXPORT p
MAT24_API
uint32_t mat24_pow_ploop(uint32_t v1, uint32_t u_exp)
// Return power v1 ** u_exp of the Parker loop element v1
//
// Here mat24_pow_ploop(v1, 3) is the inverse of v1.
{
    return (v1 & -(u_exp & 1)) 
      ^ (MAT24_THETA_TABLE[(v1 >> 1) & 0x7ff] & ((u_exp & 2) << 11));
}


// %%EXPORT p
MAT24_API
uint32_t mat24_ploop_comm(uint32_t v1, uint32_t v2)
// Return commutator of Golay code word v1 and v2
//
// This is 0 if the intersection of the vectors v1 and v2 has
// bit weight 0 mod 4 and 1 is that intersection has bit weight 
// 2 mod 4. v1 and v2 are in 'gvect' or 'ploop' representation.
{   
    uint_fast32_t r;
    r = (MAT24_THETA_TABLE[(v1 >> 1) & 0x7ff] & v2)
      ^ (MAT24_THETA_TABLE[(v2 >> 1) & 0x7ff] & v1);
    r ^= r >> 6; r ^= r >> 3;
    return (0x96 >> (r & 7)) & 1;      
} 


// %%EXPORT p
MAT24_API
uint32_t mat24_ploop_cap(uint32_t v1, uint32_t v2)
// Return intersection of two Golay code words as cocode word.
//
// v1 and v2 are in 'gvect' or 'ploop' representation, the result
// is returned in 'cocode' representation.
{
    v1 = (v1 >> 1) & 0x7ff; v2 = (v2 >> 1) & 0x7ff;
    return (MAT24_THETA_TABLE[v1]  ^  MAT24_THETA_TABLE[v2] 
              ^ MAT24_THETA_TABLE[v1 ^ v2]) & 0xffe ;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_ploop_assoc(uint32_t v1, uint32_t v2, uint32_t v3)
// Return associator of Golay code words v1, v2 and v3
//
// This the parity of the intersection of the vectors v1, v2 and 
// v3.  v1, v2 and v3 are in 'gvect' or 'ploop' representation.
{
    uint_fast32_t r;
    r = (MAT24_THETA_TABLE[(v1 >> 1) & 0x7ff] & v3)
      ^ (MAT24_THETA_TABLE[(v2 >> 1) & 0x7ff] & v3)
      ^ (MAT24_THETA_TABLE[((v1 ^ v2) >> 1) & 0x7ff] & v3);
    r ^= r >> 6; r ^= r >> 3;
    return (0x96 >> (r & 7)) & 1;      
}


// %%COMMENT
/*************************************************************************
*** Mathieu group Mat24
*************************************************************************/



#define heptad_encode(x) \
         x = MAT24_ENC_TABLE0[(x) & 0xff] \
           ^ MAT24_ENC_TABLE1[((x) >> 8) & 0xff]  \
           ^ MAT24_ENC_TABLE2[((x) >> 16) & 0xff];

#define heptad_syndrome(x)    \
     x = MAT24_SYNDROME_TABLE[((x) >> 1) & 0x7ff]; \
      x = (1 << ((x) & 31)) ^ (1 << (((x) >> 5) & 31))  \
              ^ (1 << (((x) >> 10) & 31));




// %%EXPORT p
MAT24_API
uint32_t mat24_perm_complete_heptad(uint8_t *p_io)
// Complete a permutation p given by p_io to an element of  Mat24.
//
// p must have length 24. Entries p[i], i = 0,1,2,3,4,5,8 must make 
// up a valid umbral heptad, i.e. a heptad not contained in an octad.
// p[0],...,p[5] must be contained in an octad, p[8] must not be 
// contained in that octad. The other entries of input p are ignored.
//
// It can be shown that such a permutation p can be completed to 
// a unique element of Mat24.
//
// The function returns 0 in case of success and a nonzero value
// otherwise. In case of success, p is completed to an element of
// the Mathieu group Mat24. 
{
   uint_fast32_t st, err, t;
   uint_fast32_t r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;

   // We complete a permutation p in Mat24 from p[i], i = 0,1,2,3,4,5,8.
   // These p[i] must make up a valid umbral heptad, i.e. a heptad not
   // contained in an octad. p[0],...,p[5] must be contained in an octad.
   // At the end we'll have err = 0 iff the completion has succeded. 

   // Compute the heptad  obtained from the inputs in st
   st = (1 << p_io[8]) | (1 << p_io[0]) | (1 << p_io[1]) | (1 << p_io[2]) 
      | (1 << p_io[3]) | (1 << p_io[4]) | (1 << p_io[5]);

   // %%FOR i, j1, j2 in Mat24_heptad_index_table
   // Compute a pentad in r0 from st and the inputs
   r0 = st ^ (1 <<  p_io[1]) ^ (1 <<  p_io[0]);
   // Compute the syndrome of that pentad in r0
   heptad_encode(r0);
   heptad_syndrome(r0);
   // Compute a pentad in r1 from st and the inputs
   r1 = st ^ (1 <<  p_io[2]) ^ (1 <<  p_io[0]);
   // Compute the syndrome of that pentad in r1
   heptad_encode(r1);
   heptad_syndrome(r1);
   // Compute a pentad in r2 from st and the inputs
   r2 = st ^ (1 <<  p_io[2]) ^ (1 <<  p_io[1]);
   // Compute the syndrome of that pentad in r2
   heptad_encode(r2);
   heptad_syndrome(r2);
   // Compute a pentad in r3 from st and the inputs
   r3 = st ^ (1 <<  p_io[3]) ^ (1 <<  p_io[0]);
   // Compute the syndrome of that pentad in r3
   heptad_encode(r3);
   heptad_syndrome(r3);
   // Compute a pentad in r4 from st and the inputs
   r4 = st ^ (1 <<  p_io[3]) ^ (1 <<  p_io[1]);
   // Compute the syndrome of that pentad in r4
   heptad_encode(r4);
   heptad_syndrome(r4);
   // Compute a pentad in r5 from st and the inputs
   r5 = st ^ (1 <<  p_io[3]) ^ (1 <<  p_io[2]);
   // Compute the syndrome of that pentad in r5
   heptad_encode(r5);
   heptad_syndrome(r5);
   // Compute a pentad in r6 from st and the inputs
   r6 = st ^ (1 <<  p_io[4]) ^ (1 <<  p_io[0]);
   // Compute the syndrome of that pentad in r6
   heptad_encode(r6);
   heptad_syndrome(r6);
   // Compute a pentad in r7 from st and the inputs
   r7 = st ^ (1 <<  p_io[4]) ^ (1 <<  p_io[1]);
   // Compute the syndrome of that pentad in r7
   heptad_encode(r7);
   heptad_syndrome(r7);
   // Compute a pentad in r8 from st and the inputs
   r8 = st ^ (1 <<  p_io[4]) ^ (1 <<  p_io[2]);
   // Compute the syndrome of that pentad in r8
   heptad_encode(r8);
   heptad_syndrome(r8);
   // Compute a pentad in r9 from st and the inputs
   r9 = st ^ (1 <<  p_io[4]) ^ (1 <<  p_io[3]);
   // Compute the syndrome of that pentad in r9
   heptad_encode(r9);
   heptad_syndrome(r9);
   // %%END FOR

   // Compute p_io[9,...,23] by intersecting pairs of r<i>, r<j> of syndromes.
   // %%FOR i, j1, j2 in Mat24_heptad_find_table
   t = r5 & r0;
   p_io[9] = mat24_def_lsbit24_pwr2(t); 
   t = r3 & r2;
   p_io[10] = mat24_def_lsbit24_pwr2(t); 
   t = r4 & r1;
   p_io[11] = mat24_def_lsbit24_pwr2(t); 
   t = r7 & r5;
   p_io[12] = mat24_def_lsbit24_pwr2(t); 
   t = r6 & r5;
   p_io[13] = mat24_def_lsbit24_pwr2(t); 
   t = r9 & r0;
   p_io[14] = mat24_def_lsbit24_pwr2(t); 
   t = r8 & r0;
   p_io[15] = mat24_def_lsbit24_pwr2(t); 
   t = r9 & r2;
   p_io[16] = mat24_def_lsbit24_pwr2(t); 
   t = r7 & r3;
   p_io[17] = mat24_def_lsbit24_pwr2(t); 
   t = r6 & r2;
   p_io[18] = mat24_def_lsbit24_pwr2(t); 
   t = r8 & r3;
   p_io[19] = mat24_def_lsbit24_pwr2(t); 
   t = r8 & r4;
   p_io[20] = mat24_def_lsbit24_pwr2(t); 
   t = r7 & r1;
   p_io[21] = mat24_def_lsbit24_pwr2(t); 
   t = r9 & r1;
   p_io[22] = mat24_def_lsbit24_pwr2(t); 
   t = r6 & r4;
   p_io[23] = mat24_def_lsbit24_pwr2(t); 
   // %%END FOR

   // Now it remains to compute  p_io[6] and  p_io[7].
   // Compute a syndrome containing p_io[6] but not p_io[7]
   r0 = (1 << p_io[5]) 
          ^ (1 << p_io[11])
          ^ r0;
   heptad_encode(r0);
   heptad_syndrome(r0);

   // Compute a syndrome containong ecactly  p_io[6] and p_io[7]
   r1 = st;
   heptad_encode(r1);
   err = (r1 & 1) ^ 1;    // error if st is not odd
   heptad_syndrome(r1);
   r1 ^=  (1 << p_io[8]); // should be (1 << p_io[6]) | (1 << p_io[7])
   
   // Compute  p_io[6] and p_io[7] from the last two syndromes
   r2 = r1 & r0;          //  should be  1 << p_io[6] 
   p_io[6] = mat24_def_lsbit24_pwr2(r2); 
   r2 = r1 & ~r0;         //  should be  1 << p_io[7]   
   p_io[7] = mat24_def_lsbit24_pwr2(r2); 
  
   // Put err = 0 if ok, err != 0 in case of any error
   err |= (uint_fast32_t)(-32) &
     (p_io[8] | p_io[0] | p_io[1] | p_io[2] | p_io[3] | p_io[4] | p_io[5]);
   err |= st & (0xff000000 | (1 << p_io[6]) | (1 << p_io[7]) | r1);
   err |= (r1 - 1) & 0xff000000;
   return err;
}

// %%EXPORT p
MAT24_API
uint32_t mat24_perm_check(uint8_t *p1)
// Check if permutation p1 is in in the Mathieu group Mat24.
//
// The function returns zero iff this is the case.
{
    uint8_t p2[24];
    memcpy(p2, p1, 9*sizeof(uint8_t));
    return mat24_perm_complete_heptad(p2) || memcmp(p1, p2, 24);
}        


// %%EXPORT p
MAT24_API
uint32_t mat24_perm_from_heptads(uint8_t *h1, uint8_t *h2, uint8_t *p_out)
// Try to find a permutation p that maps heptad h1 to h2
//
// h1 and h2 are arrays of length 7 defining two umbral heptads,
// i.e. heptads not contained in an octad. If a permutation p in
// the Mathieu group Mat24 that maps h1 to h2 exists, it is unique. 
//
// The function returns zero and stores p in the array referred by p
// if such a p has been found. It returns (uint32_t)(-1) otherwise.
{
    uint8_t p1[24], p2[24];
    uint_fast32_t v, y, i;
 
    // First find the special element of v h1 not contained in the octad
    v = 0;
    for (i = 0; i < 7; ++i)  v |= 1 << (h1[i] & 31);

    // Put y = mat24_syndrome(v).
    y = MAT24_ENC_TABLE0[v & 0xff]
           ^ MAT24_ENC_TABLE1[(v >> 8) & 0xff]
           ^ MAT24_ENC_TABLE2[(v >> 16) & 0xff];
    y = MAT24_SYNDROME_TABLE[(y >> 1) & 0x7ff];
    y = (1 << (y & 31)) ^ (1 << ((y >> 5) & 31)) 
                              ^ (1 << ((y >> 10) & 31));  
    
    // Put v = lsbit(v & y). Then v is the special element of h1
    v &= y; 
    v =  mat24_def_lsbit24(v); 
  
    // Find position y of element v in h1
    y = 0; 
    for (i = 0; i < 7; ++i)   y |= ((h1[i] != v) - 1) & i;

    // Copy special element of h1 to position 8 of p1 and copy the other
    // elements of h1 to positions 0,...,6. Copy h2 similarly to p2
    memcpy(p1, h1, 7*sizeof(uint8_t));
    memcpy(p2, h2, 7*sizeof(uint8_t));
    p1[8] = p1[y];   p1[y] = p1[6];
    p2[8] = p2[y];   p2[y] = p2[6];

    // Complete p1 and p2 from heptad. Return error if any completion fails
    if (mat24_perm_complete_heptad(p1)) return (uint32_t)(-1);
    if (mat24_perm_complete_heptad(p2)) return (uint32_t)(-1);

    //  If success, put p = p1**(-1) * p2
    for (i = 0; i < 24; ++i)  p_out[p1[i]] = p2[i];
    return 0;
}        



#define  STD_OCTAD 14


// %%EXPORT p
MAT24_API
uint32_t mat24_m24num_to_perm(uint32_t u_m24, uint8_t *p_out)
// Return permutation with number u_m24 in the Mathieu group Mat24.
//
// The inverse of this function is member function mat24_perm_to_int()
// This is just a short and convenient way to number elements of Mat24.
// Input u_m24 = 0 gives the identity permutation.
//
//  0 <= u_m24 < 244823040 = order(Mat24) must hold.
//
{
    uint_fast32_t oct, i, j, k = u_m24, k1;
    uint8_t p1[32];
  
    // Let k be the input u_m24
    // Integer 0 <= k < 244823040 is evaluated in mixed-radix with bases
    // 759, 8, 7, 6, 5, 4, 3, 16, with valence decreasing from left to right. 
    // In the sequel these digits of k are named:
    //
    //   oct  k_0  k_1  k_2  k_3  k_4  k_5   k'
    //   759   8    7    6    5    4    3    16 

    oct =  k/322560;            // number of image of standard octad 0..7   
    if (oct >= 759) return (uint32_t)(-1); // check if input k is correct 
    k -= 322560 * oct;  // remove digit 'oct' from input k
    oct -= 759 - STD_OCTAD;   // Manipulate oct so that input oct=0
    oct += (oct >> 12) & 759;   //   corresponds to the standard octad 
    oct = mat24_octad_to_vect(oct); // get bit vector for octad

    // p1[0..7]  will be the sorted entries of the octad oct.
    // p1[8..23] will be the sorted remaining entries. 
    // This trick is documented in function mat24_vect_to_bit_list.
    oct <<= 3; j = 0x8;
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = oct & 8;
        p1[(j >> o) & 0x1f] = i;
        j += 1 << o;
        oct >>= 1;
    }

    // Let p1[8] be the k'-th smallest entry outside octad  oct,
    // where 0 < k' < 16 is the lowest digit of k.
    p1[8] = p1[8 + (k & 15)]; 

    // Format k such that original k/8 is at bit positions 28..30 
    k >>= 4;
    k *= (1 << 28) / 2520 + 1;

    // For i = 0,...,5: exchange element at pos. i with element 
    //                 at pos i + k_i, where 0 <= k_i < 8 - i. 

    // %%FOR i in range(6)
    k1 = 0 + (k >> 28);  // this is k[0]
        j = p1[0];  p1[0] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 7;  // remove digit k_0 from k
    k1 = 1 + (k >> 28);  // this is k[1]
        j = p1[1];  p1[1] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 6;  // remove digit k_1 from k
    k1 = 2 + (k >> 28);  // this is k[2]
        j = p1[2];  p1[2] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 5;  // remove digit k_2 from k
    k1 = 3 + (k >> 28);  // this is k[3]
        j = p1[3];  p1[3] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 4;  // remove digit k_3 from k
    k1 = 4 + (k >> 28);  // this is k[4]
        j = p1[4];  p1[4] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 3;  // remove digit k_4 from k
    k1 = 5 + (k >> 28);  // this is k[5]
        j = p1[5];  p1[5] = p1[k1]; p1[k1] = j; 
        k = (k & 0xfffffff) * 2;  // remove digit k_5 from k
    // %%END FOR

    // Now entries at pos. 0,1,2,3,4,5,8 are valid. use
    // mat24_perm_complete_heptad() to compute the remaining entries
    mat24_perm_complete_heptad(p1);
    memcpy(p_out, p1, 24 * sizeof(uint8_t));
    return 0;
}






// %%EXPORT p
MAT24_API
uint32_t mat24_perm_to_m24num(uint8_t  *p1)
// Convert the permutation p1 in the Mathieu group mat24 to an integer.
//
// This reverses function mat24_int_to_perm. The result is undefined
// if p1 is not in Mat24.
{
    uint_fast32_t oct, i, j, res;
    uint_fast8_t p2[32], q[8], q_inv[8];

    // let oct be the octad formed by p1[0],...,p1[7]
    oct = (1 << p1[0]) | (1 << p1[1]) | (1 << p1[2]) | (1 << p1[3]) 
        | (1 << p1[4]) | (1 << p1[5]) | (1 << p1[6]) | (1 << p1[7]);

    // put res = mat24_vect_to_octad(oct)
    res = MAT24_ENC_TABLE0[oct & 0xff]
          ^ MAT24_ENC_TABLE1[(oct >> 8) & 0xff]
          ^ MAT24_ENC_TABLE2[(oct >> 16) & 0xff];
    res =  mat24_gcode_to_octad(res >> 12) & 0xfff;
    // put res = (res - STD_OCTAD) mod 759
    res -=  STD_OCTAD;
    res += (res >> 12) & 759;

    oct <<= 3; j = 0;
    for (i = 0; i < 24; ++i) {
        uint_fast32_t  o = oct & 8;
        p2[i] = (j >> o) & 0x1f;
        j += 1 << o;
        oct >>= 1;
    }

    // %%FOR i in range(8)
    j = p2[p1[0] & 0x1f] & 7;
    q[j] = 0;
    q_inv[0] = j;
    j = p2[p1[1] & 0x1f] & 7;
    q[j] = 1;
    q_inv[1] = j;
    j = p2[p1[2] & 0x1f] & 7;
    q[j] = 2;
    q_inv[2] = j;
    j = p2[p1[3] & 0x1f] & 7;
    q[j] = 3;
    q_inv[3] = j;
    j = p2[p1[4] & 0x1f] & 7;
    q[j] = 4;
    q_inv[4] = j;
    j = p2[p1[5] & 0x1f] & 7;
    q[j] = 5;
    q_inv[5] = j;
    j = p2[p1[6] & 0x1f] & 7;
    q[j] = 6;
    q_inv[6] = j;
    j = p2[p1[7] & 0x1f] & 7;
    q[j] = 7;
    q_inv[7] = j;
    // %%END FOR

    // %%FOR i in range(6)
    j = q_inv[0];
    q_inv[q[0]] = q_inv[q[j]];
    q[j] = q[0];
    res = res * 8 + j - 0;
    j = q_inv[1];
    q_inv[q[1]] = q_inv[q[j]];
    q[j] = q[1];
    res = res * 7 + j - 1;
    j = q_inv[2];
    q_inv[q[2]] = q_inv[q[j]];
    q[j] = q[2];
    res = res * 6 + j - 2;
    j = q_inv[3];
    q_inv[q[3]] = q_inv[q[j]];
    q[j] = q[3];
    res = res * 5 + j - 3;
    j = q_inv[4];
    q_inv[q[4]] = q_inv[q[j]];
    q[j] = q[4];
    res = res * 4 + j - 4;
    j = q_inv[5];
    q_inv[q[5]] = q_inv[q[j]];
    q[j] = q[5];
    res = res * 3 + j - 5;
    // %%END FOR

    return  16 * res + p2[p1[8] & 0x1f];
}

#undef  STD_OCTADNO   
            


// %%EXPORT p
MAT24_API
void mat24_perm_to_matrix(uint8_t  *p1, uint32_t *m_out)
// Convert the permutation p1 in the Mathieu group Mat24 to a matrix.
//
// The matrix is a 12 x 12 bit matrix acting on the Golay code
// vectors by right multiplication. It is stored at m_out.
//
// Permutation p1 is not checked to be a member of the Mathieu group.
{
   int i;
   uint32_t a[24]; 
   for (i=0; i<24; ++i) a[i] = MAT24_RECIP_BASIS[p1[i] & 0x1f] >> 12;
   *m_out++ = 1;
   // %%BITMATMUL Mat24_basis[13:24], uint32_t, a, m_out   


   // GF(2) bit matrix multiplication as a sequence of XOR operations:
   //   m_out  = _MFIX_ * a  ,
   // with bit matrices represented as arrays of unsigned integers,
   // each integer representing a row of the matrix. 
   // Here _MFIX_ is the fixed bit matrix  {
   //  0xfff0f0,0xff0ff0,0xf0fff0,0x0ffff0,0xaaaa00,0x666600,
   //  0xc6a0a0,0xac6060,0x6ca00a,0xca6006,0x11111e
   // }
   {
    uint32_t _r[2];
    m_out[9] = (uint32_t)(a[2]) ^ (uint32_t)(a[1]);
    m_out[8] = (uint32_t)(a[3]) ^ (uint32_t)(a[1]);
    m_out[10] = m_out[8] ^ (uint32_t)(a[2]);
    m_out[10] = (uint32_t)(a[4]) ^ m_out[10];
    m_out[0] = (uint32_t)(a[6]) ^ (uint32_t)(a[4]);
    m_out[7] = (uint32_t)(a[6]) ^ (uint32_t)(a[5]);
    m_out[6] = (uint32_t)(a[7]) ^ (uint32_t)(a[5]);
    m_out[0] = m_out[6] ^ m_out[0];
    m_out[10] = (uint32_t)(a[8]) ^ m_out[10];
    m_out[1] = (uint32_t)(a[10]) ^ (uint32_t)(a[8]);
    m_out[5] = (uint32_t)(a[10]) ^ (uint32_t)(a[9]);
    m_out[4] = (uint32_t)(a[11]) ^ (uint32_t)(a[9]);
    m_out[1] = m_out[4] ^ m_out[1];
    m_out[1] = m_out[1] ^ m_out[0];
    m_out[10] = (uint32_t)(a[12]) ^ m_out[10];
    m_out[2] = (uint32_t)(a[14]) ^ (uint32_t)(a[12]);
    m_out[3] = (uint32_t)(a[14]) ^ (uint32_t)(a[13]);
    m_out[5] = m_out[3] ^ m_out[5];
    m_out[9] = m_out[3] ^ m_out[9];
    m_out[7] = m_out[3] ^ m_out[7];
    m_out[3] = (uint32_t)(a[15]) ^ (uint32_t)(a[13]);
    m_out[4] = m_out[3] ^ m_out[4];
    m_out[8] = m_out[3] ^ m_out[8];
    m_out[6] = m_out[3] ^ m_out[6];
    m_out[2] = m_out[3] ^ m_out[2];
    m_out[0] = m_out[2] ^ m_out[0];
    m_out[2] = m_out[2] ^ m_out[1];
    m_out[10] = (uint32_t)(a[16]) ^ m_out[10];
    m_out[3] = (uint32_t)(a[17]) ^ (uint32_t)(a[16]);
    _r[0] = (uint32_t)(a[18]) ^ (uint32_t)(a[17]);
    m_out[6] = _r[0] ^ m_out[6];
    m_out[5] = _r[0] ^ m_out[5];
    _r[0] = (uint32_t)(a[19]) ^ (uint32_t)(a[17]);
    m_out[9] = _r[0] ^ m_out[9];
    m_out[4] = _r[0] ^ m_out[4];
    _r[0] = (uint32_t)(a[19]) ^ (uint32_t)(a[18]);
    m_out[8] = _r[0] ^ m_out[8];
    m_out[7] = _r[0] ^ m_out[7];
    m_out[3] = _r[0] ^ m_out[3];
    m_out[0] = m_out[3] ^ m_out[0];
    m_out[1] = m_out[3] ^ m_out[1];
    m_out[3] = m_out[3] ^ m_out[2];
    m_out[10] = (uint32_t)(a[20]) ^ m_out[10];
    _r[0] = (uint32_t)(a[21]) ^ (uint32_t)(a[20]);
    _r[1] = (uint32_t)(a[22]) ^ (uint32_t)(a[21]);
    m_out[8] = _r[1] ^ m_out[8];
    m_out[5] = _r[1] ^ m_out[5];
    _r[1] = (uint32_t)(a[23]) ^ (uint32_t)(a[21]);
    m_out[4] = _r[1] ^ m_out[4];
    m_out[7] = _r[1] ^ m_out[7];
    _r[1] = (uint32_t)(a[23]) ^ (uint32_t)(a[22]);
    m_out[6] = _r[1] ^ m_out[6];
    m_out[9] = _r[1] ^ m_out[9];
    _r[0] = _r[1] ^ _r[0];
    m_out[0] = _r[0] ^ m_out[0];
    m_out[1] = _r[0] ^ m_out[1];
    m_out[2] = _r[0] ^ m_out[2];
    // 57 operations generated
   }

}


// %%EXPORT p
MAT24_API
void mat24_matrix_to_perm(uint32_t *m1, uint8_t *p_out)
// Convert Mathieu group element m1 from matrix to permutation.
//
// The matrix m1 is a 12 x 12 bit matrix acting on the Golay code
// vectors by right multiplication. The matrix is not checked.
//    
// The output permutation is stored to p_out.
{
   // %%MAT24_MATRIX_TO_PERM   m1, p_out
   uint_fast32_t _i, ba[14], t[11];
   for (_i=0; _i < 12; ++_i) ba[_i] =
       (MAT24_DEC_TABLE1[(m1[_i] << 4) & 0xf0]
          ^ MAT24_DEC_TABLE2[(m1[_i]  >> 4) & 0xff])
   ;
   ba[12] = ba[5] ^ ba[8] ^ ba[10];
   ba[13] = ba[5] ^ ba[6] ^ ba[7] ^ ba[9];
   t[0] = ba[11];
   t[1] = ~(ba[11]);
   t[2] = ba[12] & ba[13];
   t[3] = ba[12] & ~(ba[13]);
   t[4] = ba[13] & ~(ba[12]);
   t[5] = ba[0] & ~(ba[1] | ba[2]);
   t[6] = ba[1] & ba[2] & ba[3] & ba[4];
   t[7] = ba[2] & ~(ba[1]);
   t[8] = ba[3] & ~(ba[2]);
   t[9] = ba[4] & ~(ba[3]);
   t[10] = ba[1] & ~(ba[4]);
   for (_i = 0; _i < 6; ++_i) {
      uint_fast32_t _w, _k = t[_i + 5];
      _w =  t[(0x1 >> (_i << 2)) & 0xf] & _k;
      *p_out++ = MAT24_LSBIT_TABLE[(0x077cb531UL *  \
              (_w) >> 26) & 0x1f];
      _w =  t[(0x443322 >> (_i << 2)) & 0xf] & _k;
      *p_out++ = MAT24_LSBIT_TABLE[(0x077cb531UL *  \
              (_w) >> 26) & 0x1f];
      _w =  t[(0x224433 >> (_i << 2)) & 0xf] & _k;
      *p_out++ = MAT24_LSBIT_TABLE[(0x077cb531UL *  \
              (_w) >> 26) & 0x1f];
      _w =  t[(0x332244 >> (_i << 2)) & 0xf] & _k;
      *p_out++ = MAT24_LSBIT_TABLE[(0x077cb531UL *  \
              (_w) >> 26) & 0x1f];
   }
   p_out -= 24;
}


// %%COMMENT
/*************************************************************************
*** Mathieu group M24: operation of group elements
*************************************************************************/

// %%EXPORT p
MAT24_API
uint32_t mat24_op_vect_perm(uint32_t v1, uint8_t *p1)
// Apply a permutation p1 to a vector v1 in GF(2)**24
//
// Here p1 is the permutation that maps i to p1[i]  for i=0,...,23.
// The function returns the result v1 * p1.
{
   uint_fast32_t i, w = 0;
   for (i = 0; i < 24; ++i) w |=  ((v1 >> i) & 1) << p1[i];
   return w;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_op_gcode_matrix(uint32_t v1, uint32_t *m1)
// Apply the 12 x 12 bit matrix m to a Golay code vector
//
// The code vector v1 is given in 'gcode' representation.
// Here application means right multiplication v1 * m1. 
// The funtion returns the result v1 * m1.
{
    uint_fast32_t w = 0;
    register int i;
    for (i=0; i< 12; ++i) w ^= *m1++ & (-((v1 >> i) & 1)); 
    return w;
}



// %%EXPORT p
MAT24_API
uint32_t mat24_op_gcode_perm(uint32_t v1, uint8_t *p1)
// Apply a permutation p1 to a Golay code vector v1
//
// Here p1 is the permutation that maps i to p1[i], i=0,...,23,
// representing an element of the Mathieu group M24.
//
// Golay code vector v1 is given in gcode representation.
// The function returns the result v1 * p1.
{
    uint_fast32_t i, w = 0;
    v1 =   MAT24_DEC_TABLE1[(v1 << 4) & 0xf0]
           ^ MAT24_DEC_TABLE2[(v1 >> 4) & 0xff];
    for (i = 0; i < 24; ++i) w |=  ((v1 >> i) & 1) << p1[i];
    v1 =  MAT24_ENC_TABLE0[w & 0xff]
           ^ MAT24_ENC_TABLE1[(w >> 8) & 0xff]
           ^ MAT24_ENC_TABLE2[(w >> 16) & 0xff];
    return v1 >> 12;
}


// %%EXPORT p
MAT24_API
uint32_t mat24_op_cocode_perm(uint32_t c1, uint8_t *p1)
// Apply a permutation p to a Golay cocode vector v
//
// Here p1 is the permutation that maps i to p1[i], i=0,...,23,
// representing an element of the Mathieu group M24.
//
// Golay cocode vector c1 is given in cocode representation.
// The function returns the result v1 * c1.
{
   uint_fast32_t res;
   res = - ((c1 + 1) & 1);         // res = 0 if c1 is odd else -1
   c1 ^= MAT24_RECIP_BASIS[0] & res;     // make c1 odd
   res &= MAT24_RECIP_BASIS[p1[0] & 31]; // .. and adjust result
   c1 = MAT24_SYNDROME_TABLE[ (c1 >> 1) & 0x7ff ]; // get syndrome
   res ^= MAT24_RECIP_BASIS[p1[c1 & 31] & 31]
        ^ MAT24_RECIP_BASIS[p1[(c1 >> 5) & 31] & 31]
        ^ MAT24_RECIP_BASIS[p1[(c1 >> 10) & 31] & 31];
   return res & 0xfff;
}



// %%EXPORT p
MAT24_API
void mat24_mul_perm(uint8_t *p1, uint8_t *p2, uint8_t *p_out)
// Return p1 * p2 in array p_out
//
// p1, p2, p_out  are elements of the  Mathieu group Mat24 
// represented as permutations.  Any overlap is possible.
{
    uint8_t p[32];
    uint_fast8_t i;
    for (i = 0; i < 24; ++i) p[i] = p2[p1[i] & 31];
    memcpy(p_out, p, 24); 
}


// %%EXPORT p
MAT24_API
void mat24_inv_perm(uint8_t *p1, uint8_t *p_out)
// Return inverse of p1 in array p_out
//
// p1, p_out  are elements of the  Mathieu group Mat24 
// represented as permutations.  Any overlap is possible.
{
    uint8_t p[32];
    uint_fast8_t i;
    for (i = 0; i < 24; ++i)  p[p1[i] & 31] = i;
    memcpy(p_out, p, 24); 
}


// %%COMMENT
/*************************************************************************
*** Automorphisms of the Parker Loop
*************************************************************************/


static const uint32_t MAT24_AUTPL_QF_TABLE[] = {
  // %%TABLE Mat24_autpl_qf_table, uint32   
0x000b000dUL,0x00030001UL,0x000f0007UL,0x000f0007UL,
0x000e000fUL,0x003f001fUL,0x0401000eUL,0x00ff007fUL,
0x00000401UL,0x03ff01ffUL,0x00000000UL,0x00000000UL
};


// %%EXPORT p
MAT24_API
void mat24_autpl_set_qform(uint32_t *m_io)
// Recompute quadratic form on a Parker loop automorphism  m_io
//
// This functions augments the Parker loop automorphism m_io by
// a quadratic form qf. The form qf simplifies the application
// of m_io to Parker loop elements and also the multiplication
// of  Parker loop automorphisms. The quadratic form qf is stored 
// in bits 13,...,24 of the entries of m_io. 
{
    uint_fast32_t i, v,  m2[11];

    // The quadratic form qf on the Golay code is defined as follows:
    // qf(b[i]) = 0 for all basis vectors b[i] of the standard
    // basis of the Golay code. Furthermore
    //   qf(v1+v2) = qf(v1) + qf(v2) + v1 * q * transpose(v2),
    // with matrix q as defined below.
 
    // First compute the 12 x 12  matrix q with
    // q[i,j] = theta(m[i], m[j])  ^  theta(b[i],b[j]).
    // Here b[i] is the i-th standard basis vector of the Golay code
    // and m[i] is it image under the automorphism given by m_io.
    // So m[i] = m_io[i] & 0xfff.
    // The matrix q is alternating by [Sey1], Lemma 4.1.
    // We just compute the lower triangle of q in order to evaluate a
    // quadratic form associated with q. Our first basis vector b[0] is 
    // Omega, so q[i,0] = q[0,i] = 0, and hence for the lower triangle
    // it suffices to compute q[i,j] for i=2,...,11; j=1,...,j-1.
    // We store q[i,j] in bit (j+13) of m[i].

    // Internal operation:
    // Most of the work is the computation of  theta(m[i], m[j]).
    // We read theta(b[i],b[j]) from table MAT24_AUTPL_QF_TABLE.

    // Store m[i+1], bit 1..11, in m2[i], bit 0..10,
    // and a copy of that value in m2[i], bit 16..26     
    for (i = 0; i < 11; ++i)  {
        v =  (m_io[i+1] & 0xfff) >> 1; 
        m2[i] = v + (v << 16);
    }

    // Put v = ( theta(m[i+1], bit 1..11,  theta(m[i+2]), bit 1..11 )
    // and compute the matrix product v * transpose(m2).
    // The result is theta(m[i+2], m[j]), j= 1..11 and
    // theta(m[i+3], m[j]), j= 1..11. 
    // Then compute q[i+2,j] and q[i+3,j] for j < i from these results
    // and constants theta(b[i],b[j]) in table MAT24_AUTPL_QF_TABLE.

    for (i = 0; i < 10; i += 2) {
        v = ((MAT24_THETA_TABLE[m2[i+1] & 0x7ff] & 0xffe) >> 1)
            ^ ((MAT24_THETA_TABLE[m2[i+2] & 0x7ff] & 0xffe) << 15);
        // %%BITVMULTRANSP v, m2, 16, 10, 2
        // Compute v = v * transpose(m), v a bit vector, m a bit matrix,
        // v coded as an integer with 16 valid bits, m a 10 x 16 bit matrix
        // coded as an array of integers.
        {
        uint_fast32_t _t0, _t1, _t2, _t3;
        _t0 =  m2[0] & v;
        _t1 =  m2[1] & v;
        _t0 = (((_t0 >> 1) ^ _t0) & 0x55555555UL)
            | (((_t1 << 1) ^ _t1) & 0xaaaaaaaaUL);
        _t1 =  m2[2] & v;
        _t2 =  m2[3] & v;
        _t1 = (((_t1 >> 1) ^ _t1) & 0x55555555UL)
            | (((_t2 << 1) ^ _t2) & 0xaaaaaaaaUL);
        _t0 = (((_t0 >> 2) ^ _t0) & 0x33333333UL)
            | (((_t1 << 2) ^ _t1) & 0xccccccccUL);
        _t1 =  m2[4] & v;
        _t2 =  m2[5] & v;
        _t1 = (((_t1 >> 1) ^ _t1) & 0x55555555UL)
            | (((_t2 << 1) ^ _t2) & 0xaaaaaaaaUL);
        _t2 =  m2[6] & v;
        _t3 =  m2[7] & v;
        _t2 = (((_t2 >> 1) ^ _t2) & 0x55555555UL)
            | (((_t3 << 1) ^ _t3) & 0xaaaaaaaaUL);
        _t1 = (((_t1 >> 2) ^ _t1) & 0x33333333UL)
            | (((_t2 << 2) ^ _t2) & 0xccccccccUL);
        _t0 = (((_t0 >> 4) ^ _t0) & 0xf0f0f0fUL)
            | (((_t1 << 4) ^ _t1) & 0xf0f0f0f0UL);
        _t1 =  m2[8] & v;
        _t2 =  m2[9] & v;
        _t1 = (((_t1 >> 1) ^ _t1) & 0x55555555UL)
            | (((_t2 << 1) ^ _t2) & 0xaaaaaaaaUL);
        _t1 = ((_t1 >> 2) ^ _t1) & 0x33333333UL;
        _t1 = ((_t1 >> 4) ^ _t1) & 0xf0f0f0fUL;
        v = (((_t0 >> 8) ^ _t0) & 0xff00ffUL)
            | (((_t1 << 8) ^ _t1) & 0xff00ff00UL);
        // 79 operations
        }
        v = (v ^ MAT24_AUTPL_QF_TABLE[i]) & MAT24_AUTPL_QF_TABLE[i+1];
        m_io[i+2] = (m_io[i+2] & 0x1fff) ^ ((v & 0x7ff) << 14);
        m_io[i+3] = (m_io[i+3] & 0x1fff) ^ ((v & 0x7ff0000) >> 2);
    }
}


// %%EXPORT p
MAT24_API
void mat24_perm_to_autpl(uint32_t c1, uint8_t *p1, uint32_t *m_out)
// Combine Mat24 and cocode element to Parker loop automorphism
//
// Given an element p1 of the Mathieu group Mat24 (in permutation 
// representation) and a Golay cocode element c1 (in cocode 
// representation), the function returns a Parker loop automorphism 
// m_out as a 12 x (12+13) matrix.
// m_out contains the 12 images of the basis vectors of the Parker loop
// and a quadratic form for simplfying its operation on Pl.
// m_out is an array of type uint32_t[12]
{
    uint_fast32_t i;
    mat24_perm_to_matrix(p1, m_out);
    for (i = 0; i < 12; ++i) m_out[i] ^= ((c1 >> i) & 1) << 12;
    mat24_autpl_set_qform(m_out);
}


// %%EXPORT p
MAT24_API
void mat24_cocode_to_autpl(uint32_t c1, uint32_t *m_out)
// Convert cocode element c1 to Parker loop automorphism m_out.
//
// Same as perm_to_autpl(c1, p), with p the identity permutation.
{
    uint_fast32_t i;
    for (i = 0; i < 12; ++i) {
        m_out[i] = (1 << i) + (((c1 >> i) & 1) << 12);
    }
}


// %%EXPORT p
MAT24_API
void mat24_autpl_to_perm(uint32_t *m1, uint8_t  *p_out)
// Convert Parker loop automprohism to Mat24 permutation
// The resulting permutation is stored in p_out.
{
    mat24_matrix_to_perm(m1, p_out);
}

// %%EXPORT p
MAT24_API
uint32_t mat24_autpl_to_cocode(uint32_t *m1)
// Extract cocode vector c from Parker loop automorphism m1
//
// Then m1 = perm_to_autpl(c, p), where p is the permutation
// obtained by calling autpl_to_perm(m1).
//
// Note that m1 = cocode_to_autpl(c) *  perm_to_autpl(0, p).
{
    uint_fast32_t i, v = 0;
    for (i = 0; i < 12; ++i)  v += ((m1[i] >> 12) & 1) << i;
    return v;
}


// The following macro computes t = mat24_op_ploop_autpl(v1, m1).
// It destroys v1. Description see function mat24_op_ploop_autpl().
#define inline_op_ploop_autpl(v1, m1, t) \
    t = (v1 & 0x1000) \
          ^ (m1[0] & -(v1 & 1)) ^ (m1[1] & -((v1 >> 1) & 1)) \
          ^ (m1[2] & -((v1 >> 2) & 1))  ^ (m1[3] & -((v1 >> 3) & 1)) \
          ^ (m1[4] & -((v1 >> 4) & 1))  ^ (m1[5] & -((v1 >> 5) & 1)) \
          ^ (m1[6] & -((v1 >> 6) & 1))  ^ (m1[7] & -((v1 >> 7) & 1)) \
          ^ (m1[8] & -((v1 >> 8) & 1))  ^ (m1[9] & -((v1 >> 9) & 1)) \
          ^ (m1[10] & -((v1 >> 10) & 1)) ^ (m1[11] & -((v1 >> 11) & 1));\
    v1 = (t >> 13) & v1;  v1 ^= v1 >> 6;  v1 ^= v1 >> 3; \
    v1 = (0x96 >> (v1 & 7)) & 1; \
    t = (t & 0x1fff) ^ (v1 << 12);     


// %%EXPORT p
MAT24_API
uint32_t mat24_op_ploop_autpl(uint32_t v1, uint32_t *m1)
// Apply Parker loop automorphism m1 to Parker Loop element v1
//
// Here m1 is a Parker loop autmorphism (in autpl representation)
// and v1 is an element of the Parker loop, encoded as in function
// mat24_mul_ploop().
// The function returns the resulting cocode vector  v1 * m1.
{
    // Operation:
    // Matrix m1 contains a quadratic form qf and the images of the
    // basis vectors, as described in function mat24_autpl_set_qform().
    // Let m = (m[0],...,m[1]), with row vector m[i] the image of the 
    // i-th basis vector b[i]. Then we compute the product binary 
    // matrix product:
    //    t0 = v_12 * m,
    // where v_12 is the vector containing the lower 12 bits of v, 
    // excluding the sign bit. t0 is the correct result up to sign.
    // Then we asjust the sign as follows:
    //   t = t0  ^  (v1 & 0x1000) ^ (s << 12),  
    // where (v1 & 0x1000) is the sign bit of v1 and s is defined by
    // s = qf(v_12) =  v_12 *  q  * transpose(v_12),
    // and q is the 12 x 12 matrix representing the quadratic form qf 
    // as in function mat24_autpl_set_qform().  

    uint_fast32_t  t;
    inline_op_ploop_autpl(v1, m1, t);
    return t;
}


// %%EXPORT p
MAT24_API
void mat24_mul_autpl(uint32_t *m1, uint32_t *m2, uint32_t *m_out)
// Put m_out = m1 * m2 for Parker loop automorphisms m1, m2
//
// Here all automorphisms are in 'autpl' representation.
{
    uint_fast32_t  i, v, t;
    uint32_t m[12];
    // Compute images of the vectors m[i] in m1 under the
    // automorphism m2 of the parker loop,
    for (i = 0; i < 12; ++i) {
        v = m1[i];
        inline_op_ploop_autpl(v, m2, t);
        m[i] = t;
    }
    // Store the images of the vectors m[i]  in output matrix m_out
    for (i = 0; i < 12; ++i) m_out[i] = m[i];
    // Compute the quadratic form for m_out.
    mat24_autpl_set_qform(m_out);
}


// %%EXPORT p
MAT24_API
void mat24_inv_autpl(uint32_t *m1, uint32_t *m_out)
// Put m_out = m1**(-1) for a Parker loop automorphisms m1
//
// Here all automorphisms are in 'autpl' representation.
{
    uint_fast32_t  i, v, t;
    uint8_t p[32], p_inv[32];
    uint32_t mi[12];

    mat24_matrix_to_perm(m1, p); 
    for (i = 0; i < 24; ++i) p_inv[p[i] & 31] = i;
    mat24_perm_to_matrix(p_inv, mi);
    for (i = 0; i < 12; ++i) {
         v = mi[i];
         inline_op_ploop_autpl(v, m1, t);
         mi[i] ^= (t & 0x1000);
    }
    for (i = 0; i < 12; ++i) m_out[i] = mi[i]; 
    mat24_autpl_set_qform(m_out);
}


//345678901234567890123456789012345678901234567890123456789012345678901234567890  

// %%EXPORT p
MAT24_API
void mat24_perm_to_iautpl(uint32_t c1, uint8_t *p1, uint8_t *p_o, uint32_t *m_o)
// Saving some intermediate steps, this is equivalent to:
//     mat24_inv_perm(p1, p_o);
//     mat24_perm_to_autpl(c1, p1, m_temp);  
//     mat24_inv_autpl(m_temp, m_o);
{
    uint_fast32_t i, v, t;
    uint32_t m1[16];
    uint8_t p_inv[32];
    mat24_perm_to_matrix(p1, m1);
    for (i = 0; i < 12; ++i) m1[i] ^= ((c1 >> i) & 1) << 12;
    mat24_autpl_set_qform(m1);

    for (i = 0; i < 24; ++i) p_inv[p1[i] & 31] = i;
    for (i = 0; i < 24; ++i) p_o[i] = p_inv[i];
    mat24_perm_to_matrix(p_inv, m_o);
    for (i = 0; i < 12; ++i) {
        v = m_o[i];
        inline_op_ploop_autpl(v, m1, t);
        m_o[i]  ^= (t & 0x1000);
    }
    mat24_autpl_set_qform(m_o);
}



// %%COMMENT
/*************************************************************************
*** Auxiliary functions for the Monster group
*************************************************************************/


// %%EXPORT p
MAT24_API
void mat24_perm_to_net(uint8_t *p1, uint32_t *a_out)
// Compute modified Benes network for permutation of 24 entries
//
// The network consists of 9 layers. The returned array 'a_out' of 
// length 9 describes that network. In layer i, entry j is to be
// exchanged with entry  j + d[i], if bit j of the value a_out[i]
// is set. Here d[i] = 1,2,4,8,16,8,4,2,1 for i = 0,...,8. In layers 
// i with d[i] >= 8 we assert that bit j of a_out[i] is set for j < 8
// only.
{
    uint_fast8_t p[32], q[32];
    uint_fast32_t i, j, sh, d, done;
    uint_fast32_t res0, res1, res2;

    for (i = 0; i < 24; ++i) 
        p[i] = p1[i] & 31; // copy permutation p1 to p

    // The first and the last three layers are a standard Benes network. 
    // Do Benes network looping algorithm steps for d = 1, 2, 4
    for (sh = 0; sh < 3; ++sh)
    {      
        d = 1 << sh;
        for (i = 0; i < 24; ++i)
            q[p[i]] = i;     // q := inverse of p
        done = 0;            // bit i marks that step i->p[i] is done
        res0 = 0;            // initial looping transpositions
        res1 = 0;            // final looping transpositions
        for (i = 0; i < 24; ++i)  // Looping step for Benes network
        {
            j = i;           // j is a node not yet processed
            while (!(done & (1 << j))) // while node j not done
            {
                done |= 1 << j;        // delare node j done
                j = p[j];              // j := permutation result p[j]
                // route node p[j] thru '0' part of inner Benes network
                // so we do: if (j & d): res1 |=  1 << (j & ~d)
                res1 |= ((j & d) >> sh) << (j & ~d);
                j = q[j ^ d];          // j = origin of buddy of p[j]
                done |= 1 << j;        // declare that buddy done
                // route buddy thru '1' part of inner Benes network
                // so we do: if (~j & d): res0 |=  1 << (j & ~d)
                res0 |= ((~j & d) >> sh) << (j & ~d);
                j = j ^ d;             // j = buddy of that origin
            }
        }
        a_out[sh] = res0;    // save initial looping transposition
        a_out[8-sh] = res1;  // save final looping transposition
        res0 |= res0 << d;   // initial: exchange i with i^d if bit i set
        res1 |= res1 << d;   // final: exchange i with i^d if bit i set
        for (i = 0; i < 24; ++i)  // compute q = (initial) * p * (final)
        {
            j = p[i ^ (((res0 >> i) & 1) << sh)];
            q[i] = j ^ (((res1 >> j) & 1) << sh);
        }
        for (i = 0; i < 24; ++i) // copy (initial) * p * (final) to p
            p[i] = q[i];
    }
    // It remains to compute the 3 middle layers. They must compute
    // the permutation i -> p[i] with p[i] = i (mod 8). E.g. for i=0
    // we do the following transpositions, if (0, 8, 16) maps to
    //
    //   ( 0,  8, 16):          (id)  *   (id)   *   (id)  // [1]
    //   ( 0, 16,  8):         (0,8)  *  (0,16)  *  (0,8)  // [0]     
    //   ( 8,  0, 16):         (0,8)  *   (id)   *   (id)  // [2]  
    //   ( 8, 16,  0):         (0,8)  *  (0,16)  *   (id)  // [3]
    //   (16,  0,  8):          (id)  *  (0,16)  *  (0,8)  // [4]  
    //   (16,  8,  0):          (id)  *  (0,16)  *   (id)  // [5]
    //          
    // For each permutation of (i, i+8, i+16) we compute a number j,
    // as indicated in square brackets above, from the bits 3 and 4 of
    // p[i] and p[i+8]. Then we use table look up for obtaining the
    // correct transpostions as given in the list above.   
    res0 = res1 = res2 = 0;
    for (i = 0; i < 8; ++i)
    {
        j = p[i] >> 3;
        j = 2 * j + ((p[i+8] >> (3 + (j & 1))) & 1);
        j = (0x236407 >> (j << 2)) & 0xf;
        res2 |=  (j & 1) << i;
        res1 |=  ((j >> 1) & 1) << i;
        res0 |=  ((j >> 2) & 1) << i;
    }
    a_out[3] = res0; a_out[4] = res1; a_out[5] = res2;
}







// %%EXPORT p
MAT24_API
void mat24_op_all_autpl(uint32_t *m1, uint16_t *a_out)
// Auxiliary function for the rep 196884x of the monster.
// Apply Parker loop automorphism  m1  to all Parker Loop elements.
// The function computes a table a_out[i], i= 0,...,0x7ff, such  
// that 2 * (a_out[i] & 0x7ff) is the image m1(2*i) of the Parker 
// loop element 2*i modulo the center of the Parker loop.
// Signs are stored in bits 12...14 of a_out[i] as follows:
// Bit 12: (sign of m1(2*i)) ^ (odd &  P(2*i))
// Bit 13: (sign of m1(2*i))
// Bit 14: (sign of m1(2*i)) ^ (bit 0 of m1(2*i))
// Here odd is 1 iff m1 is an odd automorphism, and P() is the
// Power map of the Parker loop.
{
    uint_fast32_t i;   // exponential counter: 1, 2, 4, 8,...,0x400
    uint_fast32_t j;   // counter from 1 to i-1
    uint_fast32_t ri;  // accumulator for computing a_out[i]
    uint_fast32_t q;   // 2*q is row log2(i)+1 of bilinear form in m1
    uint_fast32_t qq, qq1, qq2;  // used for computing a sign bit
    uint_fast32_t odd; // set to a nonzero value if m1 is odd
    odd = m1[0] & 0x1000;
    // We have to to the following:
    a_out[0] = 0; 
    // But we also don't like dummy operations with undefined input
    a_out[1] = a_out[2] = a_out[3] = 0;
    for (i = 1; i < 0x800; i += i) {
        // First compute ri = a_out[i] and copy the (halved) 
        // corresponding row of bilinear form from m1 to q. 
        ri = *++m1;                 // row  log2(i)+1   of  m1
        q = (ri >> 14) & 0x7ff;     // halved row of bilinear form B
        // m1[log2(i)+1], bit 0,..12 is the Parker loop element 2*i,
        // with bit 12 the sign bit. Store sign bit to bits 12...14
        // of ri. Store halved image of element 2*i in bits 10...0.
        // of ri. xor bit 0 of that image to bit 14 of ri. Note that 
        // the Power map bit is 0 for all basis vectors.
        ri = -(ri & 0x1000) ^ ((ri & 0xffe) >> 1) ^ ((ri & 1) << 14);
        a_out[i] = ri;   // Save result ri in a_out.
        qq1 = -((q & 1) << 12);
        a_out[i+1] = ri ^ a_out[1] ^ qq1;   
        qq2 =  -((q & 2) << 11);     
        a_out[i+2] = ri ^ a_out[2] ^ qq2;   
        a_out[i+3] = ri ^ a_out[3] ^ qq1 ^ qq2;   
        // Next compute a_out[i+j], 1 <= j < i.
        // We do cases j,..j+3 in a single iteration for j = 0 mod 4
        for (j = 4; j < i; j += 4) {
            // Store bit dsign = B(2*i, 2*j) = parity(j & q) in 
            // qq, bits 12..14. We have 
            //  sign(2*(i+j)) = sign(2*i) ^ sign(2*j) ^ dsign
            qq = j & q;
            qq ^= qq >> 6;
            qq ^= qq >> 3;
            qq = -((0xD20 << (qq & 7)) & 0x1000); 
            // Put a_out[i+j] = a_out[i] ^ a_out[j] ^ dsign
            a_out[i+j] = ri ^ a_out[j] ^ qq; 
            qq1 = qq ^ -((q & 1) << 12); // qq1[12..14] = qq0^B(2*i,1) 
            a_out[i+j+1] = ri ^ a_out[j+1] ^ qq1; 
            qq2 =  -((q & 2) << 11);     // qq2[12..14] =  B(2*i,2) 
            a_out[i+j+2] = ri ^ a_out[j+2] ^ qq ^ qq2; 
            a_out[i+j+3] = ri ^ a_out[j+3] ^ qq1 ^ qq2; 
        }
    }
    if (odd) for (i = 0; i < 0x800; i += 4) {
        // Adjust bit 12  for power map if m1 is odd   
        a_out[i] ^= MAT24_THETA_TABLE[i] & 0x1000;
        a_out[i+1] ^= MAT24_THETA_TABLE[i+1] & 0x1000;
        a_out[i+2] ^= MAT24_THETA_TABLE[i+2] & 0x1000;
        a_out[i+3] ^= MAT24_THETA_TABLE[i+3] & 0x1000;
    }
}





// %%EXPORT p
MAT24_API
void mat24_op_all_cocode(uint32_t c1, uint8_t *a_out)
// Auxiliary function for the rep 196884x of the monster.
// Apply cocode element c1 (interpreted as a Parker loop 
// automorphism) to all Parker Loop elements.
// The function computes a table a_out[i], i= 0,...,0x7ff, 
// containing the signs related to this operation as follows:
// Bit 0:  (sign of c1(2*i)) ^ (odd &  P(2*i))
// Bit 1:  (sign of c1(2*i))
// Bit 2:  same as bit 1
// Here odd is 1 iff m1 is an odd automorphism, and P() is the
// power map of the Parker loop.
// This ia a simplified version of function mat24_op_all_autpl().
{
    uint_fast32_t i;      // exponential counter: 1, 2, 3, 8,...,0x400
    uint_fast32_t j;      // counter from 1 to i-1
    uint_fast32_t sh = 0; // shift factor: i = 2 << sh
    uint_fast32_t ri;     // accumulator for computing a_out[i]
    // We have to to the following:
    a_out[0] = 0; 
    // But we also don't like dummy operations with undefined input
    a_out[1] = a_out[2] = a_out[3] = 0;
    for (i = 1; i < 0x800; i += i) {
        // First compute ri = a_out[i]. ri is equal to the scalar 
        // product of the Golay code element 2*i and  the cocode 
        // element c1.  Note that the Power map bit is 0 for all 
        // basis vectors.
        a_out[i] = ri = -((c1 >> ++sh) & 1);
        a_out[i+1] = ri ^ a_out[1];
        a_out[i+2] = ri ^ a_out[2];
        a_out[i+3] = ri ^ a_out[3];
        // Next compute a_out[i+j], 1 <= j < i.
        for (j = 4; j < i; j += 4) {
            // Put a_out[i+j] = a_out[i] ^ a_out[j]
            a_out[i+j] = ri ^ a_out[j];      
            a_out[i+j+1] = ri ^ a_out[j+1];      
            a_out[i+j+2] = ri ^ a_out[j+2];      
            a_out[i+j+3] = ri ^ a_out[j+3];      
        }
    }
    if (c1 & 1) for (i = 0; i < 0x800;  i += 4) {
        // Adjust bit 12  for power map if c1 is odd   
        a_out[i] ^= (MAT24_THETA_TABLE[i] >> 12) & 0x1;
        a_out[i+1] ^= (MAT24_THETA_TABLE[i+1] >> 12) & 0x1;
        a_out[i+2] ^= (MAT24_THETA_TABLE[i+2] >> 12) & 0x1;
        a_out[i+3] ^= (MAT24_THETA_TABLE[i+3] >> 12) & 0x1;
    }
}








// %%GEN ch
#ifdef __cplusplus
}
#endif
// %%GEN h
// #endif  // #ifndef MAT24_FUNCTIONS_H
// 
// 
// 
