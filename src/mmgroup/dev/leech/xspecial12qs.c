/*************************************************************************
Computation in the real Clifford group of up to 12 qubits.

Backround from quantum computing
--------------------------------

Let V = F_2**n be a Boolean vector space and T be the unit circle in 
the set CC of the complex numbers. Then F_2**n is an additive and T 
is a multiplicative Abelian group. For any mapping f: V -> T define 
the mapping \Delta f: V \times V -> T by

   \Delta f(x,y) = f(x+y) * f(x)**(-1) * f(y)**(-1) * f(0) .

A mapping g : V \times V -> T is bilinear if 

   g(x1 + x2, x3) = g(x1, x3) * g(x2, x3) , 
   g(x1, x2 + x3) = g(x1, x3) * g(x1, x3) .

Then we obviously have g(x1,x2) = +-1 and g(0,x1) = g(x1,0) = 0.
A mapping f : V -> T is called a quadratic mapping if \Delta f is 
bilinear. For a quadratic mapping f we also require the functional
values f(x) to be 8th roots of unity.


Let Q: F_2**m -> T be an  be a quadratic mapping. 
Let A: F_2**m -> F_2**n be an affine mapping. Let e 
an integer. Define a function f = f(e, A, Q): F_2**n -> CC by

   f(x) = sqrt(2)**(e) * sum_{y in F_2**m: A(y) = x} Q(y) .   (1)

We call a function f statisfying (1) a quadratic state mapping.

In the theory of quantum computation, a state vector representing the 
state of n qubits can be written as a vector in CC**(2**n), where the 
2**n unit vectors of CC**n are labeled by the elements of F_2**n. Such 
a state vector v can be considered as a function  F_2**n -> CC mapping 
the labels of the unit vectors to the corresponding coordinates of the 
vector v. We call this function the coordinate function of the 
vector v. Coordinate functions of a complex 2**n \times 2**n matrix 
(describing a transition from one n-qubit state to another) are 
defined similarly. In the theory of quantum computing the vector space
CC**(2**n) is considered as an an n-fold tensor product of CC*2.


A vector (or a matrix) is called a quadratic state vector (or a 
quadratic state matrix) if its coordinate function is a quadratic 
state function. It is not difficult to show that tensor products and 
tensor contractions of quadratic state vectors are quadratic state 
vectors, which can easily be computed in practice. Since matrix 
multiplication can be obtained from tensor products and contraction, 
the matrix product of two quadratic state matrices is also a 
quadratic state matrix. 

The following Theorem is less obvious:

Theorem 1:
For every quadratic state mapping g: F_2**n -> CC there is a 
function f(e, A, Q) satisfying (1) with g = f(e, A, Q)  such that
the affine mapping  A: F_2**m -> F_2**n is injective.
Given g as any quadratic state mapping, quantities e, A and 
Q: F_2**m -> T  with  g = f(e, A, Q) and m <= n can be computed 
in time polynomial in the input size. 

Sketch proof
For the proof of Theorem 1 we have to calculate a sum 
   S(y) =  sum  Q(x) * (-1)**B(x,y) ,   for x in F_2**m.
Here Q: F_2**m -> T is a quadratic mapping,  B is a symmetric bilinear 
form on F_2**m \times F_2**n. The sum S has to be calculated as a 
function of y for all y in F_2**n. Such sums can be computed as 
generalized Gauss sums by completing the square. With not too much
difficulty we can show that there is an affine subspace W of F_2**n 
such that the restiction of S is a W quadratic mapping (up to a scalar 
factor 2**(e1/2) * w**e2, with w an 8th root of unity), and that 
S(y) = 0 for y not in W.  We omit the details here.
q.e.d.



The complex Clifford group C_n is a group which is defined in [AaGo08] 
and [NeRS00]. It has a unitary representation in CC*(2**n).

Theorem 2
The unitary complex quadratic state matrices in CC*(2**n)
form a representation of the Clifford group C_n.

Proof
It is easy to see that all generators of C_n in [AaGo08] or [NeRS00] 
are unitary complex quadratic state matrices. The group C'_n of such 
matrices is closed under multplication. It is obviously closed under 
computing the inverse, which is the conjugate transpose for a unitary 
matrix. Thus C_n is a subgroup of C'_n. By Theorem 2 the group C_n is 
finite. By [NeRS00], Theorem 6.5, all finite supergroups of C_n in the 
unitary group are generated by C_n and a multiple of the unit matrix 
by a root of unity. Comparing the scalar multiples of the unit matrix 
in C_n and C'_n yields C_n = C'_n.  
q.e.d. 


Call a vector in CC*(2**n) a stablizer state vector if it has norm 1
and if it is also a quadratic state vector. By Theorem 1 the product
of a stabilizer state vector with a unitary quadratic state matrix is 
a stabilizer state vector. Thus Theorem 2 implies that the Clifford 
group C_n stabilizes the stablizer state vectors. It is not difficult 
to see that our stablizer state vectors coincide with the stabilizer 
states in [AaGo08].

Theorems 1 and 2 give a direct way to describe quadratic state 
vectors and matrices, and hence also Clifford group elements and 
stabilizer states in space quadratic in the number n of qubits. 
Operations on these objects such as matrix multiplication and 
computing scalar products can be done in time polynomial in n.


Our implementation of the real Clifford group
---------------------------------------------

After this motivation we feel free to use the language of quantum
computing. But we restrict this implementation to the case of rather 
small real quadratic state functions. More specifically we require
m + n < 64 in (1) and that all intermediate binary vectors fit in
a 64-bit integer. In practice the restricts us to 12 qubits, which
is sufficient to similate the subgroup 2**{1+24}.Co_1 of the monster.

Then the quadratic mapping Q in (1) can be considered as a real 
quadratic form F_2**m -> F_2, with  the embedding F_2 -> T given by 
k -> (-1)**k. Note that Q can be realized as an alternating bilinear  
form B(Q) with  B(Q)(x,y) = Q(x+y) - Q(x) - Q(y) + Q(0), augmented by 
a diagonal vector containing Q(e_k) for all unit vectors e_k of 
F_2**m. For a non-unit vector y the value Q(y) can be computed using 
Q(x1 + x2) =  Q(x1) + Q(x2) + B(Q)(x1, x2).
 
For the full set of complex quadratic functions we would have to 
consider mappings Q: ZZ_4, with the group of integers modulo 4, and 
the embedding F_2 -> ZZ_4 given by x -> 2x (as an embedding of 
additive groups), and the embedding ZZ_4 -> T given by x -> i**x,
where i = sqrt(-1). Then B(Q) is still a symmetric bilinear form and 
the diagonal vector has entries in ZZ4.   

We represent A as an (1 + m) times n matrix. All vector and matrix 
indices start with 0 as in the C language. Matrix A is considered to
have a constant invisible column (with index, say, -1) which has entry 
1 in row and 0 elsewhere. This column corresponds to an ancilla qubit 
with constant value 1. We represent B as an (m + 1) \times (m + 1) 
matrix. Evaluating the quadratic function Q at vector x, for x in 
F_2**m is done by computing (1,x)**t * (matrix B) * (1,x), where '*' is 
matrix multiplication, '**t' is transposition and (1,x) is the vector 
with first coordinate 1 and the other coordinates taken from vector x.    

Since we always evaluate Q at a vector (1,x) in F_2**(1+m), we need
not store the functional values Q(e_k) of Q at the unit vectors. We
have Q((1,e_k)) = Q((0,e_k)) + Q((1,0)) + B((0,e_k),(1,0)); so 
flipping both bits Q((0,e_k)) and B((0,e_k),(1,0)) does not change 
Q(1,e_k). This means that by tacitly assuming Q(e_k,0) = 0, it
suffices to store the bit B((0,e_k),(1,0)).  

In this module we support state vectors, operation of gates on state
vectors, and tensor contraction of state vectors. Here we alway contract 
over the first n qubits of a state vector. So we support tensor 
oparetions on the qubit level only. Tensor products and matrices over 
spaces of vector states are out of the scope of this module. We also 
support writing down stat vectors modulo smaall odd numbers, since we 
need  this feature for calculations in the monster group. 


Some naming conventions for C functions
---------------------------------------

The C functions in this module do operations on the bit matrices A 
and Q used to define a real state vector.

The state vector is desribed by a structure containing (at least) 
the following components

typedef struct {
    uint32_t nrows;    // Number m of rows of bit matrix A
    uint32_t ncols;    // Number n of columns of bit matrix A and Q
    int32_t  factor;   // A scaling factor, see below
    uint64_t *data;    // Pointer to the data bits of A and Q
} qbstate12_type;

Then it is implied that matrix Q has m rows and m columns. A and Q are 
simply concatenated to a matrix M. So M[i, j] refers to A[i, j] for 
j < ncols and to Q[i, j - ncols] for j >= ncols. The scaling factor is
an integer f which is interpreted as the constant factor
   (-1)**(f & 1) * sqrt(2)**(f >> 1) .
For complex state vectors we would have to store powers of sqrt(2)
multiplied by an 8th root of unity.

Data bits of M are stored in a strided array M' of unsigned integers 
of type uint64_t. (see e.g. the Python numpy package for documentation 
of a strided array). So the bit M[i,j] is stored in bit j % 64 of the 
array M'[i, j  / 64], and the position of the integer M'[i, k] is at 
byte  (i * stride[1] + k * stride[0]) relative to the pointer pointer 
to the data bits in the structure. Here bit j of an uint64_t is the
bit with valence 2**j. 

The current implementation requires nrows + ncols <= 64,  so that 
stride[1] is fixed to 1 and we need not care about stride[0]. With 
this restriction we may process transformation matrices for up to 12 
qubits, which is sufficient for implementing the subgroup 
2_+**{1+24}.Co_1 of the monster. In a future version the strides 
should be more flexible, so that more then 12 qubits may be processed. 
Also the full complex Clifford group for a given number of qubits 
could be supported in a future version. 

C functions supporting this module are prefixed with 'qbstate12_'.
Unless otherwise stated, these functions return an int32_t, where
a nonegative value is interpreted as success, and a negative value 
is intepreted as failure. Depending on the function, a nonnegative 
return value may e.g. mean an index for a matrix A, M or Q.  

Most functions take a pointer to a structure of type qbstate12_type
with name pqs, pqs1, pqs2,... . Other typical parameter names are

nqb           Number of qubits, i.e. of columns of matrix A.
nrows         Number of rows of matrix A, Q, and M.
i, i1,...     Index of a row of A, Q or M, starting with 0.
j, j1,..      index of a column of A, with a column of matrix A
              corrsesponding to a qubit, starting with 0.
              If appropriate, an index  j >= ncols refers to
              column (j - ncols) of matrix Q
pv, pv1,...   pointer to a row or column vector of matrix A, Q, or M,
              of type uint64*


Referneces
See file references.txt.


Side remark
-----------

Our theory of quadratic mappings from F_2**n to T can be generalized
to polynomial mappings of higher degree. Then state mappings of
higher degree can be defined similarly. We claim that mappings
of degree d >= 2 can be used to describe quantum computing circuits
with Clifford gates an phase gates of phase exp(2 \pi i * 2**(-d)).
Already in the cubic case d = 3 the group of unitary cubic state
matrices is no longer discrete. In contrary, it unleashes 
(asymtocially) the full power of quantum computing. While matrix
products can still be stored in polynomial space for n qubits and 
degree d, an analogue for Theorem 1 is no longer valid even for 
cubic state mappings.
************************************************************************/





#include <stdint.h>
#include <memory.h>
#include <stdio.h>

#include "small_bit_mat.h"
#include "xspecial12qs.h"


#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************************
*** Macros
*************************************************************************/
 
       
// Max No of columns supporte in an object of type 
// qbstate12_type. Here each column stores a bit.
#define MAXCOLS QBSTATE12_MAXCOLS
  
// Max No of rows required in an object of type qbstate12_type
// when  MAXCOLS bolumns are present.
#define MAXROWS QBSTATE12_MAXROWS

// Use this for the number 1 as an uint64_t
#define ONE ((uint64_t)0x1ULL)


// Check the object of type qbstate12_type referred by pqs.
// Return True if that object is errorneous.
#define bad_state(pqs) \
    ((pqs)->nrows + (pqs)->ncols > MAXCOLS  \
      || (pqs)->nrows  > (pqs)->maxrows)

// Check the object of type qbstate12_type referred by pqs.
// Return True if that object is errorneous or a memory error
// wuld occur after inserting 'more' additional rows.
#define bad_state_more_rows(pqs, more) \
    ((pqs)->nrows + (pqs)->ncols + (more) >  MAXCOLS \
      || (pqs)->nrows > (pqs)->maxrows)

// Check the object of type qbstate12_type referred by pqs.
// Return True if that object is errorneous or a memory error
// wuld occur after inserting 'more' additional columns.
#define bad_state_more_cols(pqs, more) \
    ((pqs)->nrows + (pqs)->ncols + (more) >  MAXCOLS \
      || (pqs)->nrows > (pqs)->maxrows)


// Return True if i is an illegal row index for the object
// of type qbstate12_type referred by pqs.
#define bad_row(pqs, i) ((i) >= (pqs)->nrows) 

// Return True if j is an illegal column index for the object
// of type qbstate12_type referred by pqs.
#define bad_col(pqs, j) ((j) >= MAXCOLS) 

// Xor bit (b & 1) to the bits Q[i1,i2] and Q[i2,i1] of the 
// submatrix Q of bit matrix M, where Q[i1, i2] = M[i1, i2 + ncols].
#define Xor_Q_i1_i2(M, ncols, b, i1, i2) \
    M[i1] ^= ((uint64_t)((b) & ONE) << ((ncols) + (i2))); \
    M[i2] ^= ((uint64_t)((b) & ONE) << ((ncols) + (i1))); 

     


// Generate C code to check that the result of qbstate12_prep_mul()
// if CHECK_QBSTATE12_PREP_MUL is #defined. 
#define CHECK_QBSTATE12_PREP_MUL




/*************************************************************************
*** Construction of a state
*************************************************************************/




int32_t qbstate12_set_mem(qbstate12_type *pqs, uint64_t *data, uint32_t size)
// Assign array 'data' of 'size' integers of type uint64_t[] as memory
// to the state vector *pqs. We recommend size = QBSTATE12_MAXROWS.
{
    pqs->data = data;
    pqs->maxrows = size;
    pqs->nrows = 0;
    pqs->ncols = 0;
    pqs->factor = 0;
    return 0;
}






int32_t qbstate12_zero(qbstate12_type *pqs, uint32_t nqb) 
// Set state *pqs to zero, for nqb qubits.
{  
    pqs->nrows = 0;
    pqs->factor = 1;
    pqs->ncols = nqb;
    if (bad_state(pqs)) {
        pqs->ncols = 0;
        return -1;
    }
    return 0;  
}



int32_t qbstate12_standard_state(qbstate12_type *pqs, uint32_t nqb)
// Set state *pqs to the standard unit vector |0...0>,  for nqb qubits.
{
    pqs->nrows = 1;
    pqs->ncols = nqb;
    pqs->factor = 0;
    pqs->data[0] = 0;
    if (bad_state(pqs)) return -1;
    return 0;  
}


int32_t qbstate12_vector_state(qbstate12_type *pqs, uint32_t nqb, uint64_t *pv)
// Set state *pqs to the unit vector |v>,  for nqb qubits.
// Vector v is referred by pv.
{
    pqs->nrows = 1;
    pqs->ncols = nqb;
    pqs->factor = 0;
    pqs->data[0] = *pv;
    if (*pv >= ONE << nqb || bad_state(pqs)) {
        pqs->nrows = pqs->ncols = 0;
        return -1;
    }
    return 0;
}





int32_t qbstate12_copy(qbstate12_type *pqs1, qbstate12_type *pqs2) 
// Copy the state referred by pqs1 to the state referred by pqs2. 
{
    if (bad_state(pqs1) || pqs2->maxrows < pqs1->nrows) return -1;
    pqs2->nrows = pqs1->nrows;
    pqs2->factor = pqs1->factor;
    pqs2->ncols = pqs1->ncols;
    memcpy(pqs2->data, pqs1->data, pqs1->nrows * sizeof(uint64_t));
    return 0;
}




/*************************************************************************
*** Elementary operations on matrices A and M of a state
*************************************************************************/



int32_t qbstate12_check(qbstate12_type *pqs) 
// Return 0 if ok, -1 if there is any error in the matrix data.
{
    uint_fast32_t i, j, c, err=0;
    uint64_t *m = pqs->data;
    // uint64_t mask;
    if (bad_state(pqs)) return -1;
    if (pqs->nrows == 0) return pqs->factor = 0;
    c = pqs->ncols;
    // mask = (ONE << c) << pqs->nrows;
    for (i = 0; i < pqs->nrows; ++i) {
        err |= m[i] >> (c + i);
        for (j = 0; j < i; ++j) {
            err |= (m[i] >> (c + j)) ^ (m[j] >> (c + i));   
        }
        // m[i] &= mask;
    }
    // for (i = pqs->nrows; i < pqs->maxrows; ++i) m[i] = 0;
    return -((int32_t)err & 1);    
} 


int32_t qbstate12_get_cols(qbstate12_type *pqs, uint32_t c0, uint32_t len, uint32_t *pa)
// Extract columns c0,...,c0 + len - 1 from matrix (A,Q)
// This is a workaround for a compiler problem with Cython 
{
    uint_fast32_t i;
    uint64_t *m = pqs->data, mask = (ONE << len) - 1;
    for (i = 0; i < pqs->nrows; ++i) {
        pa[i] = (uint32_t)((m[i] >> c0) & mask);
    }
    return 0;
}


int32_t qbstate12_set_cols(qbstate12_type *pqs, uint32_t c0, uint32_t len, uint32_t *pa)
// Fill columns c0,...,c0 + len - 1 of matrix (A,Q) from matrix *pa,
// columns 0,...,len-1.
// This is a workaround for a compiler problem with Cython 
{
    uint_fast32_t i;
    uint64_t *m = pqs->data, mask = (ONE << len) - 1;
    uint64_t mask_pqs = ~(mask << c0);
    for (i = 0; i < pqs->nrows; ++i) {
        m[i] &= mask_pqs;
        m[i] ^= (uint64_t)(pa[i] & mask) << c0;
    }
    return 0;
}







int32_t qbstate12_xch_rows(qbstate12_type *pqs, uint32_t i1, uint32_t i2)
// Exchange row i1 of the state matrix M referred by *pqs with row i2. 
// Also, adjust the quadratic form Q inside M. 1 <= i1, i2 < pqs->nrows 
// must hold. This does not change the state.
{ 
    uint64_t *m = pqs->data, v; 
    int_fast32_t k;
    if (bad_state(pqs) || bad_row(pqs, i1) || bad_row(pqs, i2)
                       || i1 == 0 || i2 == 0)  return -1;
    v = m[i1]; m[i1] = m[i2];  m[i2] = v;
    i1 +=  pqs->ncols; i2 +=  pqs->ncols; 
    v = (ONE << i1) ^ (ONE << i2);
    if (v) for (k = 0; k < pqs->nrows; ++k) 
        m[k] ^= v & -(((m[k] >> i1) ^ (m[k] >> i2)) & ONE);
    return 0; 
} 


int32_t qbstate12_del_rows(qbstate12_type *pqs, uint64_t *pv)
// Delete all rows i, 1 <= i < pqs->nrows, from the state matrix M 
// referred by *pqs, if bit i of vector *pv is set.  Also adjust the 
// quadratic form Q inside M. Row 0 is never deleted.
{ 
    uint64_t *m = pqs->data, mask, v = *pv;
    int_fast32_t i, k, sh, row_pos, shifted = 0;
    if (bad_state(pqs)) return -1;
    row_pos= 1;
    while ((v & (ONE << row_pos)) == 0 && row_pos < pqs->nrows) ++row_pos;
    for (i = row_pos; i < pqs->nrows; ++i) {
        if ((v >> i) & 1) continue;
        m[row_pos] = m[i];
        sh = i - row_pos - shifted;
        if (sh) {
            mask = ((ONE << pqs->ncols) << row_pos) - 1;
            for (k = 0; k < pqs->nrows; ++k) 
                m[k] = (m[k] & mask) | ((m[k] >> sh) & ~mask);
            shifted += sh;
        }
        ++row_pos;
    }
    pqs->nrows = row_pos;
    return 0; 
} 









int32_t qbstate12_insert_rows(qbstate12_type *pqs, uint32_t i, uint32_t nrows) 
// Insert 'nrows' zero rows into state matrix M referred by *pqs, 
// starting before row i. The corresponding zero columns for the 
// quadratic form Q inside M are also inserted.  1 <= i < nrows must 
// hold. This process multiplies the state vector by the scalar
// 2**nrows.
{ 
    int_fast32_t k; 
    uint64_t *m = pqs->data, mask; 
    if (bad_state_more_rows(pqs, nrows) || i == 0) return -1;
    for (k = pqs->nrows - 1; k >= i; --k)  m[k + nrows] = m[k]; 
    for (k = i + nrows - 1; k >= i; --k) m[k] = 0; 
    mask = ((ONE <<  pqs->ncols) << i) - 1; 
    for (k = 0; k < pqs->nrows + nrows; ++ k) 
        m[k] = (m[k] & mask) |  ((m[k] & ~mask) << nrows); 
    pqs->nrows += nrows;
    return 0;
}

int32_t qbstate12_row_op(qbstate12_type *pqs, uint32_t i1, uint32_t i2) 
// Add row i1 to row i2 of the state matrix M referred by *pqs. The 
// corresponding column of the quadratic form Q inside M is adjusted.
// This operation does not change the state.
{
    int_fast32_t k; 
    uint64_t *m = pqs->data, v1 = ONE << i1, v2; 

    // See comment after this function for mathematical background.

    // Check input parameters
    if (bad_state(pqs) || i1 == 0 || i1 == i2 || bad_row(pqs, i1)
                       || bad_row(pqs, i2)) return -1;

    v1 = m[i1] >> pqs->ncols; // this is row i of the form Q
    v2 = ONE << i2;           // bit mask for the row to be changed 

    // Negate factor (i.e. global phase) if i2 == 0 and  Q[i1,0] == 1. 
    pqs->factor ^=  v1 & v2 & 1;

    // Add row i1 to row i2
    m[i2] ^= m[i1];
    // Special treatment for row 0, see explanation after function
    m[0] ^= (v1 & v2) << pqs->ncols;

    // Adjust columns of form Q
    for (k = 0; k < pqs->nrows; ++k) {
        m[k] ^= ((v2 & -((v1 >> k) & ONE)) ^ (((v1 & v2) >> k) & ONE))
               << pqs->ncols;
    }

    m[0] &= ~(ONE << pqs->ncols); // In any case put Q[0,0] = 0.
    return 0;
}

/*************************************************************************
Updating the quadratic form Q of a state vector

Recall that we implement the quadratic form Q as symmetric matrix, where
the entries of Q are integers modulo 4. The off-diagonal entries of 
matrix Q are known modulo 2 only, but we always have Q[i1,i2] = Q[i2,i1] 
(modulo 4). The elementry operation in function qbstate12_row_op()
means adding row i1 to row i2 of Q and also adding column i1 to 
column i2 of Q. For the off-diagonal elements this is equivalent to a 
row and column operation on a binary matrix. The story is a bit more
complicated for the diagonal elements. Here we have:

     Q[i2, i2] <-  Q[i2, i2] + Q[i1, i1] + 2 * Q[i1, i2]  (mod 4).

For any  0 <= i,j < nrows let  let Q[i,i] = 2*qh_i + q_i_i,  and
Q[i,j] = q_i_j,  for bits qh_i, and q_i_j equal to 0 or 1. Then the  transformation of Q[i2, i2] given above may be written as:

    qh_i2    <-  qh_i2 ^ qh_i1 ^ q_i1_i2 ^ (q_i1_i1 & q_i2_i2);
    q_i2_i2  <-  q_i2_i2 ^ q_i1_i1;
    q_i2_j   <-  q_i2_j ^ q_i1_j,        for j != i2;
    q_i_j    <-  q_i_j,                  for i != i2, j != i2;
    qh_i_i   <-  qh_i_i,                 for i != j2;

where bit operations '^' and '&' are as in the C language. This means 
that a matrix with entries q_i_j, 0 <= i,j < nrows,  transforms as a 
bilinear form over the binary field. Using the bit operations on a
computer, such a transformation can easily be implemented; and we are 
left with just the computation of the additional bit qh_i2.

In the case of the real Clifford group (which we have implemented here),
there is a further simplification, namely, that all bits q_i_i are zero.

Note that row 0 of our symmetric matrix Q corresponds to a ancilla
qubit with fixed value 1. Mathematically this means that we have to
compute Q(v) = v**t * Q * v for vectors v with component v[0] = 1 only. 
We have seen that flipping the two bits qh_i and q_0_i (with q_i_0 
identical to q_0_i) simultaneously does not change the value Q(v) for 
any such vector v. So for i2 > 0 we need not store the bit qh_i2, and 
we flip bit q_0_i2 whenever the bit qh_i2 is to be flipped. 

We remark that flipping bit qh_0 corresponds to a global phase change 
by an angle of pi (or to multiplication of the unitary matrix 
represented by A and Q with -1). This done by updating component 
'factor' of the structure referring to A and Q. Similarly, changing
q_0_0 means multiplying the global phase by sqrt(-1) or -sqrt(-1). 

This explains the mathematical theory behind the row/column operations
on the quadratic form Q in function qbstate12_row_op() and also in 
function qbstate12_pivot(). The implementations of these two functions 
are still  a bit tricky. Note that in these two functions the relevant 
bits q_i_j of matrix Q are given as follows:

     q_i_j = (m[i] >> (pqs->ncols + j)) & 1,  where m = pqs->data .

For matrix A, with A[i,j] given by A[i,j] = (m[i] >> j) & 1, the 
function qbstate12_row_op() simply adds row i1 to row i2. Here 
addition means '^', i.e. bitwise addition modulo 2.
*************************************************************************/






/*************************************************************************
*** Pivoting a state and reducing it to (reduced) echelon form
*************************************************************************/


int32_t qbstate12_find_pivot(qbstate12_type *pqs, uint32_t j, uint64_t *pv)
// Let M be the state matrix referred by *pqs. On input j, the 
// function returns the highest row index i such that m[i,j] = 1. 
// Also, for all i1 <= i, it writes m[i1,j] to bit i1 of the vector 
// referred by pv.
{
    uint64_t *m = pqs->data,  mask; 
    int_fast32_t i = pqs->nrows - 1, i1; 

    if (bad_state(pqs) || bad_col(pqs, j)) return -1;

    // find the  highest row index i such that m[i,j] = 1. 
    mask = ONE << j;
    while (i > 0  && ((m[i] & mask) == 0)) -- i;
    
    *pv = 0;
    for (i1 = 0; i1 <= i; ++i1) *pv |= ((m[i1] >> j) & ONE) << i1;

    return i;
}




int32_t qbstate12_pivot(qbstate12_type *pqs, uint32_t i, uint64_t *pv)
// Pivot the state matrix M referred by *pqs. The pivoting process is
// controlled by the vector v referred by pv. If i1 < i and bit i1 of
// v is set  then row i of matrix M is xored to row i1 of M. The 
// columns of the form Q inside M are also adjusted. Function returns 0.
// 1 <= i < pqs->nrows must hold. Pivoting does not change the state. 
{
    uint64_t *m = pqs->data, v1, v2; 
    int_fast32_t k; 

    // Check parameters
    if (bad_state(pqs) || bad_row(pqs, i) || i == 0) return -1;

    // Here pivoting means adding row i of A and Q to all rows i2, 
    // where (pv[0] >> i2) & 1 == 1. Of course, columns of Q are 
    // processed appropriately, as in function qbstate12_row_op(). 
    // See comment after function qbstate12_row_op() for mathematical
    // background. 

    v1 = m[i] >> pqs->ncols;        // this is row i of the form Q
    v2 = pv[0] & ((ONE << i) - 1);  // bit mask for rows to be changed 
    if (v2 == 0) return 0;          // nothing to do if v2 == 0

    // Negate factor (i.e. global phase) if i2 == 0 and  Q[i1,0] == 1. 
    pqs->factor ^=  v1 & v2 & 1;

    // Pivot rows with row i
    for (k = i - 1; k >= 0; --k) m[k] ^= m[i] & -((v2 >> k) & ONE);   
    // Special treatment for row 0
    m[0] ^= (v1 & v2) << pqs->ncols;
 
    // Adjust columns of form Q
    for (k = 0; k < pqs->nrows; ++k) {
        m[k] ^= ((v2 & -((v1 >> k) & ONE)) ^ (((v1 & v2) >> k) & ONE))
               << pqs->ncols;
    }

    m[0] &= ~(ONE << pqs->ncols);  // In any case put Q[0,0] = 0
    return 0;
}


int32_t qbstate12_sum_up_kernel(qbstate12_type *pqs)
// Sum up the kernel of the transformation matrix A
// We assume that A is reduced in the sense that all nonzero rows of 
// A are linear independent and that they occur before the zero rows.
{
    uint64_t *m = pqs->data, mask = (ONE << pqs->ncols) - 1, v;
    uint64_t deleted = 0;
    uint_fast32_t i, n;

    // Sum up rows where A is zero
    for (n = pqs->nrows - 1; n > 0 && (m[n] & mask) == 0; --n) {
        if ((deleted & (ONE << n)) == 0) {
            i = qbstate12_find_pivot(pqs, pqs->ncols + n, &v);
            if (i < 0) return -1;
            pqs->factor += 4;
            if (i) { 
                if (qbstate12_pivot(pqs, i, &v)) return -1;
                v = m[i] >> pqs->ncols;  // row or column i of Q         
                if (qbstate12_pivot(pqs, n, &v)) return -1;
                deleted |= ONE << i;
            }  else if ((m[n] >> pqs->ncols) & 1) {
                return pqs->nrows = pqs->factor = 0; // i.e. state = 0
            } 
        }
        --(pqs->nrows);
    }
    // Kill the deleted rows of A
    if (qbstate12_del_rows(pqs, &deleted) < 0) return -1;
    // printf("xs12 matrix kernel reduction successful\n");
    return 0;
}

/*************************************************************************
Summing up the kernel of the transformation matrix A

Assume that the higest row A[n] of A is zero. Assume further that there
is an i > 0 with Q[i,n] != 0, and that i is the highest such n. Then we 
first add row n to all rows of Q where Q[i,n]= 0. This means pivoting 
column n of Q with row i of Q, and also doing the appropriate row 
operations on A. After pivoting Q loos like this:

      x ... x  ... 0  (0)
        ... x  ... 0          Here we have drawn rows and columns 0,
      x xxx x  xxx 1  (i)     i and n of Q completely, and x denotes
        ... x  ... 0          a bit with an unknown value
      0 000 1  000 x  (n)

Depending on the symmetric matrix after pivoting column n, we have
the following cases:

Case 1: Q[n,n] != 0.

In this case (which does not occur in the real Clifford group) we have 
Q[n,n] = 1, Q[j,n] = 0 for j < n, and hence
Q((v,0)) = sqrt(-1) * Q((v,1)) for any v in F_2**(n). Thus
Q((v,0)) + Q((v,1)) = (1 + sqrt(-1)) * Q((v,0)). So we may delete row n
of A and Q, and column n of Q, and multiply the state vector with  
1 + sqrt(-1). This operation does not change the state vector.

Case 2: For some i with 0 < i < n we have  Q[i,n] != 0.

In this case we pivot column i of Q in the same way as column n has
previously been pivodetd, so that we obtain:

      x ... x  ... 0  (0)
        ... 0  ... 0          Since we might have changed row and column
      x 000 0  000 1  (i)     i, we cannot control bit Q[0,i], due to 
        ... 0  ... 0          the effect of the operation in the comment
      0 000 1  000 0  (n)     after function qbstate12_row_op(). 

Case 2a:  There is a 0 < i < n, such that row A[i] is zero

Then we have to sum over the 4 possible combinations of bit i and bit 
n of vector v. This amounts to computing the sum of (-1)**(i*n + i*x)
for all i, n = 0,1. Clearly, this sum is equal to 2 for any x = 0,1. 
So we may delete rows i and n of A and Q, and also  the corresponding
columns of Q, and multiply the state vector by 2, without changing the 
state vector.

Case 2b:  There is no 0 < i < n, such that row A[i] is zero

Thn there is an i with  Q[i,n] = 0 and row i of A is nonzero.
In this case we have Q((v,0)) = Q((v,1)) if bit i of vector v in
F_2**(n) is zero and  Q((v,0)) = -Q((v,1)) is that bit is equal to one. 
So these values sum up to two, if bit i of v is zero, and they cancel
otherwise. So we may delete row i, since the sum is 0 whenever bit i 
of v is set, without changing the state vector. After deleting that 
row, we have   Q((v,0)) = Q((v,1)), so that we may also delete row Q 
and multiply the state vector by 2, Thus, computationally, Case 2b is 
treated exactly in the same way as Case 2a.  

Case 3: There is no i with 0 < i < n such that Q[i,n] != 0.

Then matrix Q looks as follows:

       x  xxx y  (0)     Here we have drawn rows and columns 0 and n
       x  ... 0          completely, and the operation to be done
       y  000 0  (n)     depends on the bit y = Q[0,n] = Q[n,0].
 
Case 3a: After pivoting column n, the bit Q[0,n] is zero

Then Q((v,0)) = Q((v,1)) for all v. Thus we may delete row Q 
and multiply the state vector by 2.

Case 3b: After pivoting column n, the bit Q[0,n] is one

Then Q((v,0)) = -Q((v,1)) for all v, where bit 0 of v is equal to one.
Bit 0 of v corresponds to an ancilla qubit with fixed value 1. So the 
terms Q((v,0)) and Q((v,1)) cancel in all relevant cases. In this case 
the state vector must be set to zero.

*************************************************************************/


// Submatrix A of matrix M of the state referred by pqs is converted  
// to reduced row echelon form, see
// https://en.wikipedia.org/wiki/Row_echelon_form
// The zeros rows in that form describe a constant scalar factor, which 
// is a (possible negated) power of the square root of two. So we
// eliminate the zero rows and update the scalar factor in the state   
// structure appropriately. Obviously, this does not change the state.
int32_t qbstate12_reduce(qbstate12_type *pqs)
{
    int_fast32_t col_pos = 0, row_pos = 1; 
    uint64_t *m = pqs->data;
    if (bad_state(pqs)) return -1;  // abort if matrix is bad
    if (pqs->nrows == 0) return 0;  // nothing to do if matrix is 0

    // Kill unused rows of A and Q
    {
        uint64_t mask = (ONE << (pqs->ncols + pqs->nrows)) - 1;       
        while (pqs->nrows > 1  &&  (m[pqs->nrows - 1] & mask) == 0) {
            mask >>= 1; pqs->factor += 4; --pqs->nrows;
        }
    }
    // printf("Convert submatrix A to echelon\n");
    // Convert submatrix A of M to reduced echelon form
    while (col_pos < pqs->ncols && row_pos < pqs->nrows) {
        // pivot with column col_pos, advance row_pos if success
        uint64_t v;
        int_fast32_t i = qbstate12_find_pivot(pqs, col_pos, &v);
        if (i < 0) return -1;
        // printf("%d, %d, %d\n", col_pos, row_pos, i); 
        if (i >= row_pos) {
            if (qbstate12_pivot(pqs, i, &v)) return -1;
            if (qbstate12_xch_rows(pqs, i, row_pos++)) return -1;
        }
        ++col_pos;
    }

    // printf("Sum up kernel of A\n");     
    return qbstate12_sum_up_kernel(pqs);
}



/*************************************************************************
*** Try to set a 'reference point' for a quadratic state
*************************************************************************/



int32_t qbstate12_set_ref_point(qbstate12_type *pqs, uint32_t v, uint32_t ncols) 
// Adjust representation of state vector (*pqs) to 'reference point' v 
// if possible. This means that row vector 0 of the state  A contained 
// in (*pqs) is  equal to v. Here only the first ncols columns of A[0] 
// and v are adjusted to be equal. The function returns 0 if such an
// adjustement is impossible. Otherwise is returns number n > 0, such
// that only bits j for j < ncols are set in row vector A[i] in case
// 1 <= i < n. In case i >= n also bits j for j >= ncols are set.
{
    uint64_t *m = pqs->data; 
    uint_fast32_t row_pos = 1, col_pos = 0, op;

    ncols = ncols < pqs->ncols ? ncols : pqs->ncols;
    // Reduce matrix to row echelon form; return 0 if matrix is 0
    if (qbstate12_reduce(pqs) < 0) return -1;  
    if (pqs->nrows == 0) return 0;         //   abort if matrix is 0

    // Try to set bit i of m1[0] to bit i of v, for 0 <= i < pqs->ncols
    for (col_pos = 0; col_pos < ncols; ++col_pos) {
        // Set op = True if row op with row (row_pos) is possible
        op = (row_pos < pqs->nrows) && ((m[row_pos] >> col_pos) & 1);
        if (((v ^ m[0]) >> col_pos) & 1) { // if row op required:
             if (!op) return 0;            //   abort if can't do it
                                           //   otherwise do row op
             if (qbstate12_row_op(pqs, row_pos, 0)) return -1;  
        }
        if (op) ++row_pos;     // if op: row_pos used up for row op
    }
    return row_pos;
} 



/*************************************************************************
*** Apply a gate to a state
*************************************************************************/

int32_t qbstate12_gate_x(qbstate12_type *pqs, uint32_t j)
// Apply an X (i.e. NOT) gate to qubit j
{
    uint64_t *m = pqs->data;
    if (bad_state(pqs) || j >= pqs->ncols) return -1;
    if (pqs->nrows == 0) return 0;
    // Here we simply flip the bit A[0,j] 
    m[0] ^= ONE << j;
    return 0;
}

int32_t qbstate12_gate_cx(qbstate12_type *pqs, uint32_t j, uint32_t j1)
// Apply an CX (i.e. CTRL NOT) gate to qubit j, controlled by qubit j1
{
    uint64_t *m = pqs->data;
    uint_fast32_t i;
    if (bad_state(pqs) || j >= pqs->ncols || j1 > pqs->ncols
        || j == j1) return -1;
    if (pqs->nrows == 0) return 0;
    // Here we simply  XOR column j1 of A to column j 
    for (i = 0; i < pqs->nrows; ++i) 
        m[i] ^= ((m[i] >> j1) & ONE) << j;

    // pivot the changed column j (
    //i = qbstate12_find_pivot(pqs, j, &v);
    //if (i > 0)  qbstate12_pivot(pqs, i, &v);
    return 0;
}

int32_t qbstate12_gate_z(qbstate12_type *pqs, uint32_t j)
// Apply an Z (i.e. phase pi) gate to qubit j
{
    uint64_t *m = pqs->data, v1 = 0;
    uint_fast32_t i, i1, imin;
    if (bad_state(pqs) || j >= pqs->ncols) return -1;
    if (pqs->nrows == 0) return 0;
    // Explanation of operation see comment below qbstate12_gate_cz()
    i1 = qbstate12_find_pivot(pqs, j, &v1);
    pqs->factor ^= (v1 & 1);  v1 &= ~ONE;
    m[0] ^= v1 << pqs->ncols;
    imin = 0; 
    while (((v1 >> imin) & 1) == 0 && imin <= i1) ++imin;
    for (i = imin; i <= i1; ++i) 
         m[i] ^= ((v1 >> i) & ONE) << pqs->ncols; 
    return 0;
}


int32_t qbstate12_gate_cz(qbstate12_type *pqs, uint32_t j1, uint32_t j2)
// Apply an CZ gate (i.e. contolled phase pi) gate to qubits j1, j2
// This means that we change the global phase by pi if both qubits,
// j1 and j2 are set. This is symmetric in j1 and j2.
{
    uint64_t *m = pqs->data, v1 = 0, v2 = 0;
    uint_fast32_t i1, i2, imin, i;
    if (bad_state(pqs) || j1 >= pqs->ncols || j2 >= pqs->ncols) 
        return -1;
    if (pqs->nrows == 0) return 0;
    // Explanation of operation see comment below
    i1 = qbstate12_find_pivot(pqs, j1, &v1); 
    i2 = qbstate12_find_pivot(pqs, j2, &v2);
        // Now v1 and v2 are columns j1 and j2 of matrix A

    // Next put Q[k1,k2] +=  A[k1,j1] * A[k2,j2]
    imin = 0; 
    while (((v1 >> imin) & 1) == 0 && imin <= i1) ++imin;
    for (i = imin; i <= i1; ++i) 
         if ((v1 >> i) & 1) m[i] ^= v2 << pqs->ncols;

    // Next put Q[k1,k2] +=  A[k1,j2] * A[k2,j1]
    imin = 0; 
    while (((v2 >> imin) & 1) == 0 && imin <= i2) ++imin;
    for (i = imin; i <= i2; ++i) 
         if ((v2 >> i) & 1) m[i] ^= v1 << pqs->ncols;

    // Next put  Q[k1,0] = Q[0,k1] = Q[0,k1] +  A[k1,j1] * A[k1,j1],
    // and negate global factor if A[0,j1] * A[0,j2] = 1.
    v1 &= v2;
    pqs->factor ^= (v1 & 1);  v1 &= ~ONE;
    m[0] ^= v1 << pqs->ncols;
    for (i = imin; i <= i1; ++i) 
         m[i] ^= ((v1 >> i) & ONE) << pqs->ncols; 
    return 0;
}



/*************************************************************************
Applying a Z or CZ gate to a state

Applying an CZ gate to the qubits j1 and j2 of a state qs means to negate 
all entries of the state vector where both qubits, j1 and j2 are equal to
one. Ignoring the global scalar factor in (1), our state qs is given as
a sum of classical states by 

   qs = sum_{x in  F_2**n}  f(x) * |x>,  where

   f(x) =  sum_{y in F_2**m: A(y) = x} Q(y) ,   

for the quadratic state mapping  f: F_2**n -> CC  given by (1). Here (1)
is as in the comment at the beginning of the module. So we have
to negate all terms of that sum where A(y) is in K, with K the
linear subset of entries x in F_2**n, such that both qubits j1 and j2 
of x are set to one.  

Let A[j1] and A[j2] be the j1-th and the j2-th column vector of submatrix 
A of the state. A(y) is in K if (A[j1],y) = (A[j2],y) = 1, with (.,.) the 
scalar product in  F_2**m. So we have

   (A[j1],y) = (A[j2],y) = 1  <==>   (A[j1],y) * (A[j2],y) = 1
                              <==>
       sum_{0 <= k1,k2 < m}  A[k1,j1] * A[k2,j2] * y[k1] *y[k2] = 1,

with y1 = y1[0],...,y1[m-1], y2 = y2[0],...,y2[m-1], and A[k,j] the
entry of A in row k and column j.  The sum in the last line is a 
quadratic form Q1 on F_2**m. Adding that quadratic form to the quadratic 
form Q on F_2**m (modulo 2) achieves the required phase changes for 
the given CZ operation. So we have to replace Q by Q + Q1.

Therefore we put 

   Q[k1,k2] = Q[k1,k2] + A[k1,j1] * A[k2,j2] + A[k1,j2] * A[k2,j1]. 

This achieves the required addition Q = Q + Q1 for all off-diagonal
elements of Q with k1 != k2. For the diagonal elements of Q these two
additions modulo 2 cancel. The diagonal entries of Q have to be
modified as follows:

    Q[k1,k1] = Q[k1,k1] + 2 * A[k1,j1] * A[k1,j2]   (mod 4)

According to our general philosophy discussed at the beginning of
the module, we may replace the last operation by

    Q[k1,0] =  Q[0,k1] = Q[0,k1] +  A[k1,j1] * A[k1,j1] (mod 2)

for k1 > 0. The operation  Q[0,0] = Q[0,0] + 2 * A[0,j1] * A[0,j2]
is equivalent to negating the global scalar factor of the matrix,
if A[0,j1] * A[0,j2] = 1.

An unconditional Z gate is applied to j1 as follows:
We simply set the column vector A[j2] to (1,0,...,0). This is justified
by the fact that row 0 of matrices A and Q corresponds to an ancilla
qubit with fixed value 1. 

*************************************************************************/






int32_t qbstate12_gate_h(qbstate12_type *pqs, uint32_t j)
// Apply an Hadamard gate to qubit j
{
    uint64_t *m = pqs->data, v;
    uint_fast32_t i, ix;
    if (bad_state(pqs) || j >= pqs->ncols) return -1;
    if (pqs->nrows == 0) return 0; // nothing do do for zero state

    // Reduce if short of space
    if (pqs->nrows >= pqs->maxrows - 2) {
        if (qbstate12_reduce(pqs) < 0) return -1;
    }

    // Find highest row i with A[i,j] != 0
    i = qbstate12_find_pivot(pqs, j, &v);
    // Append a zero row to A and Q and a zero column to Q.
    // Let ix be the index of the new appended row.
    if (qbstate12_insert_rows(pqs, ix = pqs->nrows, 1) < 0)
            return -1;
    // If i > 0: Pivot with row i. Afterwards, A[i,j] is
    // the only possibly nonzero value in column j of A.
    if (i > 0 &&  qbstate12_pivot(pqs, i, &v) < 0) return -1;
    // Set Q[i,ix] = Q[ix,i] = A[i,j].
    Xor_Q_i1_i2(m, pqs->ncols, m[i] >> j, i, ix);
    // Zero entry A[i,j]
    m[i] &= ~(ONE << j);
    // Set entry A[ix,j] to one, in the new row ix.
    m[ix] |= (ONE << j);

    // reduce result if it has too many rows
    if (pqs->nrows > ((3 * pqs->ncols) >> 1) + 1) {
        if (qbstate12_reduce(pqs) < 0) return -1;
    }
    pqs->factor -= 2;  // divide by sqrt(2)
    return 0;
}

// TODO: Make it reasonable or leave it!!!
int32_t qbstate12_gate_h_preserve(qbstate12_type *pqs, uint32_t j)
// Apply an Hadamard gate to qubit j, trying to decrease pqs->nrows
// The function returns 1 if the operation has been done with
// operations preserving the echelon form and possibly the deletion 
// of rows. Otherwise it proceeds exactly as function 
// qbstate12_gate_h(), but with some additional overhead.
{
    uint64_t *m = pqs->data, v = 0;
    uint_fast32_t i, ix;
    if (bad_state(pqs) || j >= pqs->ncols) return -1;
    if (pqs->nrows == 0) return 0; // nothing do do for zero state

    i = qbstate12_find_pivot(pqs, j, &v);

    // Use standard function if short of space, or qubit i not isolated
    if (pqs->nrows >= pqs->maxrows - 2 || i <= 0 || v != (ONE << i)  
        || (m[i] & ((ONE << pqs->ncols) - 1)) != (ONE << j)) {
             return  qbstate12_gate_h(pqs, j);
    } 
    // Append a zero row to A and Q and a zero column to Q.
    // Let ix be the index of the new appended row.
    if (qbstate12_insert_rows(pqs, ix = pqs->nrows, 1) < 0)
            return -1;
    // Set Q[i,ix] = Q[ix,i] = A[i,j].
    Xor_Q_i1_i2(m, pqs->ncols, m[i] >> j, i, ix);
    // Zero entry A[i,j]
    m[i] &= ~(ONE << j);
    // Set entry A[ix,j] to one, in the new row ix.
    m[ix] |= (ONE << j);
    // Exchange row i with the last row ix
    if (qbstate12_xch_rows(pqs, i, ix) < 0) return -1;
    // Last row is in kernel of matrix A, so we sum it up and delete it
    if (qbstate12_sum_up_kernel(pqs) < 0) return -1;
    pqs->factor -= 2;  // divide by sqrt(2)
    return 1;  // Special function has been used successfully
}


/*************************************************************************
Applying a Hadamard operation to qubit j of a state.

We first pivot column j of submatrix A of the state so that, after 
pivoting,  column j of A has at most one nonzero entry in row i. After
pivoting, A(y) is of shape |u,1,u>  iff such an i exists and y[i] = 1. 
Otherwise it is of shape  |u,0,u>. Then we replace matrices A and Q by 
new matrices A' and Q' as follows.

For obtaining A', we first add a new zero row to A and to Q, and we 
copy all entries for the old rows of A' from A. Of course, we also add 
a zero column to the quadratic form Q'. Let ix be the index of the new 
row of A'. Then we put A'[i,j] = 0,  A'[ix,j] = 1, and
Q'[i,ix] = Q'[ix,i] = A[i,j], without changing any other entry of A'.



Proof of correctness
--------------------

As in the previous comment, our state qs is given as a sum of classical 
states by 

   qs = sum_{x in  F_2**n}  f(x) * |x>,  where

   f(x) =  sum_{y in F_2**m: A(y) = x} Q(y) ,           (H_gate 1)

up to a scalar factor. We write  |u,b,u>  for a state where  qubit j
of that state is equal to the bit b, and the other bits are equal to 
a (usually irrelevant) bit vector u. Then our Hadamard gate maps

   
        |u,0,u>  to  (|u,0,u> + |u,1,u>) / sqrt(2) 
  and   |u,1,u>  to  (|u,0,u> - |u,1,u>) / sqrt(2)  .   (H_gate 2)

Let H(s) be the result of this mapping applied to the state s.
In the following description we ignore the factor 1/sqrt(2). 

Case 1: A[i,j] = 1  for exactly one i > 0
-----------------------------------------

For a column vector y in F_2^m let (y,c) the vector in F_2^(m+1)
with entry c in the last row ix, and the same entries as in y in 
the other rows. Then A(y) = |u,b,u>  implies A'(y,0) = |u,0,u>, for 
b = 0, 1, and for all y in F_2**m. This yields the first term 
|u,0,u>  of H(|u,b,u>) in (H_gate 2), for all terms x = |u,b,u> 
occuring in the sum given by (H_gate 1).

It remains to enter the second term (-1)**b * |u,1,u> of H(|u,b,u>) 
in  (H_gate 2) into the sum given by (H_gate 1). By definition of
A' and Q' we have A'[ix,j] = 1, Q'[i,ix] = Q'[ix,i] = 1; and all
other entries in row ix are zero. Thus  A(y) = |u,b,u>  implies 
A'(y,1) = |u,1,u>, and we have  Q'(y,1) = Q(y) * (-1)**b. 

So the term of the state vector obtained from (y,1) is equal to 

   Q(y) * (-1)**b * |u,1,u> ,  

as required by (H_gate 1) and (H_gate 2).

Case  2: A[i,j] = 0  for all i > 0
----------------------------------

Let b = A[0,j]. In case b = 1 the proof of correctness is the same as 
in Case 1, replacing i by 0. In case b = 0, we have A(y) = |u,0,b>.
Then A'(y,0) = |u,0,b>, A'(y,1) = |u,1,b>, and Q'(y,0) = Q'(y,1) = Q(y)
for all y in F_2**m, as required.

*************************************************************************/

 



int32_t qbstate12_gate_xch(qbstate12_type *pqs, uint32_t j1, uint32_t j2)
// Exchange qubit j1 with qubit j2
{
    uint64_t *m = pqs->data, mask = (ONE << j1) ^ (ONE << j2);
    uint_fast32_t k;
    if (bad_state(pqs) || j1 >= pqs->ncols || j2 >= pqs->ncols) return -1;
    if (pqs->nrows == 0 || j1 == j2) return 0;

    // Here we simply exchange row j1 with row j2 of matrix A
    for (k = 0; k < pqs->nrows; ++k) 
        m[k] ^= mask & -(((m[k] >> j1) ^ (m[k] >> j2)) & 1);   
    return 0;
}



/*************************************************************************
*** Tensor contraction of states
*************************************************************************/



int32_t qbstate12_prep_mul(qbstate12_type *pqs1, qbstate12_type *pqs2, uint32_t nqb)
// Prepare the states qs1 and qs2 referred by pqs1 and pqs2 for tensor
// contraction. Here the first nqb columns (corresponding to the first
// nqb qubits) of qs1 and qs2 are to be contacted. The function returns
// a number 'row_pos', so that, after preparation, the first nqb 
// columns of submatrices A1 and A2 of the matrices M1 and M2
// corresponding to qs1 and qs2 will be equal in the following sense: 
// A1[i,j] = A2[i,j]       for i <  'row_pos', j < 'nqb' ,   (QS1)
// A1[i,j] = A2[i,j] = 0   for i >= 'row_pos', j < 'nqb' ,   (QS2)
// and matrices A1 and A2 both have rank 'row_pos' - 1, when excluding
// row 0 of the two matrices.
// Some rows of A1 or A2 may be deleted to achieve this situation.
// The result of the tensor contraction of the states qs1 and qs2 over 
// the first nqb columns of is not changed by this operation.
// Apart from this assertion, both states are changed, and they may
// have less rows than before. They may even be changed to zero, if the 
// result of the contraction is zero.
{
    int_fast32_t i1, i2, col_pos, row_pos = 1, n_deleted = 0;
    uint64_t  v1 = 0, v2 = 0, mask = (ONE << nqb) - 1, deleted = 0;

    // The algorithm used here is explained in the comment below.

    // check and reduce input matrices
    // printf("<prep_mul>");
    if (qbstate12_reduce(pqs1) < 0  || qbstate12_reduce(pqs2) < 0   
         || nqb > pqs1->ncols || nqb > pqs2->ncols) return -1;
    if (pqs1->nrows == 0 || pqs2->nrows == 0)
        return  pqs1->nrows = pqs2->nrows = 0;
    // Equalize the first 'ncols' columns of m1 and m2
    for (col_pos = 0; col_pos < nqb; ++col_pos) {
        // pivot with column col_pos, advance row_pos if success
        i1 = qbstate12_find_pivot(pqs1, col_pos, &v1);
        i2 = qbstate12_find_pivot(pqs2, col_pos, &v2);
        if (i1 >= row_pos) {
            if (i2 >= row_pos) {
                // Pivot matrix 1 with row i1 and exchange row i1 with
                // row 'row_pos'. Next Pivot matrix 2 with row i2 and 
                // exchange row i2 with row 'row_pos'. Then both matrices
                // are zero in column 'col_pos' except for row 'row_pos'.
                if ( qbstate12_pivot(pqs1, i1, &v1) < 0
                    || qbstate12_pivot(pqs2, i2, &v2) < 0
                    || qbstate12_xch_rows(pqs1, i1, row_pos) < 0
                    || qbstate12_xch_rows(pqs2, i2, row_pos) < 0
                    ) return -1;
                ++row_pos; 
            } else if (i2 >= 0) {
                // Pivot with row i1 and so that coulumns 'col_pos' of the
                // matrices are equal except in row i1. Then delete row i1,
                // i.e. put row i1 at last position decrement row counter.
                v1 ^= v2; 
                if (qbstate12_pivot(pqs1, i1, &v1) < 0  ||
                    qbstate12_xch_rows(pqs1, i1, pqs1->nrows-1) < 0)
                    return -1;
                --pqs1->nrows; 
            } else return -1;
        } else if (i1 >= 0) {
            if (i2 >= row_pos) {
                // Pivot with row i2 and so that columns 'col_pos' of the
                // matrices are equal except in row i2. Then delete row i2,
                // i.e. put row i2 at last position decrement row counter.
                v2 ^= v1; 
                if (qbstate12_pivot(pqs2, i2, &v2) < 0  ||
                    qbstate12_xch_rows(pqs2, i2, pqs2->nrows-1) < 0)
                    return -1;
                --pqs2->nrows; 
            } else if (i2 >= 0) {
                // Both matrices are zero in column col_pos except for
                // row 0. Result is 0 if they differ entry [0,col_pos]. 
                // deleted |= v1 ^ v2;
                // if (deleted & 1)  return pqs1->nrows = pqs2->nrows = 0;
                uint64_t v = v1 ^ v2;
                int32_t i = i1 >= i2 ? i1 : i2;
                i2 = 0;
                while (i >= 0 && ((ONE << i) & v) == 0) --i;
                if (i > 0) {
                    if (qbstate12_pivot(pqs1, i, &v) < 0  ||
                        qbstate12_pivot(pqs2, i, &v) < 0 ) return -1; 
                    deleted |= ONE << i; ++n_deleted;
                    pqs1->data[i] &= ~mask; pqs2->data[i] &= ~mask; 
                } else if (i == 0) {
                    return  pqs1->nrows = pqs2->nrows = 0;  
                }                
            } else return -1;
        } else return -1;
    }
    // printf("<almost>");
    if (qbstate12_del_rows(pqs1, &deleted) < 0
      || qbstate12_del_rows(pqs2, &deleted) < 0) return -1;
    row_pos -= n_deleted;


  #ifdef CHECK_QBSTATE12_PREP_MUL
    // The preparation algorithm is a bit involved. So we may check the 
    // conditions for matrices A1, A2 after preparation here.
    // printf("<check>\n");
    deleted = 0;
    for (i1 = 0; i1 < row_pos; ++i1) 
        deleted |= pqs1->data[i1] ^ pqs2->data[i1];
    for (i1 = row_pos; i1 < pqs1->nrows; ++i1) deleted |= pqs1->data[i1];
    for (i1 = row_pos; i1 < pqs2->nrows; ++i1) deleted |= pqs2->data[i1];
    if (deleted & ((ONE << nqb) - 1)) return -1; 
  #endif

    // printf("<done, return %d>\n", row_pos);
    
    return row_pos ;
}




/*************************************************************************
Equating states for tensor contraction in function qbstate12_prep_mul()

Function qbstate12_prep_mul() takes two states qs1 and qs2 and equates 
the first nqb columns, so that they will satify conditions (QS1) and
(QS2) on return of the function.


We focus on the operations on the submatrices A1 and A2 of the states 
qs1 and qs2, which are row operations. These row operations are 
performed by the functions qbstate12_pivot(), qbstate12_xch_rows() and
qbstate12_del_rows(). These functions also process the quadratic forms
Q1 and Q2 contained in the states qs1 and qs2 appropriately, so that 
we need not bother about Q1 and Q2.

In the main loop, a counter 'col_pos' counts from 0 to 'nqs' - 1.
There is also a variable 'row_pos', initalized to one, which markes
the rows of A1 and A2 which have already been processed. 

After the loop iteration with counter = 'col_pos', we claim that the
columns  0, ..., 'col_pos' - 1 of A1 and A2 are equal, and that in all 
rows with index >= 'row_pos', the entries in these columns are zero. 
We also claim that the submatrices of A1 and A2 that consist of rows 
1,...,'row_pos' - 1 and of columns 0,...,'col_pos' - 1 have full rank. 

Entries in rows < 'row_pos' have already been processed. Such rows may 
have nonzero entries and they may no longer be changed independently 
without violating our claim. However, in later iterations of 
the loop we may do row operations on A1 and A2 simultaneously or
delete the same rows of A1 and A2.

In the loop iteration with counter = 'col_pos' we first compute the
index i1 of the highest nonzero bit in column 'col_pos' of A1 and also 
the index i2 of the highest nonzero bit in column 'col_pos' of A2.
The we try to pivot matrices A1 and A2 with these two bits in order
to equate the columns 'col_pos' of the two matrices. The details of
that pivoting process are a bit hairy, since we must maintain the
assertions in our claim for any of the bits in rows with index less
than 'row_pos' of matrices A1 and A2. We consider 4 main cases:

Case 1:  i1 >= 'row_pos',   i2 >= 'row_pos'. 
------
In this case we simply pivot matrix A1 with row i1 and matrix A2 with
row i2, both in column 'col_pos'. After pivoting, all entries of A1 
and A2 in column 'col_pos' are zero, except for A1[i1, col_pos] and
A1[i2, col_pos]. Then we exchange row i1 of A1 with row 'row_pos' and
also row i2 of A2 with row 'row_pos'. Afterwards the columns 
'col_pos' of the matrices A1 and A2 are equal. We increment 'row_pos'
by one to indicate that row 'row_pos' has nonzero entries.

Note that A1[i1, j] = A2[i2, j] = 0 for all j < 'col_pos', so that 
the columns j of of A1 and A2 are not changed for  j < 'col_pos'.
Thus our claim hold for the bits in all columns j < 'col_pos'. 
After pivoting and exchanging rows of A1 and A2, columns 'col_pos'
of A1 and A2 are equal.

After incrementing 'row_pos' and 'col_pos' and exchanging rows, 
matrices A1 and A2 still have full rank, since then we have
A1[row_pos-1, col_pos-1] = A2[row_pos-1, col_pos-1] = 1. 



Case 2:  i1 >= 'row_pos',   i2 < 'row_pos'. 
----
In this case we may pivot matrix A1 with row i1 in column 'col_pos', 
but we may not pivot matrix A2 with row i2 in that column, since 
that pivoting operation may violate our claim. So we pivot A1 with 
row i1 in such a way that  A1[i, col_pos] = A2[i, col_pos] for all i, 
except for i = i1. Then we delete row i1 from matrix A1.
Finally we increment 'col_pos' by one.

This operation does not change columns j of A1 and A2 for 
j < 'col_pos', and, after pivoting, the columns 'col_pos' of matrices
A1 and A are equal. So our claim still holds after this operation. 

Deleting row i1 from matrix A1 is justified as follows:

Note that then we have A1[i, col_pos] = A2[i, col_pos] = 0 for 
i > 'row_pos'. 

Let A1' and A2' be the submatrices of A1 and A2 that consist of the
first 'nqb' columns of A1 and A2, respectively. 

Fact: 
Row i1 of A1' (after pivoting) is not a linear combination of the
other rows of A1' and the rows of A2'.

Proof of the fact:
Let A1*, A2* be the submatrices of A1' and A2' that that consist of
columns 0,...,'col_pos' - 1. By our claim the lowest 'row_pos' - 1
rows of  A1* and  A2* are linear independent and equal, and the
other rows of  A1* and  A2* are zero. Thus any linear combination
of rows of A1' and  A2' that sums up to row i1 of A1 necessarily
consists of the same set of rows  0,...,'row_pos' - 1 of matrices A1' 
and A2', and of an arbitrary set of other rows of A1' and A2'.   
Considering column 'col_pos' of such a linear combination, we see
that the only nonzero terms in that column can come from rows with 
index >= 'row_pos', since the terms coming from row i, i < 'row_pos',
of A1' and A2' cancel.  After pivoting we have 
A1[i, col_pos] = A2[i, col_pos] = 0 for i > 'row_pos' and  
A2[row_pos, col_pos] = 0. Thus the only nonzero term in the set  
{A1[i,'col_pos'],  A2[i,'col_pos'], i >='row_pos'} is A1[i1, col_pos]. 
Hence row i1 of A1' cannot be a linear combination of the other rows 
of A1' or A2'. This proves the fact.


For the required tensor contraction we only have to consider those 
linear combinations of rows of A1' which are equal to any linear 
combination of rows of A2'. Assume that A1' contains a row i1 which 
cannot be expressed as a linear combination of the other rows of A1' 
and the rows of A2'. Then a linear combination of rows of A1' 
containing row i1 cannot be equal to any linear combination of rows 
of A2'. So we may delete row i1 from A1 in that case.


Case 3:  i1 < 'row_pos',   i2 >= 'row_pos'. 
------

This is similar to Case 2, exchanging the role of A1 and A2. 


Case 4:  i1 < 'row_pos',   i2 < 'row_pos'. 
-------
Here we have to consider the following subcases

Case 4.1: columns 'col_pos' of A1 and A2 are equal

In this case we may simply increment 'col_pos' without any other
action; and our claim about the submatrices consisting of rows 
1,...,'row_pos' - 1 and of columns 0,...,'col_pos' - 1 of A1 and A2
remains valid.

Case 4.2: columns 'col_pos' of A1 and A2 are equal except for row 0

In this case we delete all rows from both, A1 and A2, and stop.
This means that we set both states, qs1 and qs2 to zero. 

Since row 0 of A1 or A2 correspond to an ancilla qubit with fixed
value 1, we only have to consider linear combinations of rows of 
A1 or A2 containing row 0. In this case such linear combinations
of rows of A1 and of A2 always differ in column 0. Thus the tensor
contraction of the states qs1 and qs2 is zero in this case. 

Case 4.3: A1[i, col_pos] != A2[i, col_pos] for some i > 0

Let i be the idnex of the highest row with 
A1[i, col_pos] != A2[i, col_pos], and let v be the sum of the column
vectors of A1 and A2 in column 'col_pos' (modulo 2). 

Then we add row i of A1 to all rows j of A1 where v[j] = 1. Similarly,
we add row i of A2 to all rows j of A2 where v[j] = 1. Then we delete
row i in both A1 and also from A2. We also increment 'col_pos'

Clearly, this operation preservs the assertions in our claim. After
these row operations and incrementing 'col_pos', the submatrices of 
A1 and A2 consisting of rows 0, ..., 'row_pos' - 1 and columns
0, ..., 'col_pos' - 1 are equal, with the exception 
A1[i, col_pos] !=  A2[i, col_pos]. A simlar argument as in Case 2
shows that we may delete row i from A1 and A2 without changing
the tensor contraction of the two states qs1 and qs2.
 

Remarks

In Cases 2 and 3 we delete a row from A1 or A2 by exchanging it with
the last row of the matrix and dercementing the number of rows of
the matrix. This operation requires no postprocessing. In case 4 we
delete the same row i from A1 and A2 by marking it for deletion.
Therfore we set bit i in the vector 'deleted'. We also zero the
entries of row i in A1 and in A2 to avoid useless pivoting. At the
end we use function qbstate12_del_rows() to delete the marked rows
from A1 and A2. 
 
*************************************************************************/


int32_t qbstate12_reindex(qbstate12_type *pqs, uint32_t n_del, uint32_t j, uint32_t n_ins)
// Reorder the columns of submatrix A of matrix M of the state referred
// by pqs. We first delete the first n_del columns of matrix A. The we
// insert n_ins zero columns into matrix at position j. So j = 0 means
// insert zero columns at the left-hand side, after deleting columns. 
{
    int32_t k;
    uint64_t *m = pqs->data, v, mask;
    
    k = pqs->ncols - n_del;
    if (n_del > pqs->ncols || bad_state_more_cols(pqs, k) || j > k) 
        return -1;
    mask = (ONE << j) - 1;
    pqs->ncols = pqs->ncols - n_del + n_ins;

    for (k = 0; k < pqs->nrows; ++k) {
         v = (m[k] >> n_del);
         m[k] = (v & mask) | ((v & ~mask) << n_ins);
    }
    return 0;   
}


int32_t qbstate12_rot_index(qbstate12_type *pqs, int32_t rot, uint32_t nrot, uint32_t n0)
// Reorder columns of submatrix A of matrix M of the state referred by pqs. 
// For  n0 < i <= n0 + nrot  we map column i to column  n0 + i % nrot. E.g. 
// nrot = 3, rot = 1, n0 = 0 means columns are mapped as 0->1, 1->2, 2->0.
{
    uint64_t *m = pqs->data, mask_h, mask_l, mask;
    int32_t k, sh;
       
    if (bad_state(pqs) || nrot + n0 > pqs->ncols) return -1;
    if (nrot < 2) return 0;
    if (rot < 0) rot += nrot * (-rot / nrot) + nrot;
    rot %= nrot;
    if (rot == 0) return 0;
    mask_l = (ONE << (nrot + n0 - rot));
    mask_h = (ONE << (nrot + n0)) -  mask_l;
    mask_l -= (ONE << n0);
    mask = ~(mask_l | mask_h);
    sh = nrot - rot;
    for (k = 0; k < pqs->nrows; ++k) {
         m[k] = (m[k] & mask) | ((m[k] & mask_l) << rot) 
                              | ((m[k] & mask_h) >> sh);
    }
    return 0;    
}



int32_t qbstate12_mul_elements(qbstate12_type *pqs1, qbstate12_type *pqs2)
// For the submatrices A1, Q1 and A2, Q2 of the matrices M1 and M2 
// corresponding to qs1 and qs2 we put A1 = A1 + A2, B1 = B1 + B2.
// The number of rows or columns of A2 may not be larger than the
// number of row2 or columns of A2. 
{
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data;
    int32_t k;
    if (bad_state(pqs1) || bad_state(pqs2) || pqs2->nrows != pqs1->nrows
        || pqs2->ncols != pqs1->ncols) return -1; 
    for (k = 0; k < pqs1->nrows; ++k)  m1[k] ^= m2[k];
    pqs1->factor += pqs2->factor &  ~ONE;
    pqs1->factor ^= pqs2->factor &  ONE;
    return 0;
}






int32_t qbstate12_contract(qbstate12_type *pqs1, qbstate12_type *pqs2, uint32_t nqb)
// Compute tensor contraction of the states qs1 and qs2 referred by
// pqs1 and pqs2. we contract over the lowest nqb qubits of qs1 and
// over the lowest nqb qubits of qs2. The result is returned in qs1.
// qs2 is destroyed.  
{
    int32_t row_pos = qbstate12_prep_mul(pqs1, pqs2, nqb);
    int32_t cols1 = pqs1->ncols - nqb, cols2 = pqs2->ncols - nqb;
    int32_t rows1 = pqs1->nrows - row_pos, rows2 = pqs2->nrows - row_pos;
    if (row_pos < 0) return -1;
    if (pqs1->nrows == 0 || pqs2->nrows == 0) {
        pqs1->ncols += pqs2->ncols - nqb - nqb;
        return pqs1->nrows = pqs1->factor = 0; 
    }

    if (qbstate12_reindex(pqs1, nqb, cols1, cols2) < 0
          || qbstate12_reindex(pqs2, nqb, 0, cols1) < 0
          || qbstate12_insert_rows(pqs1, pqs1->nrows, rows2) < 0 
          || qbstate12_insert_rows(pqs2, row_pos, rows1) < 0
          || qbstate12_mul_elements(pqs1, pqs2) < 0
          || qbstate12_reduce(pqs1) < 0
          )  return -1;
    return 0;
}




/*************************************************************************
*** Expanding a state vector modulo a prime p
*************************************************************************/

static volatile uint16_t p_table[2][2];
// table[i][0] = p, table [i][1] = sqrt(2) % p for valid entries
// table [i][0] = 0 vor invalied entries i of the table

static volatile unsigned int last_recent_p_index;
// 0 < last_recent_p_index < 2 indicates the last recently used value p

#define BLK 0x1000

static volatile unsigned int block_p_table;
// block_p_table >= 1 means that table is blocked for writing.
// block_p_table >= BLK means that table is blocked for reading and writing.


static uint32_t u_modexp(uint32_t a, uint32_t e, uint32_t p)
// Return a**e % p. p > 0 must hold
{
    if (e > 1) {
        uint32_t x = u_modexp(a % p, e >> 1, p);
        x = ((uint64_t)x * (uint64_t)x) % p;
        return  (e & 1) ? ((uint64_t)x * (uint64_t)a) % p : x; 
    }
    return e ? a : 1;
}

static int32_t sqrt2modp(uint32_t p)
// Return smallest square root of 2 mod p if it exists and p < 0x10000.
// Otherwise return -1.
{
    uint_fast32_t x = 2, d = 3, i;

    if (p >= (1 << 16) || (p & 1) == 0) return -1; // cannot compute square root

    // Try to read sqrt(2) mod p from table p_table. We try to make this
    // thead safe in the sense that no invalid data are read from the table.
    block_p_table += 1;          // block table p_table for writing
    if (block_p_table < BLK) {   // if nobody else has blocked for reading:
        for (i = 0; i < 2; ++i) if (p_table[i][0] == p) {
            x = p_table[i][1];   // read square root from table if present
            last_recent_p_index = i;  // mark index last recently used
            block_p_table -= 1;  // unblock and set p as last recently used
            return x;            // return square root from table
        }
    }
    block_p_table -= 1;          // unblock table in all cases

    // Compute square root, since it has not been found in the table
    while (d < p) {
        d += 2;
        x = x + d - p; 
        x += p & (x >> 16);
        if (x == 0) goto success;
    }
    return -1; 

success:
    x = (d >> 1) + 1;           // x is the requested square root
    block_p_table += BLK;       // Block table for reading and writing 
    if (block_p_table == 0) {   // if nobody else has blocked for writing
        // toggle last recently used index and load it to i
        i = (last_recent_p_index = last_recent_p_index ^ 1) & 1;  
        p_table[i][0] = p;      // write p to table ..
        p_table[i][1] = x;      // and also its square root 
    } 
    block_p_table -= BLK;       // unblock
    return x;                   // return square root
}


int32_t qbstate12_factor_modp(int32_t factor, uint32_t p)
// Return (-1)**(p & 1) * sqrt(2)**(p > 1) mod p for 0 < p < 0x10000.
// Return -1 if such a number does not exist or not  p >= 0x10000.
// If needed, take the smallest possible value of sqrt(2) mod p.
{
    int_fast64_t w, f = 1, basis = 2;
    if (p > 0xffff || p <= 0) return -1; 
    f = 1, basis = 2;
    if (factor & 1) {
        f = -f;  factor -= 1;
    }
    if (factor & 2) {
        w = sqrt2modp(p);
        if (w < 0) return -1;
        f *= w; factor -= 2;
    } 
    if (factor < 0) {
        if (p & 1) basis = (p + 1) >> 1;
        else return -1;
        factor = -factor; 
    } 
    f += p * ((-f) / p) + p;
    return f * u_modexp(basis, factor >> 2, p) % p;
}

#2345678901234567890123456789012345678901234567890123456789012345678901234567890


// qbstate12_lsbtab[i] is the position of least significant bit of i | 0x40
const uint8_t qbstate12_lsbtab[64] = {
    6,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    4,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    5,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    4,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0 
};

int32_t qbstate12_expand_b(qbstate12_type *pqs, uint8_t *a, uint32_t p, int32_t f)
// Expand the f * qs where qs is the state referred by pqs to the 
// array a, and reduce all entries of array a modulo p. Depending on 
// the scalar factor in the state pqs, a number 1/2 or sqrt(2) modulo 
// p must exist. 
// Caution: The function sets 2**pqs->ncols bytes in the array a!!
{    
    uint_fast32_t qf = 0, factors[2];
    int_fast32_t w;
    uint64_t mask = (ONE << pqs->ncols) - 1; 
    uint64_t *m = pqs->data;
    uint64_t i, assoc, n_iterations, q_shift = pqs->ncols; 

    if (bad_state(pqs) || p > 256 || p == 0) return -1;
    // put factors[i] = (-1)**(i+1) * f * <factor in pqs> mod p  
    factors[1] = w = qbstate12_factor_modp(pqs->factor, p);
    // printf("w=%d\n", w);
    if (w < 0) return -1;
    factors[0] = ((p - factors[1]) * (f % p + p)) % p;
    // printf("qbstate12_expand_b, p=%d, factor=%d, w=%d\n", p, pqs->factor, w);

    assoc = m[0];
    memset(a, 0, sizeof(uint8_t) << pqs->ncols);
    if (pqs->nrows == 0 || factors[0] == 0) return 0;
    
    n_iterations = ONE << (pqs->nrows - 1);
    for (i = 1; i <= n_iterations; ++i) {
        uint64_t index = assoc & mask, i1 = i;
        uint_fast32_t value = a[index] - factors[qf & 1], d = 0, d1;
        value += (value >> 16) & p; 
        // Now value = (a[index] + factors[f & 1]) % p
        a[index] = value;
        do {
            d1 = qbstate12_lsbtab[i1 & 63];
            i1 >>= 6; 
            d += d1;
        } while (d1 == 6);    
        // printf("expand_b %4d, [0x%03x]<-%3d, f,ass= %d,0x%03x, d=%2d\n",(int)(i-1),  
        //        (int)index,(int)value,(int)(qf&1),(int)(assoc>>q_shift),(int)d);
        assoc ^= m[d+1];
        qf ^=  assoc >> (q_shift + d + 1);
    } 
    return 0;       
}

#ifdef __cplusplus
}
#endif


