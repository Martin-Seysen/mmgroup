/** @file mm_profile_abc_mod3.c

Basic operation of this module

The centralizer of the
fourgroup \f$V_4 = \{1, x_{-1}, x_{\Omega}, x_{-\Omega}\}\f$ in the
Monster is a group \f$N_{xyz}\f$ of structure \f$2^{2+11+22}.M_{24}\f$.
Let \f$N_2 := O_2(N_{xyz})\f$ be the normal subgroup of \f$N_{xyz}\f$
of structure \f$2^{2+11+22}\f$.
Let \f$\rho_3\f$ be the standard 196884-dimensional rational
representation \f$\rho\f$ of the Monster with entries taken modulo 3.
We mainly deal with \f$v \in \rho_3\f$ as that are 2A axes in the
Monster. The purpose of this module is to watermark the orbits
of 2A axes under the action of the group \f$N_{xyz}\f$. We may also
watermark orbits under the action of a few specific subgroups
of \f$N_{xyz}\f$

Given a vector \f$v\f$ as above, the functions in this module first
compute a symmetric \f$24 \times 24\f$ matrix \f$M = M(v)\f$ that is
invariant under the centralizer of \f$v\f$ in \f$N_{xyz}\f$, and also 
under \f$N_2\f$. Here the factor group \f$M_{24} = N_{xyz} / N_2\f$
acts naturally on the space of symmetric \f$24 \times 24\f$ matrices as
a permutation group. As a first step, information from the 
parts 'A', 'B', 'C' of a vector \f$v \in \rho_3\f$ is used to
obtain \f$M(v)\f$. These parts of a vector are described in Section
*The representation of the Monster group* in the *API reference*.
Note that these parts are already symmetric \f$24 \times 24\f$ 
matrices. The group \f$N_{2}\f$ acts on the
triple  ('A', 'B' + 'C', 'B' - 'C') by sign changes; and the factor
group \f$M_{24}\f$ acts on each entry of that triple naturally as a
permutation group on 24 elements, up to sign. By stripping off
sign information and merging the corresponing entries of these matrices
we obtain a first approximation \f$M_0 = M_0(v)\f$ of \f$M(v)\f$ that
is invariant under \f$N_{2}\f$.  By construction \f$M_0(v)\f$ is also
invariant under the centralizer of  \f$v\f$. 

Matrix \f$M_0\f$ can be considered as an undirected
labelled graph, with vertices labelled by the diagonal elements and
edges labelled by off-diagonal elements of \f$M_0\f$. We may refine
the labelling of \f$M_0\f$ by assigning a different label to each
orbit of a vertex or edge under the action of the isomorphism group
of the labelled graph corresponding to \f$M_0\f$. The matrix with such
a refined labelling is still invariant under the action of the 
centralizer of \f$v\f$. Computing the full isomorphism group of the
graph would take too much time; but we may do a few steps in that
direction in order to refine the watermarking. This way we compute a
matrix \f$M = M(v)\f$ that refines the labelling given by \f$M_0\f$.
Details are out of the scope of this documentation; but one may check
the documentation of the subfunctions in this module for more
information.

From \f$M(v)\f$ we also want to compute a data
structure \f$H = H(v)\f$ that watermarks the orbit of \f$v\f$ under
the action of \f$N_{xyz}\f$. For a suitably refined labelled graph
\f$M(v)\f$ we may assume that the multiset of colours of all edges
incident to a vertex depends on the on the colour of that vertex only.
The mapping \f$H\f$ from the set of the colours of the edges to the
multisets of colours of the incident vertices depends on the
isomorphism type of the graph only. Since the isomorphism type of the
graph \f$M(v)\f$ depends on the orbit of \f$v\f$ only, the 
mapping \f$H\f$ can be used as a watermark for the orbit of \f$v\f$.
It turs out that the mapping \f$M(v)\f$ can be stored in a
\f$24 \times 24\f$ matrices matrix.
Here details are out of the scope of this documentation. 


Function ``mm_profile_mod3_load`` computes the triple
('A', 'B' + 'C', 'B' - 'C') from the vector \f$v\f$  of the
representation of the Monster. Function ``mm_profile_mod3_hash``
computes the matrices \f$M(v)\f$ and \f$H(v)\f$ from that triple.
It also computes a 63-bit hash value over the matrix \f$H(v)\f$.


Extensions

From \f$v\f$ we may compute \f$M(w)\f$ and \f$H(w)\f$ for 
\f$w = v \cdot \tau^e x_\delta^f\f$, for any
odd cocode element \f$x_\delta\f$, withour comuting \f$w\f$.
(These matrices are invariant
under \f$x_\delta\f$ for \f$\delta\f$ even).

We may also watermark orbits of \f$v\f$ under the action of a
few fixed subgroups of \f$N_{xyz}\f$. 


Warning
 
The functions in this module may differ between versions!

They are desigend for the internal needs of the *mmgroup* package.
*/



/// @cond DO_NOT_DOCUMENT
#include <string.h>

#include "mat24_functions.h"
#include "mm_basics.h"
#include "mm_op_p.h"
#include "mmgroup_generators.h"
#include "clifford12.h"
#include "mm_reduce.h"   
/// @endcond

   




//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c




/************************************************************************
** Loading parts of a vector with function ``mm_profile_mod3_load`` 
************************************************************************/

/// @cond DO_NOT_DOCUMENT

/************************************************************************

Function ``mm_profile_mod3_load`` loads entries of a vector \f$v\f$ of
the representation of the Monster into an array ``a`` of length 72. For
the end user the structure of the array is opaque and hence undocumented.
The information loaded from vector \f$v\f$ corresponds to the 
triple  ('A', 'B' + 'C', 'B' - 'C') , where 'A', 'B' and 'C' are
24 times 24 subarrays of vector `\f$v\f$ as documented in Section
*The representation of the Monster group* in the *API reference*.
All entries are stored modulo 3.

In the documentation of this file, the triple  ('A', 'B'+'C', 'B'-'C')
loaded into array ``a`` will be called a *block*.

Internally, the function stores parts 'A' of the 
vectors \f$v \cdot\tau^e\f$, for  \f$e = 0, 1, 2\f$ (modulo 3)
in the array referred by ``a``. Throughout this file we 
abbreviate the part 'A' of  \f$v \cdot\tau^e\f$ stored in a block
referred by ``a`` to ``A[e;]``. We write ``A[e;i,j]`` for
entry ``i,j`` of  ``A[e;]``.

In the block ``a`` the entry ``A[e;i,j]``is stored in bits
``(2*j+1, 2*j)`` of entry ``a[24*e + i]``. Such an entry is also
called a *dibit*.
/
************************************************************************

/// @endcond 


/************************************************************************
** Auxiliary functions 
************************************************************************/

/// @cond DO_NOT_DOCUMENT 

/** 
  @brief Reduce dibits in the array ``a`` of length 72 modulo 3.
*/
static inline void _reduce(uint64_t *a) {
    uint64_t w, i;
    for (i = 0; i < 72; ++i) { 
        w = (a[i] & (a[i] >> 1)) & 0x5555555555555555ULL;
        a[i] = (a[i] ^ w ^ (w << 1)) & 0xffffffffffffULL;
    }
}



/** 
  @brief Re-encode dibits in the 64-bit integer ``w``.

  Dibits are mapped as 00 -> 00, 01 -> 01, 10 -> 11, 11 -> 00.
  Thus, modulo 3, the low bit acts as a 'nonzero' flag, and the
  high bit acts as a 'negative' flag. 

  The macro uses a temporary 64-bit integer ``t``.
*/
#define adjust_sign(w, t) \
    t = w & (w << 1) & 0xaaaaaaaaaaaaaaaaULL; \
    w = w ^ ((w >> 1) & 0x5555555555555555ULL) ^ t  



/** 
  @brief Load parts ABC of representation of Monster modulo 3

  Let ``v`` point to a vector of the representation \f$\rho_{p}\f$
  of the Monster, with \f$p\f$ given by parameter ``p``. The function
  load parts 'A', 'B', and 'C' of that vector (in that order) into
  the vector of length 3 * 24 referred by ``a``. Entries of
  vector ``a`` are encoded as in representation  \f$\rho_{3}\f$.
  The function returns 0 in case of success and -1 in case of failure.
 
*/
static inline int32_t
mm_profile_mod3_load_abc(uint32_t p, uint_mmv_t *v, uint64_t *a)
{
    uint64_t m[3*24], i, len24 = mm_aux_v24_ints(p);
    if (len24 == 0 || len24 > 4) return -1;
    for (i = 0; i < 3 * 24; i += 24) {
        if (mm_op_load_leech3matrix(p, v + i*len24, m) < 0) return -2;
        leech3matrix_compress(m, m);
        memcpy(a + i, m, 24 * sizeof(uint64_t));
    }
    _reduce(a);
    return 0;
}




/// @endcond 

/************************************************************************
** Load part A, B, C mod 3 from vector of representation of Monster
************************************************************************/




/** 
  @brief Load parts of a representation representation of the Monster

  Let ``v`` point to a vector of the representation \f$\rho_{p}\f$
  of the Monster, with \f$p\f$ given by parameter ``p``. The function
  load  triple of the parts ('A', 'B+C', 'B-C')  of that vector into
  the array length 72 referred by ``a``, as described in the
  header of this file.
  The function returns 0 in case of success and -1 in case of failure.
  Legal values for \f$p\f$ are 3 and 15.

  A nonzero value ``t`` is interpreted as follows:
  Before loading the vector ``v``, multiply it with \f$\tau^f\f$,
  where \f$f\f$ is ``(t / 2) & 3``. If ``t`` is odd then multiply ``v``
  with \f$x_\delta\f$ afterwards, where  \f$\delta\f$ is any odd
  Golay cocode element. All these multiplications are done
  internally, without changing the input vector ``v``.
 
*/
// %%EXPORT px
int32_t mm_profile_mod3_load(uint32_t p, uint_mmv_t *v, uint64_t *a, uint32_t t)
{
    uint64_t m[72], e = (t >> 1) & 3;
    if (mm_profile_mod3_load_abc(p, v, m) < 0)  return -1;

    memcpy(a + 24 * ((3 - e) % 3), m, 24 * sizeof(uint64_t));
    mm_op3_t_ABC(m, 1);
    memcpy(a + 24 * ((4 - e) % 3), m, 24 * sizeof(uint64_t));
    mm_op3_t_ABC(m, 1);
    memcpy(a + 24 * ((5 - e) % 3), m, 24 * sizeof(uint64_t));
    if (t & 1) {
        memcpy(m, a+24, 24 * sizeof(uint64_t));
        memcpy(a+24, a+48, 24 * sizeof(uint64_t));
        memcpy(a+48, m, 24 * sizeof(uint64_t));
    }
    _reduce(a);
    return 0;
}



/************************************************************************
** adjust signs for our profiling
************************************************************************/


/// @cond DO_NOT_DOCUMENT 


/** @brief Compute profile from result of function ``mm_profile_mod3_load``

In this function parameter ``a`` must must be an array of length 72, 
containg a block for a vector \f$v \in \rho_{3}\f$, as computed by
function ``mm_profile_mod3_load``. We take notation from the comment
on blocks at the beginning of this file. Let ``A[e;i,j]`` be as in
that comment.


From that block the function computes a *basic profile* of the block
stores it in the buffer referred by ``b``.
The basic profile is a 24 time 24 matrix, where each entry is computed
from the correponding three entries of 'A' * \f$\tau^e\f$. 
In case ``i != j`` we store 1 in bit ``e`` of ``b[i,j]``
if ``A[e;i,j] != 0`` and 0 otherwise. We put ``b[i,i] = A[e;i,i]``. We
remark that entries ``A[e;i,i]`` are equal for all ``e``.
For ``i != j``  we store 1 in bit 3 of ``b[i,j]`` 
if ``A[0;i,j] == A[1;i,j] == A[2;i,j] == -1`` holds modulo 3, and 0
otherwise. So that bit encodes the sign
of ``A[0;i,j] * A[1;i,j] * A[2;i,j]`` (modulo 3), if all three
factors of that product are nonzero.
All other bits of the entries ``b[i,j]`` are set to 0.
 
Buffer ``b`` must have size 24 * 24, with entry ``i, j`` of 
matrix ``b`` stored in ``b[24] * i + j``.
*/
static inline void block_mod3_to_profile(uint64_t *a, uint8_t *b)
{
    uint64_t i, j, t0, t1, t2, x;
    for (i = 0; i < 24; ++i) {
        t0 = a[i]; adjust_sign(t0, x);
        t1 = a[i+24]; adjust_sign(t1, x);
        t2 = a[i+48]; adjust_sign(t2, x);
        for (j = 0; j < 24; ++j) {
            x = (((t0 ^ t1 ^ t2) >> 1) & t0 & t1 & t2 & 1) << 3;
            x += (t0 & 1) + ((t1 & 1) << 1) + ((t2 & 1) << 2);
            b[j] = (uint8_t)(x);
            t0 >>= 2; t1 >>= 2; t2 >>= 2;
        }
        b[i] = (uint8_t)((a[i] >> (2*i)) & 3);
        b += 24;
    } 
}


static inline void block_mod3_augment(uint64_t *a, uint8_t *b, uint32_t i, uint32_t j)
{
    uint64_t t0, t1, t2, x;
    t0 = (a[i] >> 2*j) & 3; adjust_sign(t0, x);
    t1 = (a[i+24] >> 2*j) & 3; adjust_sign(t1, x);
    t2 = (a[i+48] >> 2*j) & 3; adjust_sign(t2, x);
    x = t0 + (t1 << 2) + (t2 << 4) + 0x40;
    b[24*i + j] = b[24*j + i] = (uint8_t)x;
}




/// @endcond 






/************************************************************************
** Load part A, B, C mod 3 from vector of representation
************************************************************************/


/// @cond DO_NOT_DOCUMENT 



static inline void spread_diagonal_to_column(uint8_t *h, uint32_t start)
{
    uint_fast32_t i, j;
    uint8_t diag[24], *row = h, old;
    for (i = 0; i < 24; ++i) diag[i] = (h[25*i] & 3) << 4;
    for (i = 0; i < 24; ++i) {
        old = row[i];
        for (j = start; j < 24; ++j) row[j] = (row[j] & 0xf) | diag[j];
        row[i] = old;
        row += 24;
    }
}


static inline void sort_columns_inside_row(uint8_t *h, uint8_t start)
{
    uint8_t *row = h + start, tmp;
    uint_fast32_t n = 24 - start, i;
    for (i = 0; i < start; ++i) {
        bitvector_insertsort(row, n, uint8_t);
        row += 24;
    }
    --n;
    for (i = 0; i < 24UL - start; ++i) {
        tmp = row[0]; row[0] = row[i]; row[i] = tmp;
        row += 1;
        bitvector_insertsort(row, n, uint8_t);
        row += 23;
    }
}




static inline void
mm_profile_mod3_sort(uint8_t *h, uint8_t start, uint8_t *diag)
{
    uint8_t b1[576], *row;
    uint_fast64_t ind[24], ind_last, head, sh, stage, i;

    memcpy(b1, h, 576 * sizeof(uint8_t)); 
    // Sort rows, index list in ind[]
    for (i = 0; i < 24; ++i) ind[i] = i;
    for (stage = 0; stage < 24; stage += 8) {
        for (i = start; i < 24; ++i) {
            row = b1 + 24 * (ind[i] & 0x3fULL) + stage;
            for (sh = 8 * 6; sh >= 1 * 6; sh -= 6) {
                ind[i] |= (uint64_t)(*row++ & 0x3f) << sh;
            }
        }
        bitvector_insertsort(ind, 24, uint64_t);
        ind_last = ind[0]; head = 0;
        for (i = start; i < 24; ++i) {
            if ((ind_last ^ ind[i]) & 0xffffffffffffffc0ULL) {
                ind_last = ind[i];
                head += (uint64_t)1ULL << (uint64_t)(9 * 6);
            }
            ind[i] = (ind[i] & 0x3fULL) | head;
        }
    }
    
    // Copy sorted rows to h[]
    memset(h, 0xff, 576 * sizeof(uint8_t)); // for debugging
    for (i = 0; i < 24; ++i) {
        memcpy(h + i*24, b1 + (ind[i] & 0x3f)*24, 24*sizeof(uint8_t));
        diag[ind[i] & 0x3f] = (uint8_t)(ind[i] >> 9 * 6) & 0x3f;
    }
}


/// @endcond 



/************************************************************************
** Support for Baby Monster axes
************************************************************************/


/// @cond DO_NOT_DOCUMENT 


static inline void xchg_uint8_row_col(uint8_t *b, uint32_t i1, uint32_t i2)
{
    uint8_t t, *pi1 = b + 24*i1, *pi2 = b + 24*i2;
    uint_fast32_t j;
    for (j = 0; j < 24; ++j) {
        t = pi1[j]; pi1[j] = pi2[j]; pi2[j] = t;
    }
    pi1 = b + i1; pi2 = b + i2; 
    for (j = 0; j < 24*24; j += 24) {
        t = pi1[j]; pi1[j] = pi2[j]; pi2[j] = t;
    }
}


static inline void augment_diag(uint8_t *b, uint64_t i, uint64_t value)
{
     b[25*i] = (b[25*i] & 3) | (uint8_t)((value & 0x1f) << 2);
}



/// @endcond


/************************************************************************
** compare first two rows of matrix
************************************************************************/


/// @cond DO_NOT_DOCUMENT



static inline int32_t compare_row_col_01(uint8_t *b)
{
    uint8_t *p0 = b, *p1 = b + 24;
    uint_fast32_t j;
    if (p0[0] != p1[1]) return (p0[0] < p1[1]) ? -1 : 1;
    for (j = 2; j < 24; ++j) {
        if (p0[j] != p1[j]) return (p0[j] < p1[j]) ? -1 : 1;
    }
    return 0;
}




static inline void sort_col_01(uint8_t *b)
{
    uint_fast32_t i;
    uint8_t *row = b + 2*24, t0, t1;
    for (i = 2; i < 24; ++i) {
         t0 = row[0]; t1 = row[1];
         if (t0 > t1) {
             row[0] = t1; row[1] = t0;
         }
         row += 24;
    }
}

/// @endcond

/************************************************************************
** Sort and hash
************************************************************************/


/// @cond DO_NOT_DOCUMENT 

#define HASH_MULTIPLIER  ((uint64_t)0x4f1bbcdcbfa53ffbULL)

/// @endcond 





/** @brief yet to be documented 

   Output array ``b`` must have size 2 * 24 * 24
*/
// %%EXPORT px
int64_t mm_profile_mod3_hash(uint64_t *a, uint8_t *b, uint32_t mode)
{
    uint8_t diag[24], *h = b + 576, start = 0, start_diag = 0;
    uint64_t hash = 0ULL, j;
    int32_t equ01 = 0;
    block_mod3_to_profile(a, b);
    switch(mode) {
        case 2:
            block_mod3_augment(a, b, 1, 2);
            block_mod3_augment(a, b, 1, 3);
        case 1:
            block_mod3_augment(a, b, 2, 3);
        case 0:
            break;
        default:
            return -1;
    }
    memcpy(h, b, 576 * sizeof(uint8_t)); 
    switch(mode) {
        case 1:   // for axes in Baby Monster
            xchg_uint8_row_col(h, 0, 2);
            xchg_uint8_row_col(h, 1, 3);
            start = 2;
            break;
        case 2:   // for axes in 2.E_6(2)  (???)
            xchg_uint8_row_col(h, 0, 3);
            start = 3;
            break;
        default:   // standard mode
            break;
    } 
    spread_diagonal_to_column(h, start);
    sort_columns_inside_row(h, start);
    if (mode == 1) {
        equ01 = compare_row_col_01(h);
        if (equ01 == 1) xchg_uint8_row_col(h, 0, 1);
        sort_col_01(h);
    }
    mm_profile_mod3_sort(h, start, diag);

    switch(mode) {
        case 1:   // for axes in Baby Monster
            start_diag = 4;
            augment_diag(b, 0, diag[2]);
            augment_diag(b, 1, diag[3]);
            augment_diag(b, 2, 22 + (equ01 == -1));
            augment_diag(b, 3, 22 + (equ01 == 1));
            break;
        case 2:   // for axes in 2.E_6(2)  (???)
            start_diag = 4;
            augment_diag(b, 0, diag[3]);
            for (j = 1; j < 3; ++j) augment_diag(b, j, j+20);
            break;
        default:
            break;
    }
    for (j = start_diag; j < 24; ++j) augment_diag(b, j, diag[j]);

    for (j = 0; j < 576; ++j)  hash = (hash * HASH_MULTIPLIER + h[j]);
    return (int64_t)(hash & 0x7fffffffffffffffULL);
}



/************************************************************************
** permute a 24 time 24 matrix with a permutation
************************************************************************/



/** @brief Permute rows and columns 24 times 24 matrix

    Permute the rows and columns of the 24 times 24 matrix ``b``
    with permutation ``p`` and store result in buffer ``b1``.
    Entry ``i, j`` of a matrix is stored at index ``24 * i + j``.
    Buffer ``b`` and ``b1`` have size 24* 24.

    The function returns 0 in case of success and a negative value
    in case of failure, e.g. if ``p`` is not a legal permutation.
    Buffers ``b`` and ``b1`` may overlap.
*/
// %%EXPORT px
int32_t mm_profile_mod3_permute24(uint8_t *b, uint8_t *p, uint8_t *b1)
{
    uint8_t c[576];
    uint_fast32_t bmap = 0, i, j;
    for (i = 0; i < 24; ++i) {
        if (p[i] >= 24) return -1;
        bmap |= 1UL << p[i];
    }
    if (bmap != 0xffffffUL) return-2;
    for (i = 0; i < 24; ++i) {
        for (j = 0; j < 24; ++j) {
            c[24*p[i] + p[j]] = b[24*i + j];
        }
    }
    memcpy(b1, c, 576 * sizeof(uint8_t));
    return 0;
}



//  %%GEN h
/// @endcond 
//  %%GEN c
