/** @file mm_profile_abc_mod3.c

File ``mm_profile_abc_mod3`` contains functions for profiling the
parts 'A', 'B', 'C' of a vector \f$v\f$ in the representation
of \f$\rho\f$ the Monster. Therefore we use the entries of the
vector \f$v\f$ modulo 3 only. The functions in this module are
usually applied to a 2A axis \f$v\f$.

The centralizer of the
fourgroup \f$V_4 = \{1, x_{-1}, x_{\Omega}, x_{-\Omega}\}\f$ in the
Monster is a group \f$N_{xyz}\f$ of structure \f$2^{2+11+22}.M_{24}\f$.
Given an axis \f$v\f$, the functions in this module compute a
symmetric \f$24 \times 24\f$ matrix \f$M\f$ invariant under the
subgroup \f$2^{2+11+22}\f$ of \f$N_{xyz}\f$, such that the factor
group \f$M_{24}\f$ of \f$N_{xyz}\f$ acts naturally on \f$M\f$.
We also compute a (non-symmetric) \f$24 \times 24\f$ matrix \f$H\f$
that is invariant under \f$N_{xyz}\f$. Essentially, \f$H\f$ is
obtained from \f$M\f$ by sorting the entries of \f$M\f$ in a suitable
way.

Experiments indicate that a suitable hash value \f$h\f$ over
\f$H\f$ suffices to distinguish between the different orbits of
a 2A axis under the action of \f$N_{xyz}\f$. So in a future
version of the *mmgroup* package this might be useful to
deal with orbit of a 2A axis under the action of the
subgroup \f$N_{xyz}\f$.

Let \f$A\f$ be the part 'A' of a vector \f$v\f$.
Function ``mm_profile_mod3_load`` extracts
parts \f$A \cdot \tau^e, e = 0,1,2\f$ from the vector \f$v\f$ and
stores them as a triple \f$24 \times 24\f$ matrices in a block ``a``,
with entries taken modulo 3. The space of such blocks ``a`` may be
considered as a representation of the normalizer \f$N_0\f$
of \f$V_4\f$ with kernel \f$2^{2+11}\f$. The group \f$N_0/2^{2+11}\f$
has structure \f$2^{2\cdot 11}:(S_3 \times M_{24})\f$. Here the
group of structure \f$S_3\f$ generated by \f$\tau\f$ and \f$x_\delta\f$
(for any odd element \f$\delta\f$ of the Golay cocode) acts an a
block ``a`` by permutation of the three matrices stored in that block.
Given a vector \f$v\f$, function ``mm_profile_mod3_load`` also allows
us to extract a block from \f$v \cdot S_e\f$,
with \f$S_3 = \langle \tau, x_\delta\f$.

Function ``mm_profile_mod3_hash`` takes a block ``a`` computed by
function ``mm_profile_mod3_load`` as input. Form ``a`` it computes
a symmetric matrix \f$M\f$ invariant under the
subgroup \f$2^{2+11+22}\f$ of \f$N_{xyz}\f$, and a matrix \f$H\f$
invariant under \f$N_{xyz}\f$ as described above.

Details are yet to be documented!
*/

/// @cond DO_NOT_DOCUMENT
#include <string.h>

#include "mat24_functions.h"
#include "mm_basics.h"
#include "mm_op_p.h"
#include "mmgroup_generators.h"
#include "clifford12.h"
#include "mm_reduce.h"   
/// @endcond

   




//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


/************************************************************************
** Auxiliary functions
************************************************************************/

/// @cond DO_NOT_DOCUMENT 

/** 
  @brief Reduce dibits in the array ``a`` of length 72 modulo 3.
*/
static inline void _reduce(uint64_t *a) {
    uint64_t w, i;
    for (i = 0; i < 72; ++i) { 
        w = (a[i] & (a[i] >> 1)) & 0x5555555555555555ULL;
        a[i] = (a[i] ^ w ^ (w << 1)) & 0xffffffffffffULL;
    }
}



/** 
  @brief Re-encode dibits in the 64-bit integer ``w``.

  Dibits are mapped as 00 -> 00, 01 -> 01, 10 -> 11, 11 -> 00.
  Thus, modulo 3, the low bit acts as a 'nonzero' flag, and the
  high bit acts as a 'negative' flag. 

  The macro uses a temporary 64-bit integer ``t``.
*/
#define adjust_sign(w, t) \
    t = w & (w << 1) & 0xaaaaaaaaaaaaaaaaULL; \
    w = w ^ ((w >> 1) & 0x5555555555555555ULL) ^ t  



/** 
  @brief Load parts ABC of representation of Monster modulo 3

  Let ``v`` point to a vector of the representation \f$\rho_{p}\f$
  of the Monster, with \f$p\f$ given by parameter ``p``. The function
  load parts `A`, `B`, and `C` of that vector (in that order) into
  the vector of length 3 * 24 referred by ``a``. Entries of
  vector ``a`` are encoded as in representation  \f$\rho_{3}\f$.
  The function returns 0 in case of success and -1 in case of failure.
 
*/
static inline int32_t
mm_profile_mod3_load_abc(uint32_t p, uint_mmv_t *v, uint64_t *a)
{
    uint64_t m[3*24], i, len24 = mm_aux_v24_ints(p);
    if (len24 == 0 || len24 > 4) return -1;
    for (i = 0; i < 3 * 24; i += 24) {
        if (mm_op_load_leech3matrix(p, v + i*len24, m) < 0) return -2;
        leech3matrix_compress(m, m);
        memcpy(a + i, m, 24 * sizeof(uint64_t));
    }
    _reduce(a);
    return 0;
}




/// @endcond 

/************************************************************************
** Load part A, B, C mod 3 from vector of representation of Monster
************************************************************************/




/** 
  @brief Load parts A * tau**e of representation of Monster modulo 3

  Let ``v`` point to a vector of the representation \f$\rho_{p}\f$
  of the Monster, with \f$p\f$ given by parameter ``p``. The function
  load parts `A` * \f$\tau^e\f$,  \f$e = 0, 1, 2\f$ of that vector
  (in that order) into the vector of length 3 * 24 referred by ``a``.
  Entries of  vector ``a`` are encoded as in
  representation  \f$\rho_{3}\f$.
  The function returns 0 in case of success and -1 in case of failure.

  A nonzero value ``t`` is interpreted as follows:
  Before loading the vector ``v``, multiply it with \f$\tau^f\f$,
  where \f$f\f$ is ``(t / 2) & 3``. If ``t`` is odd then multiply ``v``
  with \f$x_\delta\f$ afterwards, where  \f$\delta\f$ is any odd
  Golay cocode element. All these multiplications are done
  internally, without changing the input vector ``v``.
 
*/
// %%EXPORT px
int32_t mm_profile_mod3_load(uint32_t p, uint_mmv_t *v, uint64_t *a, uint32_t t)
{
    uint64_t m[72], e = (t >> 1) & 3;
    if (mm_profile_mod3_load_abc(p, v, m) < 0)  return -1;

    memcpy(a + 24 * ((3 - e) % 3), m, 24 * sizeof(uint64_t));
    mm_op3_t_ABC(m, 1);
    memcpy(a + 24 * ((4 - e) % 3), m, 24 * sizeof(uint64_t));
    mm_op3_t_ABC(m, 1);
    memcpy(a + 24 * ((5 - e) % 3), m, 24 * sizeof(uint64_t));
    if (t & 1) {
        memcpy(m, a+24, 24 * sizeof(uint64_t));
        memcpy(a+24, a+48, 24 * sizeof(uint64_t));
        memcpy(a+48, m, 24 * sizeof(uint64_t));
    }
    _reduce(a);
    return 0;
}



/************************************************************************
** adjust signs for our profiling
************************************************************************/


/// @cond DO_NOT_DOCUMENT 


/** @brief yet to be documented 
*/
static inline void block_mod3_to_profile(uint64_t *a, uint8_t *b)
{
    uint64_t i, j, t0, t1, t2, x;
    for (i = 0; i < 24; ++i) {
        t0 = a[i]; adjust_sign(t0, x);
        t1 = a[i+24]; adjust_sign(t1, x);
        t2 = a[i+48]; adjust_sign(t2, x);
        for (j = 0; j < 24; ++j) {
            x = (((t0 ^ t1 ^ t2) >> 1) & t0 & t1 & t2 & 1) << 3;
            x += (t0 & 1) + ((t1 & 1) << 1) + ((t2 & 1) << 2);
            b[j] = (uint8_t)(x);
            t0 >>= 2; t1 >>= 2; t2 >>= 2;
        }
        b[i] = (uint8_t)((a[i] >> (2*i)) & 3);
        b += 24;
    } 
}


static inline void block_mod3_augment(uint64_t *a, uint8_t *b, uint32_t i, uint32_t j)
{
    uint64_t t0, t1, t2, x;
    t0 = (a[i] >> 2*j) & 3; adjust_sign(t0, x);
    t1 = (a[i+24] >> 2*j) & 3; adjust_sign(t1, x);
    t2 = (a[i+48] >> 2*j) & 3; adjust_sign(t2, x);
    x = t0 + (t1 << 2) + (t2 << 4) + 0x40;
    b[24*i + j] = b[24*j + i] = (uint8_t)x;
}




/// @endcond 






/************************************************************************
** Load part A, B, C mod 3 from vector of representation
************************************************************************/


/// @cond DO_NOT_DOCUMENT 



static inline void spread_diagonal_to_column(uint8_t *h, uint32_t start)
{
    uint_fast32_t i, j;
    uint8_t diag[24], *row = h, old;
    for (i = 0; i < 24; ++i) diag[i] = (h[25*i] & 3) << 4;
    for (i = 0; i < 24; ++i) {
        old = row[i];
        for (j = start; j < 24; ++j) row[j] = (row[j] & 0xf) | diag[j];
        row[i] = old;
        row += 24;
    }
}


static inline void sort_columns_inside_row(uint8_t *h, uint8_t start)
{
    uint8_t *row = h + start, tmp;
    uint_fast32_t n = 24 - start, i;
    for (i = 0; i < start; ++i) {
        bitvector_insertsort(row, n, uint8_t);
        row += 24;
    }
    --n;
    for (i = 0; i < 24UL - start; ++i) {
        tmp = row[0]; row[0] = row[i]; row[i] = tmp;
        row += 1;
        bitvector_insertsort(row, n, uint8_t);
        row += 23;
    }
}




static inline void
mm_profile_mod3_sort(uint8_t *h, uint8_t start, uint8_t *diag)
{
    uint8_t b1[576], *row;
    uint_fast64_t ind[24], ind_last, head, sh, stage, i;

    memcpy(b1, h, 576 * sizeof(uint8_t)); 
    // Sort rows, index list in ind[]
    for (i = 0; i < 24; ++i) ind[i] = i;
    for (stage = 0; stage < 24; stage += 8) {
        for (i = start; i < 24; ++i) {
            row = b1 + 24 * (ind[i] & 0x3fULL) + stage;
            for (sh = 8 * 6; sh >= 1 * 6; sh -= 6) {
                ind[i] |= (uint64_t)(*row++ & 0x3f) << sh;
            }
        }
        bitvector_insertsort(ind, 24, uint64_t);
        ind_last = ind[0]; head = 0;
        for (i = start; i < 24; ++i) {
            if ((ind_last ^ ind[i]) & 0xffffffffffffffc0ULL) {
                ind_last = ind[i];
                head += (uint64_t)1ULL << (uint64_t)(9 * 6);
            }
            ind[i] = (ind[i] & 0x3fULL) | head;
        }
    }
    
    // Copy sorted rows to h[]
    memset(h, 0xff, 576 * sizeof(uint8_t)); // for debugging
    for (i = 0; i < 24; ++i) {
        memcpy(h + i*24, b1 + (ind[i] & 0x3f)*24, 24*sizeof(uint8_t));
        diag[ind[i] & 0x3f] = (uint8_t)(ind[i] >> 9 * 6) & 0x3f;
    }
}


/// @endcond 



/************************************************************************
** Support for Baby Monster axes
************************************************************************/


/// @cond DO_NOT_DOCUMENT 


static inline void xchg_uint8_row_col(uint8_t *b, uint32_t i1, uint32_t i2)
{
    uint8_t t, *pi1 = b + 24*i1, *pi2 = b + 24*i2;
    uint_fast32_t j;
    for (j = 0; j < 24; ++j) {
        t = pi1[j]; pi1[j] = pi2[j]; pi2[j] = t;
    }
    pi1 = b + i1; pi2 = b + i2; 
    for (j = 0; j < 24*24; j += 24) {
        t = pi1[j]; pi1[j] = pi2[j]; pi2[j] = t;
    }
}


static inline void augment_diag(uint8_t *b, uint64_t i, uint64_t value)
{
     b[25*i] = (b[25*i] & 3) | (uint8_t)((value & 0x1f) << 2);
}



/// @endcond


/************************************************************************
** compare first two rows of matrix
************************************************************************/


/// @cond DO_NOT_DOCUMENT



static inline int32_t compare_row_col_01(uint8_t *b)
{
    uint8_t *p0 = b, *p1 = b + 24;
    uint_fast32_t j;
    if (p0[0] != p1[1]) return (p0[0] < p1[1]) ? -1 : 1;
    for (j = 2; j < 24; ++j) {
        if (p0[j] != p1[j]) return (p0[j] < p1[j]) ? -1 : 1;
    }
    return 0;
}




static inline void sort_col_01(uint8_t *b)
{
    uint_fast32_t i;
    uint8_t *row = b + 2*24, t0, t1;
    for (i = 2; i < 24; ++i) {
         t0 = row[0]; t1 = row[1];
         if (t0 > t1) {
             row[0] = t1; row[1] = t0;
         }
         row += 24;
    }
}

/// @endcond

/************************************************************************
** Sort and hash
************************************************************************/


/// @cond DO_NOT_DOCUMENT 

#define HASH_MULTIPLIER  ((uint64_t)0x4f1bbcdcbfa53ffbULL)

/// @endcond 





/** @brief yet to be documented 

   Output array ``b`` must have size 2 * 24 * 24
*/
// %%EXPORT px
int64_t mm_profile_mod3_hash(uint64_t *a, uint8_t *b, uint32_t mode)
{
    uint8_t diag[24], *h = b + 576, start = 0, start_diag = 0;
    uint64_t hash = 0ULL, j;
    int32_t equ01 = 0;
    block_mod3_to_profile(a, b);
    switch(mode) {
        case 2:
            block_mod3_augment(a, b, 1, 2);
            block_mod3_augment(a, b, 1, 3);
        case 1:
            block_mod3_augment(a, b, 2, 3);
        case 0:
            break;
        default:
            return -1;
    }
    memcpy(h, b, 576 * sizeof(uint8_t)); 
    switch(mode) {
        case 1:   // for axes in Baby Monster
            xchg_uint8_row_col(h, 0, 2);
            xchg_uint8_row_col(h, 1, 3);
            start = 2;
            break;
        case 2:   // for axes in 2.E_6(2)  (???)
            xchg_uint8_row_col(h, 0, 3);
            start = 3;
            break;
        default:   // standard mode
            break;
    } 
    spread_diagonal_to_column(h, start);
    sort_columns_inside_row(h, start);
    if (mode == 1) {
        equ01 = compare_row_col_01(h);
        if (equ01 == 1) xchg_uint8_row_col(h, 0, 1);
        sort_col_01(h);
    }
    mm_profile_mod3_sort(h, start, diag);

    switch(mode) {
        case 1:   // for axes in Baby Monster
            start_diag = 4;
            augment_diag(b, 0, diag[2]);
            augment_diag(b, 1, diag[3]);
            augment_diag(b, 2, 22 + (equ01 == -1));
            augment_diag(b, 3, 22 + (equ01 == 1));
            break;
        case 2:   // for axes in 2.E_6(2)  (???)
            start_diag = 4;
            augment_diag(b, 0, diag[3]);
            for (j = 1; j < 3; ++j) augment_diag(b, j, j+20);
            break;
        default:
            break;
    }
    for (j = start_diag; j < 24; ++j) augment_diag(b, j, diag[j]);

    for (j = 0; j < 576; ++j)  hash = (hash * HASH_MULTIPLIER + h[j]);
    return (int64_t)(hash & 0x7fffffffffffffffULL);
}



/************************************************************************
** permute a 24 time 24 matrix with a permutation
************************************************************************/



/** @brief Permute rows and columns 24 times 24 matrix

    Permute the rows and columns of the 24 times 24 matrix ``b``
    with permutation ``p`` and store result in buffer ``b1``.
    Entry ``i, j`` of a matrix is stored at index ``24 * i + j``.
    Buffer ``b`` and ``b1`` have size 24* 24.

    The function returns 0 in case of success and a negative value
    in case of failure, e.g. if ``p`` is not a legal permutation.
    Buffers ``b`` and ``b1`` may overlap.
*/
// %%EXPORT px
int32_t mm_profile_mod3_permute24(uint8_t *b, uint8_t *p, uint8_t *b1)
{
    uint8_t c[576];
    uint_fast32_t bmap = 0, i, j;
    for (i = 0; i < 24; ++i) {
        if (p[i] >= 24) return -1;
        bmap |= 1UL << p[i];
    }
    if (bmap != 0xffffffUL) return-2;
    for (i = 0; i < 24; ++i) {
        for (j = 0; j < 24; ++j) {
            c[24*p[i] + p[j]] = b[24*i + j];
        }
    }
    memcpy(b1, c, 576 * sizeof(uint8_t));
    return 0;
}



//  %%GEN h
/// @endcond 
//  %%GEN c
