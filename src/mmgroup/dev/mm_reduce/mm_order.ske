/** @file mm_order.c

 File ``mm_order.c`` contains functions for checking if an element is
 in the subgroup \f$G_{x0}\f$ (or \f$Q_{x0}\f$) of the moster group.
 If this is the case, the element is expressed as a word in the
 generators of the corresponding subgroup.

 File ``mm_order.c`` also computes functions for computing the order
 of an element of the monster.

 All these function use the precomputed ``order_vector`` in
 file ``mm_order_vector.c``
*/



#include "mat24_functions.h"
#include "clifford12.h"
#include "mm_op15.h"   
#include "mm_reduce.h"   
   
// %%EXPORT_KWD MM_REDUCE_API


/// @cond DO_NOT_DOCUMENT 

enum tag_offsets {
    OFS_NORM_A = 0,
    OFS_DIAG_VA = 1,
    OFS_WATERMARK_PERM = 2,
    OFS_TAGS_Y = 26,
    OFS_SOLVE_Y = 37,
    OFS_TAGS_X = 48,
    OFS_SOLVE_X = 72,
    OFS_TAG_SIGN = 96,
};

/// @endcond  


/************************************************************************
** Load ORDER_VECTOR and ORDER_TAG_VECTOR
************************************************************************/


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c





/// @cond DO_NOT_DOCUMENT 

#define TAG_VECTOR ((uint32_t*)MM_ORDER_VECTOR_TAG_DATA)

/// @endcond 



/************************************************************************
** Check if element of monster group is in subgroup G_x0
************************************************************************/


/**
  @brief Auxiliary function for function ``mm_order_check_in_Gx0``

 
  Inputs ``v``, and the return value are as in
  function ``mm_order_check_in_Gx0``. 

  Assume that ``v`` is an image of the precomputed order vector ``v0`` 
  under an unknown element \f$g\f$ of the monster. We want to find that 
  element \f$g\f$ if it is in the subgroup \f$G_{x0}\f$ of the monster.

  The function computes an element \f$g_1\f$ such
  that \f$g^{-1} g_1\in Q_{x0}\f$ holds in case \f$g \in G_{x0}\f$.
  If \f$g \notin G_{x0}\f$  then the function detects this
  fact with high probability.

  In case of success the function writes the element \f$g_1\f$ into the
  array ``g`` is the same way as function ``mm_order_check_in_Gx0``
  writes its result int that array.
  
  The function does not change the input ``v``.  
*/
// %%EXPORT px
int32_t mm_order_find_in_Gx0(uint_mmv_t *v, uint32_t *g)
{
    uint_mmv_t a[24 * %{V24_INTS}];
    uint64_t w3;
    int32_t res, v_y;
    uint_fast32_t w_type4, i, len, perm_num, y;


    if ((uint32_t)mm_op15_norm_A(v) 
         != TAG_VECTOR[OFS_NORM_A]) return 0x101;

    w3 = mm_op15_eval_A_rank_mod3(v, TAG_VECTOR[OFS_DIAG_VA]);
    w3 &= 0xffffffffffffULL;
    if (w3 == 0) return 0x102;
    w_type4 = (uint_fast32_t)(gen_leech3to2_type4((uint64_t)w3));
    if (w_type4 == 0) return 0x103;

    res = gen_leech2_reduce_type4(w_type4, g);
    if (res < 0) return res;
    len = res;

    for (i = 0; i < 24 * %{V24_INTS}; ++i) a[i] = v[i];
    res = mm_op15_word_tag_A(a, g, len, 1);
    if (res < 0) return res;
     
    res = mm_op15_watermark_A_perm_num( 
        TAG_VECTOR + OFS_WATERMARK_PERM, a);
    if (res < 0) return 0x104;
    perm_num = res;
    if (perm_num) {
        g[len] = 0xA0000000 + perm_num;
        res = mm_op15_word_tag_A(a, g + len, 1, 1);
        if (res < 0) return res;
        len += 1;
    }

    v_y = mm_aux_mmv_extract_sparse_signs(15, a, 
        TAG_VECTOR + OFS_TAGS_Y, 11);
    if (v_y < 0) return 0x105;
    y = leech2matrix_solve_eqn(TAG_VECTOR + OFS_SOLVE_Y, 11, v_y);
    if (y > 0) {
        g[len] = 0xC0000000 + y;
        res = mm_op15_word_tag_A(a, g + len, 1, 1);
        if (res < 0) return res;
        len += 1;
    }

    if (mm_order_compare_vector_part_A(a)) return 0x106;
    for (i = len; i <10; ++i) g[i] = 0;

    return len;
}






/**
  @brief Auxiliary function for function ``mm_order_check_in_Gx0``


  Inputs ``v``, and the return value are as in
  function ``mm_order_check_in_Gx0``.  Parameter ``g`` must contain 
  the corrsponding output of function ``mm_order_check_in_Gx0``, when
  called successfully with the same input parameters. The function also 
  requires an array `` work`` of length %{MMV_INTS} as a work buffer.

  Assume that ``v`` is an image of the precomputed order vector ``v0`` 
  under an unknown element \f$g\f$ of the monster. We want to find that 
  element \f$g\f$ if it is in the subgroup \f$G_{x0}\f$ of the monster.

  In case of success the function writes the element \f$g_1\f$ into the
  array ``g`` in the same way as function ``mm_order_check_in_Gx0``
  writes its result int that array. 

  Caution:

  This function destroys the input ``v``!  
*/
// %%EXPORT px
uint32_t mm_order_find_in_Qx0(uint_mmv_t *v, uint32_t *g, uint64_t *work)
{
    int32_t v_x, sign, len = 10, res, len1, i;
    uint_fast32_t x, v_sign, tmp;
    uint32_t aa;
    

    while (len && g[len-1] == 0) --len;
    if (g[0]) {
        res = mm_op15_word(v, g, len, 1, work);
        if (res < 0) return res;
    }

    v_x = mm_aux_mmv_extract_sparse_signs(15, v, TAG_VECTOR + OFS_TAGS_X, 24);
    if (v_x < 0) return 0x107;

    x = leech2matrix_solve_eqn(TAG_VECTOR + OFS_SOLVE_X, 24, v_x) &  0xffffff;
    v_sign = ((x >> 12) & 0x7ff) ^ (x & 0x800);
    aa = TAG_VECTOR[OFS_TAG_SIGN] ^ (v_sign << 14);
    sign = mm_aux_mmv_extract_sparse_signs(15, v, &aa, 1);
    if (v_x < 0) return 0x108;

    sign ^= uint64_parity(x & (x >> 12) & 0x7ff);
    x ^=  (sign & 1) << 24;
    x ^= mat24_ploop_theta(x >> 12);
    
    len1 = len;
    if (x & 0xfff) g[len1++] = 0x90000000 + (x & 0xfff); 
    x = (x >> 12) & 0x1fff;
    if (x) g[len1++] = 0xB0000000 + x;

    if (len1 > len) {
        res = mm_op15_word(v, g + len, len1 - len, 1, work);  
        if (res < 0) return res;
    }    
    res = mm_order_compare_vector(v);
    if (res)  return  0x209;
    for (i = 0; i < len1 >> 1; ++i) {
        tmp = g[i]; g[i] = g[len1-1-i]; g[len1-1-i] = tmp; 
    }
    for (i = 0; i < len1; ++i) g[i] ^= 0x80000000;        
    return len1;   
}


/**
  @brief Check if a vector is an image under an element of \f$G_{x0}\f$


  Let ``v0`` be the precomputed order vector in the 
  representation \f$\rho_{15}\f$  of the monster group. This is a vector 
  whose stabilizer in the monster is the neutral element, satisfying some 
  additional conditions as described in 
  module ``mmgroup.structures.find_mm_order.py``

  Assume that ``v`` is an image of ``v0`` under an unknown element
  \f$g\f$ of the monster. The function comutpes the element\f$g\f$ if
  it is in the subgroup \f$G_{x0}\f$ of the monster; otherwise we have
  hardly any chance to find it.

  In case of success the function writes the element \f$g\f$ into the
  array ``g`` as a word generators of the monster group of length at
  most 10; and the function returns the length of that word. If
  inputs ``tags`` and ``v0`` have been  constructed properly then
  the function finds such an element \f$g\f$ if it exists.
  
  If a suitable element \f$g\f$ has been found then function returns
  a nonnegative number less or equal to 10 denoting the actual length
  of the word in the array ``g`` without padding zeros.

  If no such element \f$g_1\f$ has been found then the function returns
  a number greater than 256. Then the exact return value gives some
  indication why no such element \f$g\f$ has been found; this is for
  debugging only.

  A negative return value indicates an error. 

  The function does not change the inputs ``v``.  
*/
// %%EXPORT px
int32_t mm_order_check_in_Gx0(uint_mmv_t *v, uint32_t *g)
{
    int32_t res;
    uint64_t *w, *work;

    res = mm_order_find_in_Gx0(v, g);
    if (res >= 0x100 || res < 0) return res;

    w = calloc(2 * %{MMV_INTS}, sizeof(uint64_t));
    if (w == NULL) return ERR_QSTATE12_BUFFER_OVFL;
    work = w + %{MMV_INTS};
    mm_op15_copy(v, w);    
    res = mm_order_find_in_Qx0(w, g, work);
    free(w);
    return res;    
}




/**
  @brief Compute exponent \f$e\f$ such that \f$g^e \in G_{x0}\f$

  Let \f$g\f$ be the element of the monster group stored in the
  array ``g`` as a word of generators of the monster group of
  length ``n``.

  The function computes the smallest exponent \f$e\f$ such
  that  \f$g^e\f$ is in \f$G_{x0}\f$. Then the function
  writes \f$h = g^e\f$ into the buffer ``h`` as a word of
  generators \f$G_{x0}\f$ of length at most 10. Let ``k`` be the
  length of the word representing ``h``. Then the function returns
  the value ``0x100 * e + k``; here we have ``1 <= e <= 119``
  and ``0 <= k <= 10``.
   
  Computation of ``e`` is time consuming, and in some cases we
  are interested in small values of ``e`` only.
  Parameter ``o`` is an upper bound for the exponent ``e``.
  The function returns 0 in case ``e > o``; then the data in
  buffer ``h`` are invalid.

  A negative return value indicates an error. 
*/
// %%EXPORT px
int32_t mm_order_element_Gx0(uint32_t *g, uint32_t n, uint32_t *h, uint32_t o)
{
    int32_t res;
    uint_fast32_t i;
    uint64_t *w = NULL, *w1, *work;
    uint64_t elem[26];

    if (o < 1) o = 1;
    if (o > 119) o = 119;
    res = xsp2co1_check_word_g_x0(g, n);
    if (res == 0) {
        if (n == 0) {
            return 0x100;
        } else {
            res = xsp2co1_set_elem_word(elem, g, n);
            if (res < 0) return res;
            res = xsp2co1_elem_to_word(elem, h);
            if (res < 0) return res;
            return res + 0x100;
        }
    }
    if (res == 1 && o == 1) return 0;

    w = calloc(3 * %{MMV_INTS}, sizeof(uint64_t));
    if (w == NULL) return ERR_QSTATE12_BUFFER_OVFL;
    w1 = w + %{MMV_INTS};
    work = w1 + %{MMV_INTS};

    mm_order_load_vector(w); 
    for (i = 1; i <= o; ++i) {   
        res = mm_op15_word(w, g, n, 1, work);
        if (res < 0) goto done;
        res = mm_order_find_in_Gx0(w, h);
        if (res >= 0x100) continue;
        if (res < 0) goto done;
        mm_op15_copy(w, w1);    
        res = mm_order_find_in_Qx0(w1, h, work);
        if (res < 0) goto done;
        if (res < 0x100) {
            res += i << 8;
            goto done;
        } 
    }  
    res = 0;

  done:
    if (w) free(w);
    return res;
}




/**
  @brief Compute order of an element \f$g\f$ of the monster

  Let \f$g\f$ be the element of the monster group stored in the
  array ``g`` as a word of generators of the monster group of
  length ``n``.

  The function returns the order of \f$g\f$.
   
  Computation of the order is time consuming, and in some cases 
  we are interested in small orders only.
  Parameter ``o`` is an upper bound for the order. The function 
  may return 0 if the order is greater than ``o``.

  A negative return value indicates an error. 
*/
// %%EXPORT px
int32_t mm_order_element_M(uint32_t *g, uint32_t n, uint32_t o)
{
    int32_t res, e;
    uint32_t h[10];

    res = mm_order_element_Gx0(g, n, h, o);
    if (res <= 0) return res;
    e =  res >> 8;
    if ((res & 0xff) > 10) return ERR_QSTATE12_BUFFER_OVFL;
    res = xsp2co1_order_word(h, res & 0xff);
    if (res <= 0) return res ? res : ERR_QSTATE12_SCALAR_OVFL;
    return e * res;
}

//  %%GEN h
/// @endcond 
//  %%GEN c
