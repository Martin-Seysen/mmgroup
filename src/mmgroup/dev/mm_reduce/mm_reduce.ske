/** @file mm_reduce.c

 Function ``mm_reduce_M`` is the most important C function in this
 project.  It reduces an arbitrary element of the monster group
 (represented as a word in the generators of the monster) to
 a word of fixed maximum length. Function ``mm_reduce_M`` uses the
 method in [Sey22] for reducing an element of the monster.

 Here a word in the monster group is represented as an array
 of 32-bit integers of type ``uint32_t`` as described in
 section **The monster group** in the API reference. Such an
 array represents a word of generators of the monster.
 Thus group multiplication is concatenation of words. An
 generator in a word (given by an entry in the array of integers)
 can be inverted by flipping its most significant bit.

 This file also contains auxiliary functions for
 function  ``mm_reduce_M``;  most of them deal with 2A axes in
 the representation \f$\rho_{15}\f$ of the monster modulo 15.

 Here we use the term **2A axis** as in [Sey22]; there two fixed
 2A axes  \f$v^+\f$ and \f$v^-\f$ have been defined. The
 term **2A axis** has been used earlier in [Con85].
 
 An element of \f$\rho_{15}\f$ is implemented as a array of
 ``MM_OP15_LEN_V`` integers of type ``uint_mmv_t`` as described
 in **The C interface of the mmgroup project**,
 section **Description of the mmgroup.mm extension**. The value
 ``MM_OP15_LEN_V`` is defined in file ``mm_op15.h``.

 The preferred way to deal with a 2A axis \f$v\f$ in \f$\rho_{15}\f$
 is as follows:

 - Create an array of type ``uint64_t[MM_OP15_LEN_V]`` for storing \f$v\f$.

 - Use function ``mm_reduce_store_axis`` to set \f$v=v^+\f$ or \f$v=v^-\f$.

 - Use function ``mm_op15_word`` to multiply \f$v\f$ with an element of the monster.

 Here  ``mm_op15_word`` is a function in file ``mm_op15_word.c``.
*/

#include "mm_reduce.h"   
   
// %%EXPORT_KWD MM_REDUCE_API



//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/// @cond DO_NOT_DOCUMENT 


#define MAX_SHORT_ARRAY 1024

#define V_START 0x200



typedef struct {
    uint_mmv_t v[MM_OP15_LEN_V];
    uint_mmv_t vtmp[MM_OP15_LEN_V];
    uint_mmv_t vA[MM_OP15_OFS_B];
    uint32_t v_short[MAX_SHORT_ARRAY];
    uint32_t n_short;
    uint64_t basis[24];
} axes_work_t;


/////////////////////////////////////////////////////////////////////////
// Auxiliary functions 
/////////////////////////////////////////////////////////////////////////
 



/**
  @brief Return certain array of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15.

  In case ``value1 == 0`` the function computes the list of all 
  vectors ``v2`` in the Leech lattice mod 2 such that the absolute 
  value of the entry of ``v`` corresponding a unit vector labelled 
  by ``v2`` is equal to ``value0``. That list is stored 
  in ``pwork.v_short[j], 0 <= j < ``n_short``.

  In case ``value1 != 0`` wil will store the list of all 
  vectors ``v2`` in the Leech lattice mod 2 such that the absolute 
  value of the entry of ``v`` corresponding a unit vector labelled 
  by ``v2`` is equal to ``value0`` or ``value1` . That list is 
  stored in ``pwork.v_short[j], 0 <= j < ``n_short`` in the same way
  as in function ``mm_op15_eval_X_find_abs``.
*/
 
static inline void get_short(
    uint_mmv_t *v, 
    uint32_t value0, 
    uint32_t value1, 
    axes_work_t *p_work
)
{
    p_work->n_short = mm_op15_eval_X_find_abs(v, p_work->v_short,
                MAX_SHORT_ARRAY,  value0, value1);
}



/**
  Return certain subspace of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15, and let
  ``L`` be the set of vectors in the Leech lattice mod 2
  returned by function ``short(v, value)``. The function computes
  the linear subspace of the Leech lattice mod 2 spanned by ``L``
  as a list of vectors. 

  That list is  stored in ``pwork.v_short[j], 0 <= j < ``n_short``.
*/
static inline void get_span(
    uint_mmv_t *v, 
    uint32_t value, 
    axes_work_t *p_work
)
{
    uint32_t dim;
    get_short(v, value, 0, p_work);
    dim = leech2_matrix_basis(p_work->v_short, p_work->n_short, 
                p_work->basis, 24);
    if (dim > 10) dim = 10;
    p_work->n_short = leech2_matrix_expand(p_work->basis, dim, 
          p_work->v_short);
}


/**
  Return certain subspace of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15, and let
  ``L`` be the set of vectors in the Leech lattice mod 2
  returned by function ``short(v, value)``. let ``V`` be the
  linear space spanend by ``L``. 

  The function returns the radical of ``V`` (i.e. the intersection
  of ``V`` with its orthogonal complement) as a list of vectors. 

  That list is  stored in ``pwork.v_short[j], 0 <= j < ``n_short``.
*/
static inline void get_radical(
    uint_mmv_t *v, 
    uint32_t value, 
    axes_work_t *p_work
)
{
    uint32_t dim;
    get_short(v, value, 0, p_work);
    dim = leech2_matrix_radical(p_work->v_short, p_work->n_short, 
                p_work->basis, 24);
    if (dim > 10) dim = 10;
    p_work->n_short = leech2_matrix_expand(p_work->basis, dim, 
          p_work->v_short);
}



static inline uint32_t find_type4(
    axes_work_t *p_work
)
{
    uint32_t *pv;
    for (pv = p_work->v_short; pv < p_work->v_short + p_work->n_short; ++pv) {
        if ((gen_leech2_type(*pv & 0xffffff) >> 4) == 4) return *pv;
    }
    return 0;
}


static inline uint32_t find_ortho_short(
    axes_work_t *p_work
)
{
    uint32_t *pv;
    for (pv = p_work->v_short; pv < p_work->v_short + p_work->n_short; ++pv) {
        uint32_t v = *pv & 0xffffff;
        if ((gen_leech2_type(v) >> 4) == 4 &&
           (gen_leech2_type(v ^ V_START) >> 4) == 2) return v ^ V_START;
    }
    return 0;
}



static inline uint32_t xor_entries(
    axes_work_t *p_work,
    int32_t value
)
{
    uint32_t *pv;
    for (pv = p_work->v_short; pv < p_work->v_short + p_work->n_short; ++pv) {
        *pv ^= value;
    }
    return 0;
}

 

static inline uint32_t eval_A_vstart(uint_mmv_t *v)
{
    return mm_op15_eval_A(v, 0x200);
}


/// @endcond  



/////////////////////////////////////////////////////////////////////////
// Analyze type of a 2A axis
/////////////////////////////////////////////////////////////////////////

/** @brief Check 2A axis in rep of monster at a short Leech vector

   Let ``v`` be a vector in the 196884-dimensional representation
   of the monster group modulo ``15``, encoded as described in
   section *Description of the mmgroup.mm<p> extensions* in the
   description of the *C interface*. 

   If ``v`` is a 2A axis then the function computes the type
   of the 2A axis. Each 2A axis corresponds uniquely to a 2A
   involution \f$x\f$ in the monster. Let \f$z\f$ be the central 
   involution in the subgroup \f$G_{x0}\f$ of the monster. Then
   the type of the 2A axis ``v`` is the class of the 
   product \f$xz\f$ in the monster, which has one of the
   values 2A, 2B, 4A, 4B, 4C, 6A, 6C, 6F, 8B, 10A, 10B, 12C
   
   The function returns a value ``n * 2**28 + k * 2**24 + v``.
   Here ``n`` is the number of the class, e.g. ``n == 6`` for
   class 6C, ``k`` encodes the letter in the name of the 
   class ('A' = 1, 'B' = 2, ...) e.g. ``k = 3`` for class 6C.

   Output ``v`` is either 0 or a vector in the Leech lattice 
   mod 2 found during the computation. Here a vector of type 2
   is returned for classes 2A, 6A; and a vector of type 4 is
   returned for class 4A.

   Caution:

   This is a quick disambiguation of the type of a 2A axis. The 
   function may return any axis type if ``v`` is not  a 2A axis.
*/
// %%EXPORT px
uint32_t mm_reduce_2A_axis_type(uint_mmv_t *v)
{
    static uint8_t axes_types[16] = {
           0,  0, 0x82, 0x43,     0xF2, 0x63,  0,   0,
        0xF0,  0, 0xC3,    0,        0, 0x42, 0xF0, 0
    };
    uint32_t norm, res, rank, v2, val_A;
    uint64_t r, v3;
    norm = mm_op15_norm_A(v);
    res = axes_types[norm & 15];
    if (res < 0x0F0) return res << 24;
    r =  mm_op15_eval_A_rank_mod3(v, res & 0xf);    
    rank = (uint32_t)(r >> 48);
    v3 = r & 0xffffffffffffULL;
    
    switch (norm) {
        case 4:
            if (rank == 2) return 0xA1000000;
            if (rank == 23) {
                v2 = gen_leech3to2_short(v3) & 0xffffff;
                val_A = mm_op15_eval_A(v, v2);
                switch (val_A) {
                    case 4:
                        return 0x21000000 + v2;
                    case 7:
                        return 0x61000000 + v2;
                    default:
                        break;
                }
            }
            break;
        case 8:
            if (rank == 8) return 0x22000000;
            if (rank == 24) return 0xA2000000;
            break;
        case 14:
            if (rank == 8) return 0x66000000;
            if (rank == 23) {
                v2 = gen_leech3to2_type4(v3) & 0xffffff;
                return 0x41000000 + v2;
            } 
            break;
        default:
            break;
    }    
    return 0;
}


/////////////////////////////////////////////////////////////////////////
// Store standard 2A axes in a vector
/////////////////////////////////////////////////////////////////////////

/**
  @brief Store the 2A axis \f$v^+\f$ or \f$v^-\f$ at a vector in \f$\rho_{15}\f$

  The function stores the 2A axis \f$v^+\f$ (in case ``sign == 0``)
  or \f$v^-\f$  (in case ``sign != 0``) in the vector referred
  by ``v``. That vector will store an element of the 
  representation \f$\rho_{15}\f$ of the monster group as described in
  the header of this file. 
  Vectors \f$v^+\f$ and \f$v^-\f$ are defined in [Sey22], Section 6.
*/
// %%EXPORT px
void  mm_reduce_store_axis(uint_mmv_t *v, uint32_t sign)
{
    mm_aux_zero_mmv(15, v);
    static uint32_t sp[4] = {
        (1 << 25) + (2 << 14) + (2 << 8) + 1,
        (1 << 25) + (2 << 14) + (3 << 8) + 15 - 1,
        (1 << 25) + (3 << 14) + (3 << 8) + 1,
        (2 << 25) + (2 << 14) + (3 << 8) 
    };
    sp[3] &= 0xffffff00;
    sp[3] += sign ? 2 : 15 - 2;
    mm_aux_mmv_set_sparse(15, v, sp, 4);
}

/////////////////////////////////////////////////////////////////////////
// Reducing a 2A axis to the standard axis V_START
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 


static int32_t reduce_v_axis(uint_mmv_t *v, uint32_t * r, axes_work_t *p_work)
{
    int32_t status = -1000;
    uint32_t len_r = 0, i, j, len_r1, vt, v4, ax_type, e;
    uint32_t ax_types[3];

    for (i = 0; i < 5; ++i) {
        vt = mm_reduce_2A_axis_type(v);
        if (vt == 0)  return -2;
        ax_types[1] = ax_types[2] = 0;
        ax_type = vt >> 24;
        vt &= 0xffffff;
        switch(ax_type) {
            case 0xC3:
                get_radical(v, 7, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x42;
                ax_types[1] = 0x61;
                break;
            case 0xA2:
                get_radical(v, 4, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x42;
                ax_types[1] = 0x43;
                break;
            case 0xA1:
                get_short(v, 3, 1, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_type4(p_work);
                ax_types[0] = 0x61;
                break;
            case 0x82:
                get_short(v, 1, 0, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x66:
                get_radical(v, 7, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x43;
                break;
            case 0x63:
                get_span(v, 3, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x61:
                get_short(v, 5, 0, p_work);
                xor_entries(p_work, vt);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x43:  // case 4C
            case 0x42:  // case 4B
                get_radical(v, 1, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x22;
                break;
            case 0x41:  // case 4A
                v4 = vt;
                ax_types[0] = 0x21;
                break;
            case 0x22:  // case 2B
                get_span(v, 4, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x21;
                break;
            case 0x21:   // case 2B
                len_r1 = gen_leech2_reduce_type2(vt, r+len_r);
                if (len_r1 < 0) return -21;
                mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
                len_r += len_r1;
                vt = mm_aux_get_mmv1(15, v, (24+3)*32 + 2);
                if (vt != 15-2) {
                   r[len_r] = 0xB0000200;
                   mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                   len_r += 1;
                }
                mm_reduce_store_axis(p_work->vtmp, 0);
                if (mm_op15_compare(v, p_work->vtmp)) return -22;
                return len_r;
            default:
                return -1;
        }

        len_r1 = gen_leech2_reduce_type4(v4, r + len_r);
        if (len_r1 < 0) return -10;
        mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
        len_r += len_r1;
        status = -4;
        for (e = 1; e < 3 && status; ++e) {
            mm_op15_t_A(v, e, p_work->vA);                    
            ax_type = mm_reduce_2A_axis_type(p_work->vA) >> 24;
            for (j = 0; j < 3 && ax_types[j]; ++j) {
                if (ax_type == ax_types[j]) {
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    len_r += 1;
                    status = 0;
                    break;
                }
            }
        }
        if (status)  return status;
    }
    return -3;
}

/// @endcond


/**
  @brief Reduce a 2A axis in \f$\rho_{15}\f$ in to the standard axis \f$v^+\f$

  Input ``v`` in this function must refer to a 2A axis \f$v\f$ 
  in \f$\rho_{15}\f$ as described in the header of this file.

  The function computes an element \f$g\f$ of the monster group 
  with   \f$v \cdot g = v^+\f$. We use the method in [Sey22],
  Section 6 ff. for computing \f$g\f$.

  The function stores \f$g\f$ as a word of generators in the 
  array ``r`` as described in the header of this file and returns
  the length of this word.
  
  The buffer referred by ``r`` should have length at least 64.

  A negative return value indicates a fatal error.
*/
// %%EXPORT px
int32_t mm_reduce_v_axis(uint_mmv_t *v, uint32_t *r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    res =  reduce_v_axis(v,  r, p_work);
    free(p_work);
    return res;
}


/**
  @brief Reduce element of monster to element of subgroup \f$H^+\f$

  Let \f$g\f$ be the element of the monster given as a word of
  generators in the buffer ``a`` of length ``n``. The function
  computes an element \f$h\f$ of the monster with 
  \f$g \cdot h \in H^+\f$. Here \f$H^+\f$ is a subgroup
  of the monster of structure \f$2.B\f$ as defined in [Sey22],
  Section 6. We use the method in loc. cit. for computing \f$h\f$.

  The function stores \f$h\f$ as a word of generators in the 
  array ``r`` as described in the header of this file and returns
  the length of this word.
  
  The buffer referred by ``r`` should have length at least 64.

  A negative return value indicates a fatal error.
  
*/
// %%EXPORT px
int32_t mm_reduce_axis(uint32_t *a,  uint32_t n, uint32_t *r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    mm_reduce_store_axis(p_work->v, 0);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res >= 0)  res = reduce_v_axis(p_work->v, r, p_work);
    free(p_work);
    return res;
}



/////////////////////////////////////////////////////////////////////////
// Reducing a 2A axis to orthogonal to V_START, preserving V_START
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 


static int32_t reduce_v_baby_axis(uint_mmv_t *v, uint32_t * r, axes_work_t *p_work)
{
    int32_t status = -1000;
    uint32_t len_r = 0, i, j, len_r1, vt, v4, ax_type, e, ind;
    uint32_t ax_types[3];

    for (i = 0; i < 5; ++i) {
        vt = mm_reduce_2A_axis_type(v);
        if (vt == 0)  return -2;
        ax_types[1] = ax_types[2] = 0;
        ax_type = vt >> 24;
        vt &= 0xffffff;
        switch(ax_type) {
            case 0xA1:
                get_short(v, 3, 1, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_ortho_short(p_work);
                ax_types[0] = 0x61;
                break;
            case 0x63:
                get_span(v, 3, p_work);
                v4 = find_ortho_short(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x61:
                get_short(v, 5, 0, p_work);
                xor_entries(p_work, vt);
                v4 = find_ortho_short(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x43:  // case 4C
            case 0x42:  // case 4B
                get_radical(v, 1, p_work);
                v4 = find_ortho_short(p_work);
                ax_types[0] = 0x22;
                break;
            case 0x41:  // case 4A
                v4 = vt ^ V_START;
                ax_types[0] = 0x21;
                break;
            case 0x22:  // case 2B
                if ((eval_A_vstart(v) & ~8) == 0) {
                    get_span(v, 4, p_work);
                    v4 = find_ortho_short(p_work);
                    ax_types[0] = 0x21;
                } else return -4;
                break;
            case 0x21:   // case 2B
                if (eval_A_vstart(v) == 0)  {
                    len_r1 = gen_leech2_reduce_type2_ortho(vt, r+len_r);
                    if (len_r1 < 0) return -21;
                    mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
                    len_r += len_r1;
                    vt = mm_reduce_2A_axis_type(v) & 0xffffff;
                    if (vt != 0x800200) return -22;
                    ind = mm_aux_get_mmv1(15, v, (2*24+3)*32 + 2);
                    e = 2 - (ind == 15-2);
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    len_r += 1;
                }
                mm_reduce_store_axis(p_work->vtmp, 1);
                if (mm_op15_compare(v, p_work->vtmp)) return -23;
                return len_r;
            default:
                return -1;
       }

        len_r1 = gen_leech2_reduce_type2_ortho(v4, r + len_r);
        if (len_r1 < 0) return -10;
        mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
        len_r += len_r1;
        status = -4;
        for (e = 1; e < 3 && status; ++e) {
            mm_op15_t_A(v, e, p_work->vA);                    
            ax_type = mm_reduce_2A_axis_type(p_work->vA) >> 24;
            for (j = 0; j < 3 && ax_types[j]; ++j) {
                if (ax_type == ax_types[j]) {
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    len_r += 1;
                    status = 0;
                    break;
                }
            }
        }
        if (status)  return status;
    }
    return -3;
}


/// @endcond 


/**
  @brief Reduce feasible 2A axis to the feasible axis \f$v^-\f$

  To be documented later!
  
*/
// %%EXPORT px
int32_t mm_reduce_v_baby_axis(uint_mmv_t *v, uint32_t * r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    res =  reduce_v_baby_axis(v,  r, p_work);
    free(p_work);
    return res;
}



/**
  @brief Reduce element of monster to element of subgroup \f$G_{x0}\f$

  To be documented later!
  
*/
// %%EXPORT px
int32_t mm_reduce_G_x0(uint32_t *a,  uint32_t n, uint32_t *r)
{
    int32_t len1, res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    mm_reduce_store_axis(p_work->v, 0);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) goto done;
    len1 = res = reduce_v_axis(p_work->v, r, p_work);
    if (res <  0) goto done;
    mm_reduce_store_axis(p_work->v, 1);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) goto done;
    res = mm_op15_word(p_work->v, r, len1, 1, p_work->vtmp);
    if (res <  0) goto done;
    res = reduce_v_baby_axis(p_work->v, r + len1, p_work);
    if (res <  0) goto done;
    res = len1 + res;

done:
    free(p_work);
    return res;
}


/**
  @brief Reduce an element in the monster group

  To be documented later!

  
*/
// %%EXPORT px
int32_t mm_reduce_M(uint32_t *a,  uint32_t n, uint32_t *r)
{
    int32_t len1, len2, res;

    // This function combines functions  mm_reduce_G_x0 and
    // mm_order_check_in_Gx0. Here we cut and paste the code of both 
    // functions, for reducing  the overhead of memory allocation.
    // First allocate memory for both subfunctions.
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;

    // Cut an paste the operation of function mm_reduce_G_x0
    mm_reduce_store_axis(p_work->v, 0);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) goto done;
    len1 = res = reduce_v_axis(p_work->v, r, p_work);
    if (res <  0) goto done;
    mm_reduce_store_axis(p_work->v, 1);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) goto done;
    res = mm_op15_word(p_work->v, r, len1, 1, p_work->vtmp);
    if (res <  0) goto done;
    res = reduce_v_baby_axis(p_work->v, r + len1, p_work);
    if (res <  0) goto done;
    len1 = res = len1 + res;

    // Let ``g1`` be the element of the monster stored in
    // ``r[0,...,len1-1]``. Then ``h := g * g1`` is now in the
    // Subgroup ``G_x0`` of the monster.

    // Put p_work->v = v0 * h
    mm_order_load_vector(p_work->v); 
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res < 0) goto done;
    res = mm_op15_word(p_work->v, r, len1, 1, p_work->vtmp);
    if (res < 0) goto done;

    // Now we essentially apply function t mm_order_check_in_Gx0
    // to find a representation of ``h`` in generators of ``G_x0``.
    res = mm_order_find_in_Gx0(p_work->v, r + len1);
    if (res > 0x100) res = -0x200;
    if (res < 0) goto done; 
    len2 = res = mm_order_find_in_Qx0(p_work->v, r + len1, 
          p_work->vtmp);
    if (res < 0) goto done;

    // Now ``r[len1,...,len1+len2-1]``  contains ``h``. We will compute
    // the result ``h * g1**(-1)`` in ``r[0,...,len1+len2-1]`` and
    // return res = len1 + len2.
    mm_group_invert_word(r + len1, len2);
    mm_group_invert_word(r, res = len1 + len2);
  
done:
    free(p_work);
    return res;
}



//  %%GEN h
/// @endcond 
//  %%GEN c
