/** @file mm_reduce.c

 Function ``mm_reduce_M`` is the most important C function in this
 project.  It reduces an arbitrary element of the monster group
 (represented as a word in the generators of the monster) to
 a word of fixed maximum length. Function ``mm_reduce_M`` uses the
 method in [Sey22] for reducing an element of the monster.

 Here a word in the monster group is represented as an array
 of 32-bit integers of type ``uint32_t`` as described in
 section **The monster group** in the API reference. Such an
 array represents a word of generators of the monster.
 Thus group multiplication is concatenation of words. An
 generator in a word (given by an entry in the array of integers)
 can be inverted by flipping its most significant bit.

 This file also contains auxiliary functions for
 function  ``mm_reduce_M``;  most of them deal with 2A axes in
 the representation \f$\rho_{15}\f$ of the monster modulo 15.

 Here we use the term **2A axis** as in [Sey22]; there two fixed
 2A axes  \f$v^+\f$ and \f$v^-\f$ have been defined. The
 term **2A axis** has been used earlier in [Con85].
 
 An element of \f$\rho_{15}\f$ is implemented as a array of
 ``MM_OP15_LEN_V`` integers of type ``uint_mmv_t`` as described
 in **The C interface of the mmgroup project**,
 section **Description of the mmgroup.mm extension**. The value
 ``MM_OP15_LEN_V`` is defined in file ``mm_op15.h``.

 The preferred way to deal with a 2A axis \f$v\f$ in \f$\rho_{15}\f$
 is as follows:

 - Create an array of type ``uint64_t[MM_OP15_LEN_V]`` for storing \f$v\f$.

 - Use function ``mm_reduce_store_axis`` to set \f$v=v^+\f$ or \f$v=v^-\f$.

 - Use function ``mm_op15_word`` to multiply \f$v\f$ with an element of the monster.

 Here  ``mm_op15_word`` is a function in file ``mm_op15_word.c``.
*/

#include "mm_reduce.h"   
   
// %%EXPORT_KWD MM_REDUCE_API



//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/// @cond DO_NOT_DOCUMENT 


#define MAX_SHORT_ARRAY 1024

#define V_START 0x200



typedef struct {
    uint_mmv_t v[MM_OP15_LEN_V];
    uint_mmv_t vtmp[MM_OP15_LEN_V];
    uint_mmv_t vA[MM_OP15_OFS_B];
    uint32_t v_short[MAX_SHORT_ARRAY];
    uint32_t n_short;
    uint64_t basis[24];
} axes_work_t;

/// @endcond


/////////////////////////////////////////////////////////////////////////
// Auxiliary functions 
/////////////////////////////////////////////////////////////////////////
 

/// @cond DO_NOT_DOCUMENT 


/**
  @brief Return certain array of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15.

  In case ``value1 == 0`` the function computes the list of all
  vectors ``v2`` in the Leech lattice mod 2 such that the absolute
  value of the entry of ``v`` corresponding a unit vector labelled
  by ``v2`` is equal to ``value0``. That list is stored
  in ``pwork.v_short[j], 0 <= j < ``n_short``.

  In case ``value1 != 0`` wil will store the list of all
  vectors ``v2`` in the Leech lattice mod 2 such that the absolute
  value of the entry of ``v`` corresponding a unit vector labelled
  by ``v2`` is equal to ``value0`` or ``value1` . That list is
  stored in ``pwork.v_short[j], 0 <= j < ``n_short`` in the same way
  as in function ``mm_op15_eval_X_find_abs``.
*/
 
static inline void get_short(
    uint_mmv_t *v, 
    uint32_t value0, 
    uint32_t value1, 
    axes_work_t *p_work
)
{
    p_work->n_short = mm_op15_eval_X_find_abs(v, p_work->v_short,
                MAX_SHORT_ARRAY,  value0, value1);
}



/**
  Return certain subspace of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15, and let
  ``L`` be the set of vectors in the Leech lattice mod 2
  returned by function ``short(v, value)``. The function computes
  the linear subspace of the Leech lattice mod 2 spanned by ``L``
  as a list of vectors.

  That list is  stored in ``pwork.v_short[j], 0 <= j < ``n_short``.
*/
static inline void get_span(
    uint_mmv_t *v, 
    uint32_t value, 
    axes_work_t *p_work
)
{
    uint32_t dim;
    get_short(v, value, 0, p_work);
    dim = leech2_matrix_basis(p_work->v_short, p_work->n_short, 
                p_work->basis, 24);
    if (dim > 10) dim = 10;
    p_work->n_short = leech2_matrix_expand(p_work->basis, dim, 
          p_work->v_short);
}


/**
  Return certain subspace of short vectors in Leech lattice mod 2

  Let ``v`` be a vector in the rep of the moster mod 15, and let
  ``L`` be the set of vectors in the Leech lattice mod 2
  returned by function ``short(v, value)``. let ``V`` be the
  linear space spanend by ``L``. 

  The function returns the radical of ``V`` (i.e. the intersection
  of ``V`` with its orthogonal complement) as a list of vectors.

  That list is  stored in ``pwork.v_short[j], 0 <= j < ``n_short``.
*/
static inline void get_radical(
    uint_mmv_t *v, 
    uint32_t value, 
    axes_work_t *p_work
)
{
    uint32_t dim;
    get_short(v, value, 0, p_work);
    dim = leech2_matrix_radical(p_work->v_short, p_work->n_short, 
                p_work->basis, 24);
    if (dim > 10) dim = 10;
    p_work->n_short = leech2_matrix_expand(p_work->basis, dim, 
          p_work->v_short);
}

/// @endcond 



/**
  Select a type-4 vector from list of Leech lattice vectors

  Let ``v`` be an array of ``n`` vectors in the Leech lattice 
  modulo 2 in Leech lattice encoding.

  If parameter ``v2`` is 0 then the function returns the least
  vector of type 4 in the list ``v`` with repect to a certain
  ordering. If list ``v`` contains no vector of type 4 then the
  function returns 0.

  Here subtypes are ordered as follows: ``[48, 40, (42, 44), 46, 43]``.
  So e.g. a vector of subtype ``40`` is selected in favor of a vactor
  of subtype ``46``. We do not distinguish between substypes ``42``
  and ``44``. From all vectors of the same subtype (equalizing
  subtypes ``42`` and ``44``) we return the smallest vector in
  the list in the natural order.
  
  If ``v2`` is nonzero then we accept only vectors ``v1`` in the
  list ``v`` with ``type(v1) = 4`` and ``type(v1 + v2) = 2``.

  The list ``v`` is destroyed. More precisely, all entries 
  of ``v`` are masked with ``0xffffff`` and subjected to an
  (undocumented) permutation.
*/
// %%EXPORT px
uint32_t mm_reduce_find_type4(uint32_t *v, uint32_t n, uint32_t v2)
{
/// @cond DO_NOT_DOCUMENT 
    uint_fast32_t part[6], i, j, temp, no_sub2;
    v2 &= 0xffffff;
    for (i = 0; i < n; ++i) v[i] &= 0xffffff;
    no_sub2 = v2 == 0; 
    part[0] = part[1] = 0; part[5] = n; 
    i = 0; j = n;
    #define cond(x) (x) & 0x800
    bitvector_cond_sort(v, i, j, cond, temp);
    #undef cond
    part[4] = j = i; i = 0;
    #define cond(x) MAT24_THETA_TABLE[((x) >> 12) & 0x7ff] & 0x1000
    bitvector_cond_sort(v, i, j, cond, temp);
    #undef cond
    part[3] = j = i; i = 0;
    #define cond(x) (x) & 0x7ff000UL
    bitvector_cond_sort(v, i, j, cond, temp);
    #undef cond
    part[2] = i;
    for (i = 0; i < part[2]; ++i) {
        if (v[i] == 0x800000) {
            temp = v[0]; v[0] = v[i]; v[i] = temp;
            part[1] = 1;
            break;
        }
    }

    for (i = 0; i < 5; ++i) {
        bitvector32_sort(v + part[i], part[i+1] - part[i]);
        for (j = part[i]; j < part[i+1]; ++j) {
            if (gen_leech2_type(v[j]) == 4 && 
                (no_sub2 || gen_leech2_type2(v[j] ^ v2))) return v[j]; 
        }
    }
/// @endcond
    return 0;
}


/// @cond DO_NOT_DOCUMENT 




static inline uint32_t find_type4(
    axes_work_t *p_work
)
{
    return mm_reduce_find_type4(p_work->v_short, p_work->n_short, 0);
}


static inline uint32_t find_ortho_short(
    axes_work_t *p_work,
    uint32_t axis
)
{
    return mm_reduce_find_type4(p_work->v_short, p_work->n_short, axis);
}



static inline uint32_t xor_entries(
    axes_work_t *p_work,
    int32_t value
)
{
    uint32_t *pv;
    for (pv = p_work->v_short; pv < p_work->v_short + p_work->n_short; ++pv) {
        *pv ^= value;
    }
    return 0;
}

 




/**
  @brief Adjust sign of an axis

  Assume that ``v2`` is an element of the subgroup \f$Q_{x0}\f$ of
  the monster of structure \f$2^{1+24}\f$ (known up to sign only)
  given in **Leech lattice encoding**. Assume that ``v`` is the 
  axis of ``v2`` in the representation \f$\rho_{15}\f$.

  The we return the element ``v2`` with corrected sign. If the
  assumptions do not hold then the function returns garbage.
*/
static inline int32_t v_leech2_adjust_sign(uint_mmv_t *v, uint32_t v2)
{
    uint32_t ind = mm_aux_index_leech2_to_sparse(v2 & 0xffffffUL);
    mm_aux_mmv_extract_sparse(15, v, &ind, 1);
    return (v2 & 0xffffff) | (((ind & 15) == 2) << 24);
}


/**
  @brief Transform element of \f$Q_{x0}\f$ with element of monster group

  Let \f$g\f$ be the element of the monster given as a word of 
  generators in the buffer ``a`` of length ``n``. Let ``p_axis``
  point to an element \f$q\f$ of the subgroup \f$Q_{x0}\f$ of the 
  monster of  of structure \f$2^{1+24}\f$  given 
  in **Leech lattice encoding**.

  The function conjugates the element \f$q\f$ with \f$g\f$ in place.
  It returns 0 an case of success and a negative value otherwise.
  
  Warning: the function does not change  \f$q\f$ if \f$q\f$  is
  equal to ``V_START``.
*/
static inline int32_t op_axis(uint32_t *p_axis, uint32_t *a, uint32_t n)
{  
    if (*p_axis == V_START) return 0;
    *p_axis = gen_leech2_op_word(*p_axis, a, n);
    return *p_axis < 0 ? *p_axis : 0; 
}



/// @endcond  



/////////////////////////////////////////////////////////////////////////
// Analyze type of a 2A axis
/////////////////////////////////////////////////////////////////////////

/** @brief Check 2A axis in rep of monster at a short Leech vector

   Let ``v`` be a vector in the 196884-dimensional representation
   of the monster group modulo ``15``, encoded as described in
   section *Description of the mmgroup.mm<p> extensions* in the
   description of the *C interface*.

   If ``v`` is a 2A axis then the function computes the type
   of the 2A axis. Each 2A axis corresponds uniquely to a 2A
   involution \f$x\f$ in the monster. Let \f$z\f$ be the central
   involution in the subgroup \f$G_{x0}\f$ of the monster. Then
   the type of the 2A axis ``v`` is the class of the
   product \f$xz\f$ in the monster, which has one of the
   values 2A, 2B, 4A, 4B, 4C, 6A, 6C, 6F, 8B, 10A, 10B, 12C
   
   The function returns a value ``n * 2**28 + k * 2**24 + v``.
   Here ``n`` is the number of the class, e.g. ``n == 6`` for
   class 6C, ``k`` encodes the letter in the name of the
   class ('A' = 1, 'B' = 2, ...) e.g. ``k = 3`` for class 6C.

   Output ``v`` is either 0 or a vector in the Leech lattice
   mod 2 found during the computation. Here a vector of type 2
   is returned for classes 2A, 6A; and a vector of type 4 is
   returned for class 4A.

   Caution:

   This is a quick disambiguation of the type of a 2A axis. The
   function may return any axis type if ``v`` is not  a 2A axis.
*/
// %%EXPORT px
uint32_t mm_reduce_2A_axis_type(uint_mmv_t *v)
{
    static uint8_t axes_types[16] = {
           0,  0, 0x82, 0x43,     0xF2, 0x63,  0,   0,
        0xF0,  0, 0xC3,    0,        0, 0x42, 0xF0, 0
    };
    uint32_t norm, res, rank, v2, val_A;
    uint64_t r, v3;
    norm = mm_op15_norm_A(v);
    res = axes_types[norm & 15];
    if (res < 0x0F0) return res << 24;
    r =  mm_op15_eval_A_rank_mod3(v, res & 0xf);    
    rank = (uint32_t)(r >> 48);
    v3 = r & 0xffffffffffffULL;
    
    switch (norm) {
        case 4:
            if (rank == 2) return 0xA1000000;
            if (rank == 23) {
                v2 = gen_leech3to2_short(v3) & 0xffffff;
                val_A = mm_op15_eval_A(v, v2);
                switch (val_A) {
                    case 4:
                        return 0x21000000 + v2;
                    case 7:
                        return 0x61000000 + v2;
                    default:
                        break;
                }
            }
            break;
        case 8:
            if (rank == 8) return 0x22000000;
            if (rank == 24) return 0xA2000000;
            break;
        case 14:
            if (rank == 8) return 0x66000000;
            if (rank == 23) {
                v2 = gen_leech3to2_type4(v3) & 0xffffff;
                return 0x41000000 + v2;
            } 
            break;
        default:
            break;
    }    
    return 0;
}


/////////////////////////////////////////////////////////////////////////
// Store standard 2A axes in a vector
/////////////////////////////////////////////////////////////////////////

/**
  @brief Store the 2A axis \f$v^+\f$ or \f$v^-\f$ at a vector in \f$\rho_{15}\f$

  The function stores the 2A axis \f$v^+\f$ (in case ``sign == 0``)
  or \f$v^-\f$  (in case ``sign != 0``) in the vector referred
  by ``v``. That vector will store an element of the
  representation \f$\rho_{15}\f$ of the monster group as described in
  the header of this file.
  Vectors \f$v^+\f$ and \f$v^-\f$ are defined in [Sey22], Section 6.
*/
// %%EXPORT px
void  mm_reduce_store_axis(uint_mmv_t *v, uint32_t sign)
{
    mm_aux_zero_mmv(15, v);
    static uint32_t sp[4] = {
        (1 << 25) + (2 << 14) + (2 << 8) + 1,
        (1 << 25) + (2 << 14) + (3 << 8) + 15 - 1,
        (1 << 25) + (3 << 14) + (3 << 8) + 1,
        (2 << 25) + (2 << 14) + (3 << 8) 
    };
    sp[3] &= 0xffffff00;
    sp[3] += sign ? 2 : 15 - 2;
    mm_aux_mmv_set_sparse(15, v, sp, 4);
}

/////////////////////////////////////////////////////////////////////////
// Reducing a 2A axis to the standard axis V_START
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 


static int32_t reduce_v_axis(
    uint_mmv_t *v, 
    uint32_t * r, 
    uint32_t std_axis,
    axes_work_t *p_work
)
{
    int32_t status = -1000;
    uint32_t len_r = 0, i, j, len_r1, vt, v4, ax_type, e;
    uint32_t ax_types[3];

    for (i = 0; i < 5; ++i) {
        vt = mm_reduce_2A_axis_type(v);
        if (vt == 0)  return -2;
        ax_types[1] = ax_types[2] = 0;
        ax_type = vt >> 24;
        vt &= 0xffffff;
        switch(ax_type) {
            case 0xC3:
                get_radical(v, 7, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x42;
                ax_types[1] = 0x61;
                break;
            case 0xA2:
                get_radical(v, 4, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x42;
                ax_types[1] = 0x43;
                break;
            case 0xA1:
                get_short(v, 3, 1, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_type4(p_work);
                ax_types[0] = 0x61;
                break;
            case 0x82:
                get_short(v, 1, 0, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x66:
                get_radical(v, 7, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x43;
                break;
            case 0x63:
                get_span(v, 3, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x61:
                get_short(v, 5, 0, p_work);
                xor_entries(p_work, vt);
                v4 = find_type4(p_work);
                ax_types[0] = 0x41;
                break;
            case 0x43:  // case 4C
            case 0x42:  // case 4B
                get_radical(v, 1, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x22;
                break;
            case 0x41:  // case 4A
                v4 = vt;
                ax_types[0] = 0x21;
                break;
            case 0x22:  // case 2B
                get_span(v, 4, p_work);
                v4 = find_type4(p_work);
                ax_types[0] = 0x21;
                break;
            case 0x21:   // case 2A
                if (!std_axis) {
                    vt = v_leech2_adjust_sign(v, vt);
                    r[len_r++] = 0x84000000 + vt;
                    return len_r;
                }
                len_r1 = gen_leech2_reduce_type2(vt, r+len_r);
                if (len_r1 < 0) return -21;
                mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
                len_r += len_r1;
                r[len_r++] = 0x82000000 + vt;
                vt = mm_aux_get_mmv1(15, v, (24+3)*32 + 2);
                if (vt != 15-2) {
                   r[len_r] = 0xB0000200;
                   mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                   len_r += 1;
                }
                mm_reduce_store_axis(p_work->vtmp, 0);
                if (mm_op15_compare(v, p_work->vtmp)) return -22;
                r[len_r++] = 0x84000200;
                return len_r;
            default:
                return -1;
        }

        len_r1 = gen_leech2_reduce_type4(v4, r + len_r);
        if (len_r1 < 0) return -10;
        mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
        len_r += len_r1;
        r[len_r++] = 0x82000000 + (v4 & 0xffffff);
        status = -4;
        for (e = 1; e < 3 && status; ++e) {
            mm_op15_t_A(v, e, p_work->vA);                    
            ax_type = mm_reduce_2A_axis_type(p_work->vA) >> 24;
            for (j = 0; j < 3 && ax_types[j]; ++j) {
                if (ax_type == ax_types[j]) {
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    len_r += 1;
                    status = 0;
                    break;
                }
            }
        }
        if (status)  return status;
    }
    return -3;
}

/// @endcond


/**
  @brief Reduce a 2A axis in \f$\rho_{15}\f$ in to the standard axis \f$v^+\f$

  Input ``v`` in this function must refer to a 2A axis \f$v\f$
  in \f$\rho_{15}\f$ as described in the header of this file.

  The function computes an element \f$h\f$ of the monster group
  with   \f$v \cdot h = v^+\f$. We use the method in [Sey22],
  Section 6 ff. for computing \f$h\f$.

  The function stores \f$h\f$ as a word of generators in the
  array ``r`` as described in the header of this file and returns
  the length of this word.
  
  The buffer referred by ``r`` should have length at least 64.

  Parameter ``std_axis`` is yet to be documented! In the current 
  version is should be set to ``1``.

  A negative return value indicates a fatal error.
*/
// %%EXPORT px
int32_t mm_reduce_v_axis(uint_mmv_t *v, uint32_t std_axis, uint32_t *r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    res =  reduce_v_axis(v,  r, std_axis, p_work);
    free(p_work);
    return res;
}






/////////////////////////////////////////////////////////////////////////
// Reducing a 2A axis to orthogonal to V_START, preserving V_START
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 




static int32_t reduce_v_baby_axis(
    uint_mmv_t *v, 
    uint32_t axis, 
    uint32_t *r,
    axes_work_t *p_work
)
{
    int32_t status = -1000;
    uint32_t len_r = 0, i, j, len_r1, vt, v4, ax_type, e;
    uint32_t ax_types[3];

    for (i = 0; i < 5; ++i) {
        vt = mm_reduce_2A_axis_type(v);
        if (vt == 0)  return -2;
        ax_types[1] = ax_types[2] = 0;
        ax_type = vt >> 24;
        vt &= 0xffffff;
        switch(ax_type) {
            case 0xA1:
                get_short(v, 3, 1, p_work);
                xor_entries(p_work, p_work->v_short[0]);
                v4 = find_ortho_short(p_work, axis);
                ax_types[0] = 0x61;
                break;
            case 0x63:
                get_span(v, 3, p_work);
                v4 = find_ortho_short(p_work, axis);
                ax_types[0] = 0x41;
                break;
            case 0x61:
                get_short(v, 5, 0, p_work);
                xor_entries(p_work, vt);
                v4 = find_ortho_short(p_work, axis);
                ax_types[0] = 0x41;
                break;
            case 0x43:  // case 4C
            case 0x42:  // case 4B
                get_radical(v, 1, p_work);
                v4 = find_ortho_short(p_work, axis);
                ax_types[0] = 0x22;
                break;
            case 0x41:  // case 4A
                v4 = vt;
                ax_types[0] = 0x21;
                break;
            case 0x22:  // case 2B
                if ((mm_op15_eval_A(v, axis) & ~8) == 0) {
                    get_span(v, 4, p_work);
                    v4 = find_ortho_short(p_work, axis);
                    ax_types[0] = 0x21;
                } else return -4;
                break;
            case 0x21:   // case 2A
                j = mm_op15_eval_A(v, axis);
                if (j == 0)  {
                    len_r1 = gen_leech2_reduce_type4(vt ^ axis, r + len_r); 
                    if (len_r1 < 0) return -31;
                    mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
                    if (op_axis(&axis, r + len_r, len_r1)) return -7;
                    len_r += len_r1;
                    r[len_r++] = 0x82000000 + ((vt ^ axis) & 0xffffff);
                    vt = mm_reduce_2A_axis_type(v) & 0xffffff;
                    if ((vt ^ axis ^ 0x800000) & 0xffffff) return -32;
                    vt = v_leech2_adjust_sign(v, vt);
                    e = 1 + (vt >> 24);
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    if (op_axis(&axis, r + len_r, 1)) return -8;
                    vt = gen_leech2_op_word(vt, r + len_r, 1);
                    len_r += 1;
                } else  {
                    if (j != 4)  return -33;
                }
                vt = v_leech2_adjust_sign(v, vt);
                if ((vt ^ axis ^ 0x1000000) & 0x1ffffff) return -34;
                //if (axis == V_START) {
                //    mm_reduce_store_axis(p_work->vtmp, 1);
                //    if (mm_op15_compare(v, p_work->vtmp)) return -35;
                //}
                r[len_r++] = 0x86000000 + (axis & 0x1ffffff);
                return len_r;
            default:
                return -1;
        }

        len_r1 = gen_leech2_reduce_type4(v4, r + len_r); 
        if (len_r1 < 0) return -10;
        mm_op15_word(v, r + len_r, len_r1, 1, p_work->vtmp);
        if (op_axis(&axis, r + len_r, len_r1)) return -7;
        len_r += len_r1;
        r[len_r++] = 0x82000000 + (v4 & 0xffffff);
        status = -4;
        for (e = 1; e < 3 && status; ++e) {
            mm_op15_t_A(v, e, p_work->vA);                    
            ax_type = mm_reduce_2A_axis_type(p_work->vA) >> 24;
            for (j = 0; j < 3 && ax_types[j]; ++j) {
                if (ax_type == ax_types[j]) {
                    r[len_r] = 0xD0000003 - e;
                    mm_op15_word(v, r + len_r, 1, 1, p_work->vtmp);
                    if (op_axis(&axis, r + len_r, 1)) return -8;
                    len_r += 1;
                    status = 0;
                    break;
                }
            }
        }
        if (status)  return status;
    }
    return -3;
}


/// @endcond 


/**
  @brief Reduce feasible 2A axis to the feasible axis \f$v^-\f$

  Input ``v`` in this function must refer to a 2A axis \f$v\f$
  in \f$\rho_{15}\f$ as described in the header of this file.
  Also this axis must be orthogonal to the the standard
  axis \f$v^+\f$. Such an axis is called feasible
  in [Sey22], Section 8.

  The function computes an element \f$h\f$ of the monster group
  with  \f$v \cdot h = v^-\f$ and  \f$v^+ \cdot h = v^+\f$. We
  use the method in loc. cit. for computing \f$h\f$.
  If no such element \f$h\f$ exists then the function returns
  an undefined value \f$h\f$.

  The function stores \f$h\f$ as a word of generators in the
  array ``r`` as described in the header of this file and returns
  the length of this word.

  Parameter ``axis`` is yet to be documented! In the current 
  version is should be set to ``0x200``.
  
  The buffer referred by ``r`` should have length at least 64.

  A negative return value indicates a fatal error.
*/
// %%EXPORT px
int32_t mm_reduce_v_baby_axis(uint_mmv_t *v, uint32_t axis, uint32_t * r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    res =  reduce_v_baby_axis(v, axis, r, p_work);
    free(p_work);
    return res;
}



/// @cond DO_NOT_DOCUMENT 

/**
  @brief Workhorse for function ``mm_reduce_G_x0``

  Input parameters and return value are as in 
  function ``mm_reduce_G_x0``. The additional input 
  parameter  ``p_work`` must refer to a strcture of 
  type ``axes_work_t``.
*/
static inline int32_t reduce_G_x0(
    uint32_t *a, 
    uint32_t n, 
    uint32_t std_axis, 
    uint32_t *r,
    axes_work_t *p_work
    )
{
    int32_t len1, res;
    uint32_t axis;
    mm_reduce_store_axis(p_work->v, 0);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) return res;
    r[0] = 0x80000000;
    len1 = res = reduce_v_axis(p_work->v, r+1, std_axis, p_work);
    if (res <  0) return res;
    ++len1;
    mm_reduce_store_axis(p_work->v, 1);
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res <  0) return res;
    res = mm_op15_word(p_work->v, r, len1, 1, p_work->vtmp);
    if (res <  0) return res;
    axis = std_axis ? V_START : r[len1 - 1] & 0x1ffffff ;
    res = reduce_v_baby_axis(p_work->v, axis, r + len1, p_work);
    if (res <  0) return res;
    res = len1 + res;
    return res;
}

/// @endcond 




/**
  @brief Reduce element of monster to element of subgroup \f$G_{x0}\f$

  Let \f$g\f$ be the element of the monster given as a word of
  generators in the buffer ``a`` of length ``n``. The function
  computes an element \f$h\f$ of the monster with
  \f$g \cdot h \in H\f$. Here \f$H\f$ is a subgroup of the monster
  of structure \f$2^{2+22}.\mbox{Co}_2\f$ as defined in [Sey22],
  Section 6. We use the method in ibid. for computing \f$h\f$.

  The function stores \f$h\f$ as a word of generators in the
  array ``r`` as described in the header of this file and returns
  the length of this word.
  
  The buffer referred by ``r`` should have length at least 64.

  A negative return value indicates a fatal error.  
*/
// %%EXPORT px
int32_t mm_reduce_G_x0(uint32_t *a,  uint32_t n, uint32_t std_axis, uint32_t *r)
{
    int32_t res;
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;
    res = reduce_G_x0(a, n, std_axis, r, p_work);
    free(p_work);
    return res;
}


/**
  @brief Reduce an element in the monster group

  This is the most important function in the project. It reduces
  an arbitrary element \f$g\f$ of the monster to an element \f$h\f$.
  The size of the element \f$h\f$ depends on the value of \f$g\f$ 
  as an element of the monster group, but not of the representation 
  of  \f$g\f$.

  Let \f$g\f$ be the element of the monster given as a word of
  generators in the buffer ``a`` of length ``n``. Then the function
  computes the reduced element \f$h\f$ of the monster with 
  \f$g = h\f$. We use the method in [Sey22] for computing \f$h\f$.

  The function stores \f$h\f$ as a word of generators in the 
  array ``r`` as described in the header of this file and returns
  the length of this word.
  
  The buffer referred by ``r`` should have length at least 128.

  A negative return value indicates a fatal error.  
*/
// %%EXPORT px
int32_t mm_reduce_M(uint32_t *a,  uint32_t n, uint32_t *r)
{
    int32_t len1, len2, res;

    // This function combines functions  mm_reduce_G_x0 and
    // mm_order_check_in_Gx0. Here we cut and paste the code of both 
    // functions, for reducing  the overhead of memory allocation.
    // First allocate memory for both subfunctions.
    axes_work_t *p_work = calloc(1, sizeof(axes_work_t));
    if (p_work == 0) return -1;

    // Execute function mm_reduce_G_x0
    len1 = res = reduce_G_x0(a, n, 1, r, p_work);
    if (res <  0) goto done;

    // Let ``g1`` be the element of the monster stored in
    // ``r[0,...,len1-1]``. Then ``h := g * g1`` is now in the
    // Subgroup ``G_x0`` of the monster.

    // Put p_work->v = v0 * h
    mm_order_load_vector(p_work->v); 
    res = mm_op15_word(p_work->v, a, n, 1, p_work->vtmp);
    if (res < 0) goto done;
    res = mm_op15_word(p_work->v, r, len1, 1, p_work->vtmp);
    if (res < 0) goto done;

    // Now we essentially apply function t mm_order_check_in_Gx0
    // to find a representation of ``h`` in generators of ``G_x0``.
    res = mm_order_find_in_Gx0(p_work->v, r + len1);
    if (res > 0x100) res = -0x200;
    if (res < 0) goto done; 
    len2 = res = mm_order_find_in_Qx0(p_work->v, r + len1, 
          p_work->vtmp);
    if (res < 0) goto done;

    // Now ``r[len1,...,len1+len2-1]``  contains ``h``. We will compute
    // the result ``h * g1**(-1)`` in ``r[0,...,len1+len2-1]`` and
    // return res = len1 + len2.
    mm_group_invert_word(r + len1, len2);
    mm_group_invert_word(r, res = len1 + len2);
  
done:
    free(p_work);
    return res;
}



//  %%GEN h
/// @endcond 
//  %%GEN c
