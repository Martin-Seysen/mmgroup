/** @file mm_reduce.c


*/

#include "mm_reduce.h"   
   
// %%EXPORT_KWD MM_REDUCE_API




/////////////////////////////////////////////////////////////////////////
// Definitions of internally-used structures
/////////////////////////////////////////////////////////////////////////


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 


#define MAX_GT_WORD_DATA 24


/// @endcond 



/** 
   @brief Yet to be documented
*/
typedef struct gt_subword_type {
    uint32_t type;                  /** 0 = unused, 1 = node, 2 = end node */
    uint32_t length;                /** No of entries in component data */
    uint32_t data[MAX_GT_WORD_DATA]; /** Element of monster group */
    uint32_t img_Omega;             /** Image of Omega under element*/
    uint32_t img_Omega_inv;         /** Image of Omega under inverse elem.*/
    struct gt_subword_type *p_prev; /** Pointer to previous subword */
    struct gt_subword_type *p_next; /** Pointer to previous subword */
    struct gt_word_type  *p_master; /** Pointer to master word */
} gt_subword_type;




/** 
   @brief Yet to be documented
*/
typedef struct gt_word_type {
    uint32_t n_subwords;            /** Max No of subwords allocated */
    struct gt_subword_type *p_fst;  /** Pointer to first subword */
    struct gt_subword_type *p_end;  /** Pointer to end mark subword */
    struct gt_subword_type *p_free; /** Pointer list of free subwords */
    gt_subword_type a[1];           /** Array of subwords */
} gt_word_type;





#define SIZE_GT_WORD_DATA(n) (sizeof(gt_word_type) + (n)*sizeof(gt_subword_type))






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/////////////////////////////////////////////////////////////////////////
// Manipulating the doubly linked list
/////////////////////////////////////////////////////////////////////////


/**
@brief Yet to be documented!

*/
// %%EXPORT p
uint32_t gt_word_size(uint32_t n) 
{
    return sizeof(gt_word_type) + n*sizeof(gt_subword_type);
}


/**
@brief Yet to be documented!

*/
// %%EXPORT p
void gt_word_init(gt_word_type *p_gtw, uint32_t n)
{
    uint32_t i;
    p_gtw->n_subwords = 0;
    for (i = 1; i <= n; ++i) {
       p_gtw->a[i].type = 0;
       p_gtw->a[i].p_next = &(p_gtw->a[i + 1]);
       p_gtw->a[i].p_master = p_gtw;
    }
    p_gtw->a[n-1].p_next = NULL;
    p_gtw->a[0].p_next = p_gtw->a[0].p_prev = NULL;
    p_gtw->a[0].type = 2; 
    p_gtw->a[0].p_master = p_gtw;
    p_gtw->a[0].length = 0;
    p_gtw->a[0].img_Omega = 0;
    p_gtw->a[0].img_Omega_inv = 0;
    p_gtw->p_fst = p_gtw->p_end = &(p_gtw->a[0]);
    p_gtw->p_free =  &(p_gtw->a[1]);
    p_gtw->n_subwords = n;
} 


/**
@brief Yet to be documented!

*/
// %%EXPORT p
gt_subword_type *gt_subword_insert(gt_subword_type *p_gtsub)
{
    gt_word_type *p_master;
    gt_subword_type *p_new, *p_prev;

    if (p_gtsub == NULL || p_gtsub->type == 0) return NULL;
    p_master = p_gtsub->p_master;
    p_new = p_master->p_free;
    p_prev = p_gtsub->p_prev;

    if (p_new == NULL) return NULL;
    p_master->p_free = p_new->p_next;

    p_new->p_next = p_gtsub;
    p_gtsub->p_prev = p_new;
    p_new->p_prev = p_prev;
    if (p_prev != NULL) p_prev->p_next = p_new;
    else p_master->p_fst = p_new;

    p_new->type = 1; 
    p_new->length = 0;
    p_new->img_Omega = 0;
    p_new->img_Omega_inv = 0;
    return p_new;  
}

/**
@brief Yet to be documented!

*/
// %%EXPORT p
gt_subword_type *gt_subword_delete(gt_subword_type *p_gtsub)
{
    gt_word_type *p_master;
    gt_subword_type *p_next, *p_prev;
 
    if (p_gtsub == NULL || p_gtsub->type != 1) return NULL;
    p_master = p_gtsub->p_master;
    p_next = p_gtsub->p_next;
    p_prev = p_gtsub->p_prev;

    p_gtsub->type = 0;
    p_gtsub->p_next = p_master->p_free;
    p_master->p_free = p_gtsub;

    p_next->p_prev = p_prev;
    if (p_prev != NULL) p_prev->p_next = p_next;
    else p_master->p_fst = p_next;
    return p_next;  
}



/////////////////////////////////////////////////////////////////////////
// Load a subword
/////////////////////////////////////////////////////////////////////////



/**
@brief Yet to be documented!

*/
// %%EXPORT px
uint32_t gt_word_n_subwords(uint32_t *a,  uint32_t n)
{
    uint32_t i, k = 0;
    for (i = 0; i < n; ++i) if ((a[i] & 0x70000000) == 0x50000000) ++k;
    return k;
}




#define MAX_INTERN_WORD_DATA (MAX_GT_WORD_DATA+40)


/**
@brief Yet to be documented!

*/
// %%EXPORT p
int32_t gt_subword_load(gt_subword_type *p_gtsub, uint32_t *a,  uint32_t n)
{
    uint32_t i = 0, j, ulen = 0, e, w[MAX_INTERN_WORD_DATA], g[5];
    int32_t res;

    if (p_gtsub->type != 1) return -1;
    do {
        for ( ; i < n; ++i) {
            uint32_t v = a[i];
            uint32_t tag = v & 0x70000000;
            switch(tag) {
                case 0:
                    continue;
                case 0x70000000:
                    return -1;
                case 0x50000000:
                   if ((v & 0xfffffff) % 3 == 0) continue;
                   goto end_scan_Gx0;
                default:
                   if ((v & 0xfffffff) == 0) continue;
                   w[ulen++] = v; 
                   break;
            }               
            if (ulen > MAX_INTERN_WORD_DATA - 5) {
                if ((res = xsp2co1_reduce_word(w, ulen, w)) < 0) 
                   return res;
                ulen = res;
            }
        }
      end_scan_Gx0:
        mm_group_n_clear(g);
        i += mm_group_n_mul_word_scan(g, a + i, n - i);
        e = mm_group_n_right_coset_N_x0(g);
        ulen += mm_group_n_to_word(g, w + ulen);
    } while (e == 0);
    if (ulen > MAX_GT_WORD_DATA -1) {
       if ((res = xsp2co1_reduce_word(w, ulen, w)) < 0) return res;
       ulen = res;
    }
    if (e > 0) w[ulen++] = 0x50000000 + e;
    p_gtsub->length = ulen;
    for (j = 0; j < ulen; ++j) p_gtsub->data[j] = w[j];
    p_gtsub->img_Omega = p_gtsub->img_Omega_inv = 0;
    return i;
}


/**
@brief Yet to be documented!

*/
// %%EXPORT p
int32_t gt_word_load(gt_word_type *p_gtw, uint32_t *a,  uint32_t n)
{
    uint32_t i = 0, j;
    gt_subword_type *p_new;

    if ((p_gtw->p_fst->type) != 2) gt_word_init(p_gtw, p_gtw->n_subwords);

    while (i < n) {
        if ((p_new = gt_subword_insert(p_gtw->p_fst)) == NULL) return -1;
        if ((j = gt_subword_load(p_new, a + i,  n - i)) < 0) return j;
        i += j;
    } 
    return 0;
}




/**
@brief Yet to be documented!

*/
// %%EXPORT p
int32_t gt_word_length(gt_word_type *p_gtw)
{
    uint32_t length = 0, nwords = 0;
    gt_subword_type *p_cur = p_gtw->p_fst;
    for (; p_cur->type != 2; p_cur = p_cur->p_next) {
        if (nwords++ > p_gtw->n_subwords) return -2;
        if (p_cur->p_master != p_gtw) return -3;
        if (p_cur->type != 1) return -4;
        if (p_cur->length > MAX_GT_WORD_DATA) return -5;
        length += p_cur->length;
    } 
    return length;
}



/**
@brief Yet to be documented!

*/
// %%EXPORT p
int32_t gt_word_store(gt_word_type *p_gtw, uint32_t *pa, uint32_t maxlen)
{
    uint32_t *p_out = pa, *p_end = pa + maxlen, *p_data, j;
    gt_subword_type *p_cur = p_gtw->p_fst;
    for (; p_cur->type == 1; p_cur = p_cur->p_next) {
        if  (p_out + (j = p_cur->length) > p_end) return -1; 
        p_data = p_cur->data; 
        while (j--) *p_out++ = *p_data++;
    } 
    return (int32_t)(p_out - pa);
}




//  %%GEN h
/// @endcond  
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif

