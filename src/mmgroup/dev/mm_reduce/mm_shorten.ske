/** @file mm_shorten.c

 This file contains function for reducing a word of generators
 of the Monster group. Here word reduction is done by computations
 in the subgroups \f$G_{x0} = 2^{1+24}.\mbox{Co}_1\f$
 and \f$N_0 = 2^{2+11+22}.(\mbox{Mat}_{24} \times \mbox{Sym}_3)\f$.
 To some extent, we will also compute in the Frobenius group
 of order 21 generated by the generators \f$\tau\f$ and \f$\xi\f$
 of the Monster.
 
 Internally, we store a word ``a`` of generators of the Monster in
 a structure of type ``gt_word_type``. Here the word ``a`` is
 split into subwords, where each subword is in the double
 coset \f$G_{x0} N_0\f$. Such a subword is represented as a word
 of generators of  \f$G_{x0}\f$, followed by a power of the
 triality element \f$\xi\f$. A subword is stored in a structure
 of type ``gt_subword_type``.

 Unless otherwise stated, a negative return value of a function
 is this module indicates an error.

 Structures required for this module are defined in
 file ``mm_reduce.h``.


 The following code block demonstrates the reduction of a word
 with the functions in this module (ignoring error handling).

 @code
 // Assume that the following buffer contains a word ``g``
 // of length 10 of generators of the Monster group
 #define INPUT_LENGTH 10
 uint32_t in_buf[INPUT_LENGTH]; 
 // Declare a sufficiently long output buffer
 #define MAX_OUTPUT_LENGTH 20
 uint32_t out_buf[MAX_OUTPUT_LENGTH];
 // Define a reduction mode as specified in function gt_word_alloc
 #define REDUCTION_MODE 1 
 // Allocate a structure for reduction
 gt_word_type* p_gt = gt_word_alloc(REDUCTION_MODE, NULL, 0);
 // Enter the word ``g`` into that structure
 gt_word_append(p_gt, in_buf, INPUT_LENGTH);
 // Reduce the word in that structure
 gt_word_reduce(p_gt);
 // Store the reduced word in the output buffer and the actual
 // length of that word in variable output_length
 int32_t output_length;
 output_length = gt_word_store(p_gt, out_buf, MAX_OUTPUT_LENGTH);
 // Free the allocated structure
 gt_word_free(p_gt);
 @endcode



*/

/// @cond DO_NOT_DOCUMENT 
#include "mm_reduce.h"   
/// @endcond 
   




/////////////////////////////////////////////////////////////////////////
// Definitions of internally-used structures
/////////////////////////////////////////////////////////////////////////


//  %%GEN h

/// @cond DO_NOT_DOCUMENT 
#define MAX_GT_WORD_DATA 24

/// @endcond 



/** 
   @brief Stucture to store a subword of generators of the Monster

   This structure is required in file ``mm_shorten.c``.

   It stores a subword of a word in the Monster in a node
   of a circular doubly-linked list. There is a dedicated EOF (end of
   file) mark in that list, in which member ``eof``is set to 1; and
   elsewhere member ``eof`` is set to zero. Note that standard
   operations like insertions and deletions are easier in a circular
   doubly-linked list than in a standard doubly-linked list.

   Member ``data`` contains a word \f$g\f$ of generators of the
   subgroup \f$G_{x0}\f$; and member ``t_exp`` contains an
   exponent \f$0 \leq e < 3\f$. Then the structure represents the
   element  \f$g \tau^e\f$ of the Monster, where  \f$\tau\f$  is
   the triality element in the subgroup  \f$N_0\f$ of the Monster.

   The length of a word in member ``data`` is limited to the
   size ``MAX_GT_WORD_DATA - 1``; and we will reduce that word
   using function ``xsp2co1_reduce_word`` in module ``xsp2co1.c``
   if necessary. Note that member ``data`` may contain atoms with
   tags ``'x', 'y', 'd', 'p', 'l'`` only, and the inversion bit
   in such an atom is always cleared.

   Member ``img_Omega`` contains the image \f$g \cdot \Omega\f$,
   where \f$\Omega\f$ is the standard frame of the Leech lattice
   mod 2. Here ``img_Omega`` is given in Leech lattice encoding.
   Member ``reduced`` is 1 if the word in member ``data`` is
   reduced (by function ``xsp2co1_reduce_word``) and 0 otherwise.
   
*/
struct gt_subword_s {
    uint32_t eof;        ///< 0 means standard subword, 1 means EOF mark 
    uint32_t length;     ///< Number of entries in component ``data``
    uint32_t img_Omega;  ///< Image of \f$\Omega\f$ under element
    uint32_t t_exp;      ///< Exponent of final tag 't' 
    uint32_t reduced;    ///< True if part 'data' is reduced 
    struct gt_subword_s *p_prev;     ///< Pointer to previous subword 
    struct gt_subword_s *p_next;     ///< Pointer to previous subword 
    uint32_t data[MAX_GT_WORD_DATA]; ///< Element of monster group 
} ;




/** 
   @brief typedef for structure ``struct gt_subword_s``
*/
typedef struct gt_subword_s gt_subword_type;

/** 
   @brief Structure to store an array of entries of type ``gt_subword_type``

   We allocate several entries of of type ``gt_subword_type`` with a
   single call to function ``malloc``. This saves a considerable amount
   of interaction with the operating system.

   This structure contains an array of type ``gt_subword_type[]`` plus
   the necessary bookkeeping information.
*/
struct gt_subword_buf_s {
    uint32_t capacity;   ///< max No of type ``gt_subword_s `` entries
    uint32_t n_used;     ///< used No of type ``gt_subword_s `` entries
    struct gt_subword_buf_s *p_next; ///< Pointer to next buffer
    gt_subword_type subwords[1];     ///< array of subwords in this buffer
} ;




/** 
   @brief typedef for structure ``struct gt_subword_buf_s``
*/
typedef struct gt_subword_buf_s gt_subword_buf_type;



/** 
   @brief Stucture to store a word of generators of the Monster

   This structure is required in file ``mm_shorten.c``.

   It stores a word in the Monster in a circular
   doubly-linked list of nodes of type ``gt_subword_type``. Each of
   these node represents subword of that word, and there is a
   dedicated EOF (end of file) mark in that list that marks both,
   the beginning and the end of the list. Member ``p_end`` always
   points to the EOF mark.

   The structure contains a pointer ``p_node`` pointing to one of
   the nodes of the list, which we will call the **current** node.
   Some functions in these module take a pointer to this structure,
   and the perform operations on the current node. The pointer may
   be manipulated with function ``gt_word_seek``.

*/
typedef struct {
    gt_subword_type *p_end;   ///< Pointer to the **end mark** subword 
    gt_subword_type *p_node;  ///< Pointer to current subword 
    gt_subword_type *p_free;  ///< Pointer to list of free subwords
    int32_t reduce_mode;      ///< Mode for the reduction of a word 

    /* memory management */
    uint32_t is_allocated;    ///< 1 if this structure has been allcocated
    gt_subword_buf_type *pb0; ///< pointer to first buffer
    gt_subword_buf_type *pbe; ///< pointer to last buffer
    gt_subword_buf_type buf;  ///< 1st buffer containing Array of subwords 
} gt_word_type;





// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


/////////////////////////////////////////////////////////////////////////
// Definitions in the C file
/////////////////////////////////////////////////////////////////////////

/// @cond DO_NOT_DOCUMENT 

#define SIZE_GT_WORD_DATA(n) (sizeof(gt_word_type) + (n)*sizeof(gt_subword_type))

#define OMEGA 0x800000

#define _ERROR(source, error) ((-(source) << 24) - ((-(error)) & 0xffffff)) 


/// @endcond  




/////////////////////////////////////////////////////////////////////////
// Memory management
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 


// Min capacity (in units of struct gt_subword_s) of an allocated buffer
#define MIN_CAPACITY 32
// Max capacity (in units of struct gt_subword_s) of an allocated buffer
#define MAX_CAPACITY 0x8000
// Size of an allocated buffer of type gt_word_type in bytes
#define MIN_GT_WORD_BYTELENGTH (sizeof(gt_word_type) +  \
                    (MIN_CAPACITY - 1) * sizeof(gt_subword_type))
// Memory alignment for a buffer provided by the user
#define ALIGN_MEM ((uintptr_t)16)




/* @brief Initialize a buffer of type ``gt_word_type``

This function initializes an (already allocated) buffer referred
by ``p_gt`` of a given ``bytesize``. The number of entries of
the circular doubly linked list stored in that buffer is not known
in advance. Thus functions adding entries to that list might have
to call ``malloc`` for allocating for such entries. Here
function ``_gt_word_new_subword`` returns a pointer to a new entry
of the linked list. Function ``_gt_word_delete_all_subwords`` frees
all memory  allocated by function ``_gt_word_new_subword``.

In order to avoid memory leaks, only the three functions mentioned
above will allocate or free memory for entries of the linked list.
The following activities are out of the scope of these three funtions:

allocating and deallocating the buffer referred by ``p_gt``,
manipulating the doubly linked list in that buffer, recycling of
entries of that list which are no longer used.

For recycling such entries, will will use the pointer ``p_gt->p_free``
in other functions.

The buffer referred by ``p_gt`` already contains memory for a number
of entries of the linked list (at least for one entry). Any such
entry is of type ``gt_subword_type``.
If ``bytesize < MIN_GT_WORD_BYTELENGTH`` then the buffer referred
by ``p_gt`` is to small and the function fails. The function
returns 0 in case of success and -1 in case of failure.
*/ 
static inline int32_t 
_gt_word_init(gt_word_type *p_gt, size_t bytesize)
{
   gt_subword_buf_type *p_buf;
   if (bytesize < sizeof(gt_word_type)) return -1;
   p_buf = &(p_gt->buf);
   p_gt->pb0 = p_gt->pbe = p_buf;
   p_buf->capacity = (uint32_t)((bytesize - sizeof(gt_word_type)) /
                    sizeof(gt_subword_type)) + 1;
   p_buf->n_used = 0;
   p_buf->p_next = NULL;
   p_gt->p_end = p_gt->p_node = p_gt->p_free = NULL;
   return 0;
}

/* @brief Create entry for the linked list in ``gt_word_type `` object

The function returns a new entry of type ``gt_subword_type`` to be
used in the circular doubly linked list stored in the bufter of
type ``gt_word_type`` referred by ``p_gt``. Such an entry can be used
in the linked list associated with ``p_gt`` only. The function returns
a pointer to the new entry in case of success and ``NULL`in case of
failure.

In order to reduce the calls to the function ``malloc``, we maintain
buffers of type ``gt_subword_buf_type``, where any such buffer may
may contain an arbitrary number of entries. This number of entries
cannot be changed after creating the buffer. We have to allocate a
new buffer when more entries are needed. We double the size of such
a buffer when allocating memory for a new buffer. Thus ``n`` buffers
can be created with ``O(log n)`` calls to ``malloc``.
*/ 
static inline gt_subword_type* 
_gt_word_new_subword(gt_word_type *p_gt)
{
   gt_subword_buf_type *p_buf = p_gt->pbe, *p_nextbuf;
   uint32_t capacity = p_buf->capacity;
   if (p_buf->n_used < capacity) {
       return p_buf->subwords + (p_buf->n_used)++;
   }
   capacity <<= 1;
   if (capacity < MIN_CAPACITY) capacity =  MIN_CAPACITY;
   if (capacity > MAX_CAPACITY) capacity =  MAX_CAPACITY;
   p_nextbuf = malloc( sizeof(gt_subword_buf_type) +
       (capacity - 1) * sizeof(gt_subword_type) );
   if (p_nextbuf == NULL) return NULL;

   p_nextbuf->capacity = capacity;
   p_nextbuf->n_used = 1;
   p_nextbuf->p_next = NULL;
   p_gt->pbe = p_buf->p_next =  p_nextbuf;
   return p_nextbuf->subwords;
}

/* @brief Delete entries for the linked list in ``gt_word_type `` object

The function frees all buffers for entries to be used in the circular
doubly linked list associated with the buffer of
type ``gt_word_type`` referred by ``p_gt``. All these entries have been
createdby function ``_gt_word_new_subword``.
*/ 
static void
_gt_word_delete_all_subwords(gt_word_type *p_gt)
{
    gt_subword_buf_type *p_buf = p_gt->pb0->p_next, *p_next;
    while (p_buf != NULL) {
        p_next = p_buf->p_next;
        free(p_buf);
        p_buf = p_next;
    }
    p_gt->pbe = p_buf = p_gt->pb0;
    p_buf->n_used = 0;
    p_buf->p_next = NULL;
    p_gt->p_end = p_gt->p_node = p_gt->p_free = NULL;
}


/// @endcond  


/////////////////////////////////////////////////////////////////////////
// Creating and manipulating the doubly linked list
/////////////////////////////////////////////////////////////////////////






/**
@brief Low-level function

Set a subword to the empty subword.

*/
// %%EXPORT p
void gt_subword_clear(gt_subword_type *p_gtsub)
{
    p_gtsub->length = p_gtsub->t_exp = 0; 
    p_gtsub->img_Omega =  OMEGA;
    p_gtsub->reduced = 1; 
    p_gtsub->eof = 0;
} 

/// @cond DO_NOT_DOCUMENT 


static inline void set_eof_word(gt_word_type *p_gt)
{
   p_gt->p_end = p_gt->p_node = _gt_word_new_subword(p_gt);
   p_gt->p_end->p_prev = p_gt->p_end->p_next = p_gt->p_end;
   p_gt->reduce_mode = 1;
   gt_subword_clear(p_gt->p_end);
   p_gt->p_end->eof = 1;
} 


/// @endcond  



/**
@brief Create a structure of type ``gt_word_type``

This function creates a valid structure of type ``gt_word_type``
and returns a pointer to that structure. The returned structure
contains the empty word of generators of the Monster. If a
buffer ``p_buffer`` of ``nbytes``  bytes length is given as a
parameter then the structure may be ininitalized inside this
buffer. We recommend ``nbytes >= 4096``.

If ``p_buffer = NULL`` or ``nbytes`` is too small then a buffer
is allocated via the C function ``malloc``. You should always use
the returned pointer as a pointer to a valid  structure of
type ``gt_word_type`` containing the neutral element of the Monster.

The structure referred by returned pointer will contain the
circular doubly linked list with a single entry of
type ``gt_subword_type``. This entry is an end-of-file mark.
So the whole word stored in that structure corresponds to the
neutral element of the Monster group. 

In any case function ``gt_word_free`` must be called to
free all buffers allocated by this function and, possibly, by
other function in this module applied to the pointer returned
by this function.

Parameter ``mode`` specifies the reduction mode:

``mode = 0`` means no reduction. Here the user has to apply the
low-level functions in this module to perform reduction. This 
mode is used for testing.

``mode = 1`` means the maximum possible reduction which is supported.

``mode = 2`` means a lazy mode of reduction. The idea is to reduce
only in cases where we can expect a substantial decrease of the word
length. This mode is faster than ``mode = 1``.


This function returns ``NULL`` in case of failure, e.g. if the C
function ``malloc```fails to allocate memory.
*/
// %%EXPORT p
gt_word_type *gt_word_alloc(uint32_t mode, void *p_buffer, size_t nbytes)
{
    gt_word_type *p_gt = NULL;

    if (p_buffer != NULL) {
        uintptr_t slack = (((uintptr_t)p_buffer + ALIGN_MEM - 1)
                            & (0-ALIGN_MEM)) - (uintptr_t)p_buffer;
        if (nbytes > (size_t) slack + MIN_GT_WORD_BYTELENGTH) {
            p_buffer = (unsigned char*)p_buffer + slack;
            nbytes -= (size_t)slack;
        } else p_buffer = NULL;
    }
    if (p_buffer == NULL) {
        p_gt = malloc(nbytes = MIN_GT_WORD_BYTELENGTH);  
        if (p_gt == NULL) return NULL;
        p_gt->is_allocated = 1;  
    } else {
        p_gt = p_buffer;
        p_gt->is_allocated = 0;  
    }
    if (mode > 2) mode = 1;
    p_gt->reduce_mode = mode;
    if (_gt_word_init(p_gt, nbytes) != 0) goto failure;
    set_eof_word(p_gt);
    if (p_gt->buf.n_used != 1) goto failure;
    return p_gt;

  failure:
    if (p_gt->is_allocated) free(p_gt);
    return NULL;
} 



/**
@brief Free a structure of type ``gt_word_type``

This function frees the memory allocated to a structure of
type ``gt_word_type`` created by function ``gt_word_alloc``.
Ultimately, it must be applied to all pointers created by
function ``gt_word_alloc`` in order to avoid memory leaks. It
is safe to apply function ``gt_word_free`` to the ``NULL``
pointer.
*/
// %%EXPORT p
void gt_word_free(gt_word_type *p_gt)
{
    if (p_gt == NULL) return;
    _gt_word_delete_all_subwords(p_gt);
    if (p_gt->is_allocated) free(p_gt);
}



/**
@brief Set content of the structure ``*p_gt`` to the empty word

This function sets the value of the structure of type ``gt_word_type``
referred by ``p_gt`` to the neutral element of the Monster. It also
frees all allocated memory blocks referred by ``p_gt``, except for
the block ``p_gt`` itself.
*/
// %%EXPORT p
void gt_word_clear(gt_word_type *p_gt)
{
    if (p_gt == NULL) return;
    _gt_word_delete_all_subwords(p_gt);
    set_eof_word(p_gt);
}







/**
@brief Low-level function

Insert an empty subword after the current subword pf ``*p_gt`` and
set the position of the current subword to the new subword.

Return a negative value if out of memory.
*/
// %%EXPORT p
int32_t gt_word_insert(gt_word_type *p_gt)
{
    gt_subword_type *p_new, *p_cur, *p_next;

    if (p_gt->p_free == NULL) {
        p_new = _gt_word_new_subword(p_gt);
        if (p_new == NULL) return -1;
    } else {
        p_new = p_gt->p_free;
        p_gt->p_free = p_new->p_next;
    }
    gt_subword_clear(p_new);

    p_cur = p_gt->p_node;
    p_next = p_cur->p_next;
    p_new->p_next = p_next;
    p_new->p_prev = p_cur;
    p_cur->p_next = p_next->p_prev = p_gt->p_node = p_new;
    return 0;  
}

/**
@brief Low-level function

Delete the current subword, and set the position of the current
subword to its predecessor.

Return a negative value on an attempt to delete an EOF mark.
*/
// %%EXPORT p
int32_t gt_word_delete(gt_word_type *p_gt)
{
    gt_subword_type *p_prev, *p_cur, *p_next;
 
    if ((p_cur = p_gt->p_node)->eof) return _ERROR(1, -2);
    p_next = p_cur->p_next;
    p_prev = p_cur->p_prev;

    p_gt->p_node = p_next->p_prev = p_prev;
    p_prev->p_next = p_next;

    p_cur->p_next = p_gt->p_free;
    p_gt->p_free = p_cur;

    return 0;  
}




/**
@brief Low-level function

Move the pointer to the current subword to position 'pos'
Her pos = 0 means the EOF mark if 'set' is True,
and the position of the current subword otherwise.
pos = i+1 means the subword after  pos = i,
pos = i-1 means node subword  pos = i.


It is an error to move p_gt->p_node across the EOF node.
When starting at the EOF node we may move forward or back
until finding the EOF node once again, but not any further.
*/
// %%EXPORT p
int32_t gt_word_seek(gt_word_type *p_gt, int32_t pos, uint32_t set)
{
    int32_t i;
    if (set) p_gt->p_node = p_gt->p_end;
    if (pos > 0) {
        for (i = 1; i <= pos; ++i) {
            p_gt->p_node = p_gt->p_node->p_next;
            if (p_gt->p_node->eof && pos != i) return _ERROR(1, -3);
        }
    } else if (pos < 0) {
        for (i = -1; i >= pos; --i) {
            p_gt->p_node = p_gt->p_node->p_prev;
            if (p_gt->p_node->eof && pos != i) return _ERROR(1, -4);
        }
    }
    return 0;
}






/////////////////////////////////////////////////////////////////////////
// Append part of a monster group element to a subword
/////////////////////////////////////////////////////////////////////////

/// @cond DO_NOT_DOCUMENT 
#define MAX_INTERN_WORD_DATA (MAX_GT_WORD_DATA+40)

/// @endcond






/**
@brief Low-level function

Try to append a prefix of word 'a' of length 'n' to the current subword.
Return number of atoms of 'a' sucessfully appended to that word.
A negative return value inducates an error.
*/
// %%EXPORT p
int32_t gt_word_append_sub_part(gt_word_type *p_gt, uint32_t *a,  uint32_t n)
{
    
    gt_subword_type *p_cur = p_gt->p_node;
    uint32_t i = 0, ulen = 0, img_omega_len = 0, j, e, v;
    uint32_t reduced = p_cur->reduced;
    uint32_t w[MAX_INTERN_WORD_DATA], g[5];
    int32_t res;

    if (p_cur->eof) return 0;
    img_omega_len = ulen = p_cur->length;
    e = p_cur->t_exp;
    for (j = 0; j < ulen; ++j) w[j] = p_cur->data[j];
    
    while (1)  {
        mm_group_n_clear(g);
        g[0] = e;
        i += mm_group_n_mul_word_scan(g, a + i, n - i);
        e = mm_group_n_right_coset_N_x0(g);
        j = mm_group_n_to_word(g, w + ulen);
        reduced &= !j;
        ulen += j;
        if (e || i >= n) break;
        v = a[i++];
        if ((v & 0x70000000) != 0x60000000) return _ERROR(2,-1);
        v ^=  0 - ((v >> 31) & 1);
        v = (v & 0xfffffff) % 3;
        if (v) {
            w[ulen++] = v + 0x60000000;
            reduced = 0;
        }
        if (ulen > MAX_INTERN_WORD_DATA - 6) {
            if ((res = xsp2co1_reduce_word(w, ulen, w)) < 0) 
                   return _ERROR(-0x10, res);
            ulen = res;
            img_omega_len = 0;
            p_cur->img_Omega = OMEGA;
            reduced = 1;
        }
    }
    p_cur->t_exp = e;
    if (ulen > MAX_GT_WORD_DATA - 1) {
       if ((res = xsp2co1_reduce_word(w, ulen, w)) < 0) 
          return _ERROR(-0x11, res);
       ulen = res;
       img_omega_len = 0;
       p_cur->img_Omega = OMEGA;
       reduced = 1;
    }
    p_cur->img_Omega = gen_leech2_op_word_leech2(p_cur->img_Omega, 
        w + img_omega_len, ulen - img_omega_len, 0);
    p_cur->length = ulen;
    p_cur->reduced = reduced;
    for (j = 0; j < ulen; ++j) p_cur->data[j] = w[j];
    return i;
}






/////////////////////////////////////////////////////////////////////////
// Reduce a subword
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 

/**
@brief Low-level function

Compute 'complexity' of an element \f$g\f$ of \f$G_{x0}\f$ from
the image of \f$\Omega\f$  under \f$g\f$ .

Here the complexity of \f$g\f$ is the minimum number of atoms
of tag ``l`` required to represent \f$g\f$.
*/
static inline uint32_t complexity(uint32_t img_omega)
{
    uint32_t weight;
    if (img_omega & 0x800) return 3;
    if ((img_omega & 0x7ff800) == 0) return (img_omega & 0x7fffff) != 0;
    weight = (MAT24_THETA_TABLE[(img_omega >> 12) & 0x7ff] >> 12) & 1;
    return 2 + weight;
}

/**
@brief Low-level function

Return True if an element  \f$g\f$ of \f$G_{x0}\f$ stored in the
array of ``a`` of length ``n`` is so complex that lazy reduction
is worth the effort.

Here Parameter ``l_weight`` is the output of function ``complexity``
applied to \f$g\f$.
*/
static inline 
uint32_t over_complex(uint32_t *a, uint32_t n, uint32_t l_weight)
{
    uint32_t n_atoms[8], i;

    if (n > 12) return 1;

    for (i = 0; i < 8; ++i) n_atoms[i] = 0;
    for (i = 0; i < n; ++i) ++(n_atoms[(a[i] >> 28) & 7]);
    if (n_atoms[6] > l_weight) return 1;        // tag 'l'
    if (n_atoms[2] > l_weight + 1) return 1;    // tag 'p'
    if (n_atoms[3] > 1) return 1;               // tag 'x'
    if (n_atoms[4] > 1) return 1;               // tag 'y'
    if (n_atoms[1] > 2) return 1;               // tag 'd'
    return 0;
}


/// @endcond


/**
@brief Low-level function

Reduce current subword

sub_mode = 0: lazy reduction (just some word shortening)

sub_mode = 1: standard reduction

sub_mode = 2: as sub_mode 0, but move also prefix in N_x0 to previous subword

sub_mode = 3: as sub_mode 1, but move also prefix in N_x0 to previous subword
*/
// %%EXPORT p
int32_t gt_word_reduce_sub(gt_word_type *p_gt, uint32_t sub_mode)
{
    gt_subword_type *p_cur = p_gt->p_node;
    uint32_t *w;
    int32_t res;
    uint32_t i, j;
    if (p_cur->eof || p_cur->length == 0) {
        p_cur->reduced = 1;
        return 0;
    }
    w = p_cur->data;
    if (!p_cur->reduced) {
        uint32_t reduce = sub_mode & 1;
        if (reduce == 0) {
            uint32_t l_weight = complexity(p_cur->img_Omega);
            reduce = over_complex(w, p_cur->length,l_weight); 
        }
        if (reduce) {
            res = xsp2co1_reduce_word(w, p_cur->length, w);
            if (res < 0) return _ERROR(-0x12, res);
            p_cur->length = res;
            p_cur->reduced = 1;
        }
    }
    if (sub_mode < 2 || p_cur->p_prev->eof) return 0;
    for (i = 0; i < p_cur->length; ++i) {
       if ((w[i] & 0x70000000) == 0x60000000) break;
    }
    if (i) {
        p_gt->p_node = p_cur->p_prev;
        if ((res = gt_word_append_sub_part(p_gt, w, i)) < 0) return res;
        p_gt->p_node = p_cur;
        p_cur->length -=  i;
        p_cur->reduced &= ((uint32_t)res == i);
        for (j = 0; j < p_cur->length; ++j) w[j] = w[i + j];
    }
    return 0;
}


/////////////////////////////////////////////////////////////////////////
// Join a subword with its predecessors if possible
/////////////////////////////////////////////////////////////////////////



/**
@brief Low-level reduction function

Try to join current subwort ``p_gt->p_node`` with its predecessor.
Return 1 and let ``p_gt->p_node`` point to first node being changed
if the rule could be applied.
Return 0 and do not change ``p_gt->p_node`` this is not the case.
Return a negative number in case of a fatal error.
*/ 
// %%EXPORT p
int32_t gt_word_rule_join(gt_word_type *p_gt)
{
    gt_subword_type *p_cur, *p_prev;
    int32_t res;

    p_cur = p_gt->p_node;
    if (p_cur->eof) return 0;
    p_prev = p_cur->p_prev;
    if (p_prev->eof) {
        if (p_cur->img_Omega == OMEGA && p_cur->t_exp == 0) {
            res = xsp2co1_reduce_word(
                p_cur->data, p_cur->length, p_cur->data);
            if (res < 0) return _ERROR(-0x14, res);
            if (res == 0) {
                gt_word_delete(p_gt);
                p_gt->p_node = p_gt->p_node->p_next;
                return 1;
            }
            p_cur->length = res;
            p_cur->reduced = 1;
        }
        return 0;
    }

    if (p_prev->t_exp == 0) {
        gt_word_delete(p_gt);
        if (p_gt->p_node != p_prev) return _ERROR(2, -0x104);
        p_cur->data[p_cur->length++] = 0x50000000 + p_cur->t_exp;
        res = gt_word_append_sub_part(p_gt, p_cur->data, p_cur->length);
        if (res != (int32_t)p_cur->length) 
            return res < 0 ? res : _ERROR(2, -4);
        return 1;
    } else if (p_cur->img_Omega == OMEGA) {
        gt_word_delete(p_gt);
        if (p_gt->p_node != p_prev) return _ERROR(2, -0x105);
        res = xsp2co1_reduce_word(
             p_cur->data, p_cur->length, p_cur->data);
        if (res < 0) return _ERROR(-0x14, res);
        p_cur->length = res;
        p_cur->data[p_cur->length++] = 0x50000000 + p_cur->t_exp;
        res = gt_word_append_sub_part(p_gt, p_cur->data, p_cur->length);
        if (res != (int32_t)p_cur->length) 
            return res < 0 ? res : _ERROR(2, -5);
        return 1;
    } 
    return 0;
}




/////////////////////////////////////////////////////////////////////////
// Replace t^e xi^f t^g g by xi^e' t^f' xi^g' 
/////////////////////////////////////////////////////////////////////////

/// @cond DO_NOT_DOCUMENT 

/***************************************************************
Every element ``g = t^e[0] xi^e[1] t^e[2]`` of the Monster 
group with ``1 <= e[i] <= 2`` can also be expressed in the 
form ``g = xi^f[0] t^f[1] xi^f[2]`` with ``1 <= f[i] <= 2``.
Put ``e = e[0] - 1 + 2 * (e[1] - 1) + 4 * (e[2] - 1)``
and ``f = f[0] - 1 + 2 * (f[1] - 1) + 4 * (f[2] - 1)``.
Then ``0 <= e, f < 8``; and the change of the representation 
of ``g`` mentioned above can be considered as a 
function ``F_TLT : {0,...,7} -> {0,...,7}`` that maps ``e`` 
to ``f``. We encode the precomputed function ``F_TLT`` in the 
following constant ``TLT_CONVERSION``
as ``F_TLT(e) = (TLT_CONVERSION >> (e << 2)) & 7``.
****************************************************************/

#define TLT_CONVERSION  %{hex:ORDER_VECTOR_TLT_CONVERSION}
#define F_TLT(e) ((TLT_CONVERSION >> ((e) << 2)) & 7)

/// @endcond


/**
@brief Low-level reduction function

This function tries to apply a reduction rule:

\f$\tau^{e_1} \xi^{e_2} \tau^{e_3} \rightarrow \xi^{e_4} \tau^{e_5} \xi^{e_6}\f$.

Such a rule exists for all \f$0 < e_1, e_2, e_3 < 3\f$. This rule is
applied to the subword ``p_gt->p_node`` and to its predecessor. Applying
such a rule decreases the number of generators \f$\tau^{\pm 1}\f$
in a word.

The function returns 1 and lets ``p_gt->p_node`` point to first node
being changed if such rule could be applied. It returns 0 and does not
change ``p_gt->p_node`` this is not the case.
It returns a negative number in case of a fatal error.

To show the existence of suitable reduction rules as mentioned above we 
put \f$a = \tau \xi^{-1}\f$. Then we verify that \f$a\f$ has order 7 
and that \f$\tau^{-1} a \tau = a^2\f$ holds. Therefore is suffices to 
verify that the group operations corresponding to these relations fix 
the 'order vector' in the representation \f$\rho_{15}\f$ .

Since \f$\tau\f$ has order 3, the group generated by \f$\tau\f$
and \f$a\f$  (and hence also  the group generated by \f$\tau\f$
and \f$\xi\f$) is visibly a Frobenius group of order 21. Finding
suitable reduction rules in such a group is easy.
*/ 
// %%EXPORT p
int32_t gt_word_rule_t_xi_t(gt_word_type *p_gt)
{
    gt_subword_type *p_cur, *p_prev;
    int32_t res;
    uint32_t e, f, l[2], pi = 0, len;

    p_cur = p_gt->p_node;
    if (p_cur->eof) return 0;
    if (p_cur->t_exp == 0) return 0;
    p_prev = p_cur->p_prev;
    if (p_prev->eof) return 0;
    if (p_prev->t_exp == 0) return 0;
    if (complexity(p_cur->img_Omega) != 1) return 0;
    if ((res = gt_word_reduce_sub(p_gt, 3)) < 0) return res;
    if (p_cur->t_exp < 1 || p_cur->t_exp > 2) return -501;
    if (p_prev->t_exp < 1 || p_prev->t_exp > 2) return -502;
    switch (p_cur->length) {
        case 2:
           pi = p_cur->data[1];
           if ((pi >> 28) != 2) return -503;
        case 1:
           e = p_cur->data[0];
           if (e < 0x60000001 || e > 0x60000002) return -0x504;
           break;
        default:
           return -505;
    }

    // Now the last atom in ``*p_prev`` is ``t^e[0]``, and
    // we have  ``*p_cur = xi^e[1] t^e[2]``, for some
    // 1 <= e[i] <= 2. 
    // Let ``g = t^e[0] ^ xi^e[1] t^e[2]`` as in the comment above.
    // We will replace ``g`` by ``xi^f[0] t^f[1] xi^f[2]`` as
    // indicated in that comment.

    // Compute ``f = F_TLT(e)`` with ``e, f`` as in the comment.
    e = ((e-1) & 1) << 1;
    e += (p_prev->t_exp - 1);
    e += (p_cur->t_exp - 1) << 2;
    f = F_TLT(e);

    // Store xi^[(f & 1)/4 + 1)] in ``*p_cur``.
    gt_subword_clear(p_cur);
    l[0] = 0x60000001 + ((f >> 2) & 1);
    l[1] = pi;
    len =  1 + (pi != 0);
    if (gt_word_append_sub_part(p_gt, l,len) != (int32_t)len)  
         return -0x508;

    // Move the pointer to its predecessor ``p_prev``
    p_gt->p_node = p_prev;  // point to  ``*p_prev``

    // Kill the last atom ``t^e[0]`` in ``*p_prev``.
    p_prev->t_exp = 0;  
    // Append l = xi^((f & 1) + 1))  ^((f & 1)/2 + 1)) to ``*p_prev``.
    l[0] = 0x60000001 + (f & 1);
    l[1] = 0x50000001 + ((f >> 1) & 1);
    p_gt->p_node = p_prev;  // point to  ``*p_prev``
    if (gt_word_append_sub_part(p_gt, l, 2) != 2) return -0x507;
    return 1;
}



/////////////////////////////////////////////////////////////////////////
// Reduce a word
/////////////////////////////////////////////////////////////////////////


/// @cond DO_NOT_DOCUMENT 

/**
@brief Low-level reduction function

Yet to be documented!
*/ 
// %%EXPORT p
int32_t gt_word_reduce_input(gt_word_type *p_gt)
{
    int32_t res;
    while (!p_gt->p_node->eof) {
        res = gt_word_rule_join(p_gt);
        if (res < 0) return res;
        if (res== 0) res = gt_word_rule_t_xi_t(p_gt);
        if (res < 0) return res;
        if (res == 0) p_gt->p_node = p_gt->p_node->p_next; 
    }
    return 0;
}

/// @endcond 


/////////////////////////////////////////////////////////////////////////
// Append element of the monster group to a word
/////////////////////////////////////////////////////////////////////////


/**
@brief Append word of generators to strcture ``*p_gt``

Append the word ``a`` of length ``n`` to the word in the buffer
refered by ``p_gt``.

A negative return value inducates an error.

At exit, pointer ``p_gt->p_node`` will point to the ``EOF`` mark.
*/
// %%EXPORT p
int32_t gt_word_append(gt_word_type *p_gt, uint32_t *a, uint32_t n)
{
    int32_t res;
    uint32_t i = 0;
    p_gt->p_node = p_gt->p_end->p_prev;
    while (i < n) {
        if ((res = gt_word_insert(p_gt)) < 0) return res;
        if ((res = gt_word_append_sub_part(p_gt, a + i,  n - i)) <= 0) 
            return res < 0 ? res : _ERROR(2,-3);
        i += res;
        if (p_gt->reduce_mode) {
            res = gt_word_reduce_input(p_gt);
            if (res < 0) return res;
            p_gt->p_node = p_gt->p_end->p_prev;
        }
    }
    p_gt->p_node = p_gt->p_end; 
    return 0;    
}


/////////////////////////////////////////////////////////////////////////
// Store a word or a subword as an array of atoms
/////////////////////////////////////////////////////////////////////////


/**
@brief Return number of subwords required to store element of the Monster


Return (an upper bound for) the number of subwords in a doubly
linked list of type ``gt_word_type`` required to store the word
of generators of the Monster of length ``n`` referred by ``a``.
*/
// %%EXPORT px
uint32_t gt_word_n_subwords(uint32_t *a, uint32_t n)
{
    uint32_t i, k = 1;
    for (i = 0; i < n; ++i) if ((a[i] & 0x70000000) == 0x50000000) ++k;
    return k;
}



/**
@brief Return the length of the word stored in ``*p_gt``.

*/
// %%EXPORT p
int32_t gt_word_length(gt_word_type *p_gt)
{
    uint32_t length = 0;
    gt_subword_type *p_cur = p_gt->p_end->p_next;
    for (; p_cur->eof == 0; p_cur = p_cur->p_next) {
        length += p_cur->length + (p_cur->t_exp != 0);
    } 
    return length;
}





/**
@brief Reduce the word stored in ``*p_gt``.


The function reduces the word \f$g\f$ stored in the 
structure ``*p_gt``. The mode of reduction depends on the 
parameter ``mode`` passed to function ``gt_word_alloc`` when 
creating that structure. The function returns:

0 if \f$g\f$ is not known to be in any subgroup of the Monster

4 if \f$g\f$ is known to be in \f$G_{x0} \cdot N_0\f$

5 if \f$g\f$ is known to be in \f$N_0\f$

6 if \f$g\f$ is known to be in \f$G_{x0}\f$

7 if \f$g\f$ is known to be in \f$N_{x0} = G_{x0} \cap N_0\f$

A negative value in case of failure.

If the return value is > 0  (i.e. if we
know \f$g \in G_{x0} \cdot N_0\f$) then we also have
performed a full reduction of the result.
*/
// %%EXPORT p
int32_t gt_word_reduce(gt_word_type *p_gt)
{
    uint32_t sub_mode = p_gt->reduce_mode == 2 ? 2 : 3;
    gt_subword_type *p_old = p_gt->p_node, *p_fst;
    int32_t res, res1;

    p_gt->p_node = p_gt->p_end->p_prev;
    for ( ; p_gt->p_node->eof == 0; p_gt->p_node = p_gt->p_node->p_prev) {
        res = gt_word_reduce_sub(p_gt, sub_mode);
        if (res < 0) return res;
    }
    p_gt->p_node = p_old;

    // Find out in which subgroup we are
    p_fst = p_gt->p_end->p_next;                // obtain first subword
    if (p_fst == p_gt->p_end) return 3;         // done if word is empty
    if (p_fst->p_next != p_gt->p_end) return 0; // ignorant if >1 subwords

    // Here we are in  \f$G_{x0} \cdot N_0\f$
    res = 4;
    if ((p_fst->img_Omega & 0x7fffff) == 0) res |= 1; // are we in N_0?
    if (p_fst->t_exp == 0) res |= 2;                  // are we in G_x0?
    // We can reduce the result completely, so we'll just do so.
    p_gt->p_node = p_gt->p_end->p_prev;
    res1 = gt_word_reduce_sub(p_gt, 1);
    if (res1 < 0) return res;
    p_gt->p_node = p_old;
    return res;
}





/**
@brief Store the word in ``*p_gt`` in an array.

The function stores the word in ``*p_gt`` in the array ``a`` (of
length ``maxlen``) referred by ``pa``. It returns the actual 
length ``n``of the word stored in the array ``a``.

The function returns a negative value in case of failure, e.g.
if ``n > maxlen``.

*/
// %%EXPORT p
int32_t gt_word_store(gt_word_type *p_gt, uint32_t *pa, uint32_t maxlen)
{
    uint32_t *p_out = pa, *p_end = pa + maxlen, *p_data, n, e;
    gt_subword_type *p_cur;


    p_cur = p_gt->p_end->p_next;
    for ( ; p_cur->eof == 0; p_cur = p_cur->p_next) {
        e = p_cur->t_exp;
        p_data = p_cur->data;
        p_data[n = p_cur->length] = 0x50000000 + e;
        n += e != 0;
        if  (p_out + n > p_end) return _ERROR(2, -7); 
        while (n--) *p_out++ = *p_data++;
    } 
    return (int32_t)(p_out - pa);
}



/////////////////////////////////////////////////////////////////////////
// Compress a fully reduced word into a 256-bit integer
/////////////////////////////////////////////////////////////////////////


/**
@brief Compress word in ``*p_gt`` to strcuture of type ``mm_compress_type``

Yet to be tested and documented!!!

*/
// %%EXPORT p
int32_t gt_word_to_mm_compress(gt_word_type *p_gt, mm_compress_type *p_c)
{
    gt_subword_type *p_fst, *p_cur;
    uint32_t  *p_data, n;
    int32_t status;

    mm_compress_pc_init(p_c, 0);
    if ((status = gt_word_reduce(p_gt)) < 0) return status;
    p_fst = p_cur = p_gt->p_end->p_next;
    for ( ; p_cur->eof == 0; p_cur = p_cur->p_next) {
        if (!(p_cur->reduced)) return -100001;
        p_data = p_cur->data;
        n = p_cur->length;
        if (p_cur == p_fst) {
            status = mm_compress_pc_add_nx(p_c, p_data, n);
            if (status < 0) return status;
        } else status = 0;
        if (status < (int32_t)n && (p_data[status] >> 28) != 6)
            return -1000002;
        status = mm_compress_pc_add_type4(p_c, p_cur->img_Omega);
        if (status < 0) return status;
        status = mm_compress_pc_add_t(p_c, p_cur->t_exp);
        if (status < 0) return status;
    }
    return 0;
}


/**
@brief Compress word in ``*p_gt`` to a 256-bit integer``

Yet to be tested and documented!!!

*/
// %%EXPORT p
int32_t gt_word_compress(gt_word_type *p_gt, uint64_t *p_n)
{
    mm_compress_type c;
    if (gt_word_to_mm_compress(p_gt, &c) < 0) return -1;
    return mm_compress_pc(&c, p_n);
}


/////////////////////////////////////////////////////////////////////////
// Exported functions for shortening a word
/////////////////////////////////////////////////////////////////////////

/**
@brief Reduce a word of generators of the Monster group

Let \f$g\f$ be the word of the monster group of length ``n``
stored in the array ``g``. The function reduces the word \f$g\f$
and stores the reduced word in the buffer ``g1`` of length ``n1max``.
It returns the actual length ``n1`` of the reduced word.

Internally, the function uses a buffer of type ``gt_word_type``
for reduction. Parameter ``mode`` controls the reduction mode;
it is specified as in function ``gt_word_alloc``.

The function returns a negative value in case of failure, e.g.
if ``n1 > n1max ``.

*/
// %%EXPORT px
int32_t gt_word_shorten(uint32_t *g, uint32_t n, uint32_t *g1, uint32_t n1max, uint32_t mode)
{
    gt_word_type* p_gt = gt_word_alloc(mode, NULL, 0);
    uint32_t n1;
    int32_t res = -1, status = 0;

    if (p_gt == NULL) goto done;
    res = gt_word_append(p_gt, g, n);
    status = 2; if (res < 0) goto done;

    res = gt_word_reduce(p_gt);
    status = 3; if (res < 0) goto done;

    n1 = gt_word_length(p_gt);
    status = 4; res = -1;
    if (n1 > n1max) goto done;
    status = 5;
    res = gt_word_store(p_gt, g1, n1);

  done:
    gt_word_free(p_gt);
    if (res >= 0) return res;
    return (int32_t)(((-status << 24) + res) | 0x80000000);

}

//  %%GEN h
/// @endcond  
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif

