"""Generation of C code for the monster representations

This file geneates the C code for computing several representations
of the monster.

More specifically, we compute the rational representation [Seys19] 
of the monster, which is based on the Conway's construction [Conw85] 
of the monster, modulo various small integers p = 2**n-1, n <= 8.
Here the integer p is called the characteristic. We beg the pure 
mathematicians for pardon that p might not be prime, but supporting
different characteristics is useful, e.g. for computing traces of
elements of the monster. Here performance requirements dictate 
p = 2**n-1. Variable PRIMES in file config.py contains the list of
moduli p for which code will be gereated. 

Therefore several .c, .h, .pyd files are created, and also one .pyx
file. Then the Cython package can be used for integrating all C 
functions into a single python library. The action of the Cython
package is controlled by the .pyx file, which also includes the
generated .pyd files.

Function generate_pyx() in this module generates all these files.

Variable INT_BITS in file config.py should be set to 32 or 64 for
32-bit or 64-bit target systems. There might be performace issues
if INT_BITS is not chosen properly. 


Generating .c files
-------------------

We use the C code generation mechanism in class 
make_c_tables.TableGenerator. There .c and .h files are generated
from files with extension .ske which resemble .c files, augmented
with some code generation statements for entering (usually rather
large) tables and automatically generated code into the .c file
to be generated. These .ske files may also have statements for 
automatically generating .h files declaring the exported funtions.  
    
There are C programs that can be used for any characteristics and
C programs used for on special characteristic p only. Note that
writing programs that work for several p are slower than programs
dedicated to a specific p. Some names of .c files are:

   mm_aux,        auxliary functions (used for all p)
   mm_random,     random vector generation (used for all p)

   mm_op{P}_XXX   does operation XXX on the monster modulo p={P}
   mm_op{P}_misc  miscellaneous operations  modulo p={P} 
   
E.g. the .ske file for p=3 is mm_op_misc.ske and the corresponding
.c file to be generated is mm_op3_misc.c. 

Variable C_BASICS_SKELETONS is a list of all generic .ske files,  
C_FILE_SKELETONS is a list of all .ske files for specific values p.


Generating .h and .pxd files
----------------------------

Names of .h files are given by:
   H_BASICS_NAME = "mm_basics.h"  // name of generic header file
   H_FILE_NAME = "mm{P}_op.h"     // name of specific header files, 
                                  // e.g. mm3_op.h

E.g. file mm3_op.h contains all functions required for computing 
in the monster modulo 3. It includes file mm_basics.h.

.pxd files are just wrappers for including the C functions into 
python via the Cython package. They are in 1:1 correspondence to
the header files. Their names are controlled by the variables 
H_BASICS_NAME and H_FILE_NAME.

The header file named by H_BASICS_NAME has prefix given by
H_BASICS_BEGIN and suffix given by H_BASICS_END. The declarations
in this header are generated by function make_basics().
The header files named by H_BASICS_NAME are prefixed by
H_FILE_BEGIN and suffixed by H_FILE_END. The declarations in these
headers are  generated by function make_c_h_pxd(p) for each p.

Apart form the .h file, the functions make_basics() and 
make_c_h_pxd(p) also create the corresponding .c files and the
corresponding  .pxd file. Here each .pxd file is prefixed with 
the declarations given in the variable PYX_DECLARATIONS.

Variable H_FILE_SKELETONS is a list of all .ske files that are
entered ito the header file only, for all pecific values p.



Naming rules for external identifiers in C
------------------------------------------

All external identifiers in any C module in this project must 
follow the conventions for prefixes in file c_prefixes.txt. This 
includes also the names defined by a #define directive in any
C header. 

This convention is also valid for automatically generated C
modules and headers, but not for C modules or headers generated by 
the Cython compiler.


Entering tables and automatically generated code
------------------------------------------------

Class make_c_tables.TableGenerator in directory generate_c provides  
a mechansim for entering tables and automatically generated code 
into a .c file. Conventions for using this mechanism effectively
are given in class mat24aux.Lsbit24Function. 

Variable BASIC_TABLE_CLASSES contains a list of classes providing
tables and automatically generated code to the C functions
generated by the .ske files listed in C_BASICS_SKELETONS. 
Similarly, variable TABLE_CLASSES contains a list of classes 
providing such features to the .ske files listed in 
C_FILE_SKELETONS. All these classes must be coded according to the
conventions given by class at24aux.Lsbit24Function.  

Each C-code generation process done by make_c_tables.TableGenerator
may create tables to be used in C code generated later. The global
dictionary generated_tables maintains a list of all such tables.
That dictionary just stored the public names all of those tables as 
obtained by method export_tables() of class TableGenerator.


Generating the .pyx file
------------------------

A .pyx file with name PYX_FILE_NAME is generated. It controls the
generation of the python wrapper for the C functions with Cython.

The .pyx file contains wrappers for all exported C functions
from the modules listed in C_BASICS_SKELETONS and also for the
modules listed in C_FILE_SKELETONS for all selected
characteristics p. The structure of these exported funtions must 
be extremely simple, so that automatic generation of a wrappers
from the corresponding .pxd files is possible. For details of
this wrapper generation see function make_c_tables.pxd_to_pyx().


Adding functions from modules in mat24
--------------------------------------

Apart from the wrappers mentioned above, function im modules
mat24 und mat24_xi (generated by the process in subdirectory
mat24) are added to the pyx file. The corresponding C functions
are called by the C functions generated in this module. So they
are needed in the generated library anyway, and we add the
python wrappers to the .pyx file in order to avoid duplication
of C code. This is done in function  mat24_pyx_lines(). 


Augmenting the .pyx file
------------------------

The .pyx file is augmented by some python functions and classes 
which allow more convenient access to the C functions.

We add some hand coded functions to the .pyx file as given by 
the variable PYX_FUNCTIONS. Examples are the creation of a numpy
array suitable for storing a monster rep vector or the creation 
of a seed for the internal random generator.

Then we create classes that collect functions for operations
modulo p for each of the characteristics p supported. These 
classes are stored in the dictionary MM. So MM[p] contains 
functions for characteristic p.

Prefixes of functions collected in MM[p] are stripped off in 
a reasonable way. Details are given in class _MM_{p} in 
file mm_op.pyx. Here prefix manipulation is controlled by the 
variable PYX_PARTIALS. Function generate_mm_p_classes() creates 
the relevant part of the .pyx file.
 
 
Generating documentation
------------------------
 
Function generate_doc() may be used for generating some
documentation from the generated C files. 

References
----------
See file references.txt
"""


from __future__ import absolute_import, division, print_function
from __future__ import  unicode_literals


import sys
import os
import re
import collections
import warnings
from numbers import Integral

FILE_DIR = os.path.dirname(os.path.realpath(__file__))
DEV_DIR = os.path.dirname(FILE_DIR)
PACKAGE_DIR = os.path.dirname(DEV_DIR)
SRC_DIR =  os.path.dirname(PACKAGE_DIR)


sys.path.append(SRC_DIR)
import mmgroup.dev.mm_basics
from mmgroup.dev import config
from mmgroup.dev.config import INT_BITS, PRIMES
from mmgroup.dev.config import C_DIR, DOC_DIR

from mmgroup.dev.generate_c.make_c_tables import TableGenerator
from mmgroup.dev.generate_c.make_c_tables import format_item 
from mmgroup.dev.generate_c.make_c_tables import make_doc
from mmgroup.dev.generate_c.make_pyx import pxd_to_pyx
from mmgroup.dev.generate_c.make_pyx import pxd_to_function_list

from mmgroup.dev.mm_basics import mm_aux, mm_tables, mm_basics
from mmgroup.dev.mm_basics import mm_tables_xi, mm_random

from mmgroup.dev.hadamard import hadamard_t 
from mmgroup.dev.hadamard import hadamard_xi 

from mmgroup.dev.mm_op import mm_op_pi, mm_op_xy, mm_op_xi
assert sys.path.pop() == SRC_DIR



os.chdir(FILE_DIR)



VERBOSE = 0

##########################################################################
# Generating .c files
##########################################################################




H_FILE_SKELETONS = [
    "mm{P}_op_defines",
]

C_FILE_SKELETONS = [
    "mm{P}_op_pi",
    "mm{P}_op_misc",
    "mm{P}_op_xy",
    "mm{P}_op_t",
    "mm{P}_op_xi",
    "mm{P}_op_word",
]

##########################################################################
# Generating .h and .pxd files files
##########################################################################


H_FILE_NAME = "mm_op{P}.h"


PXD_FILE_NAME = "mm_op{P}.pxd"




### Generate the headers for specific p

H_FILE_BEGIN = """
// %%GEN h
// This header has been created automatically, do not edit!

#ifndef MM_OP{P}_H
#define MM_OP{P}_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mm_basics.h"

"""


H_FILE_END  = """
// %%GEN h
#ifdef __cplusplus
}
#endif
#endif  // #ifndef MM_OP{P}_H

"""


### Declarations for the generated .pxd files


PYX_DECLARATIONS = """
# cython: language_level=3

from __future__ import absolute_import, division, print_function
from __future__ import  unicode_literals

from libc.stdint cimport uint32_t, uint16_t, uint8_t, int32_t
from libc.stdint cimport uint16_t
from libc.stdint cimport uint{INT_BITS}_t as uint_mmv_t


"""


##########################################################################
# Entering contants from class MM_Basics 
##########################################################################

# List of constants added to classes for a specific p from MM_Basics(p)
MM_BASICS_CONSTANTS = [
   "MMV_ENTRIES", "INT_BITS", "LOG_INT_BITS",
   "P", "FIELD_BITS", "LOG_FIELD_BITS", 
   "INT_FIELDS", "LOG_INT_FIELDS", "P_BITS", "MMV_INTS", 
]   

##########################################################################
# Entering tables and automatically generated code
##########################################################################




TABLE_CLASSES = [
    mm_basics.MM_Op,
    #mm_op_pi.Perm24_Standard,
    mm_op_pi.Perm24_Benes,
    mm_op_pi.SmallPerm64,
    mm_op_pi.ScalarProd2048,    
    mm_op_xy.Perm64_xy, 
    hadamard_t.HadamardOpT64,
    hadamard_t.HadamardOpT3,
    hadamard_xi.HadamardOpXi64,
    hadamard_xi.HadamardOpXi16,
    mm_op_xi.MonomialOp_t,
]



    
##########################################################################
# Generating the .pxd file
##########################################################################



PYX_FILE_NAME = "mm_op{P}.pyx"









##########################################################################
# Generating the .c, .h and .pyx file
##########################################################################



def make_c_h_pxd(p):
    """Generate .c files for a specific p from  .ske files 

    The relevant .ske files are listed in variable
    C_FILE_SKELETONS. One corresponding .h and .pxd file
    is also generated. The .c files and the .h file are written 
    to directory given by C_DIR, the .pxd file is written to the 
    current directory.

    Tables and directives for automatically generated C code
    are taken from the classes listed in TABLE_CLASSES.

    Return pair of lists, one of the .c files and one of the.
    .pxd files generated
    """
    tables = {}
    directives = {}
    global generated_tables
    for table_class in TABLE_CLASSES:
        table_instance = table_class(p)
        tables.update(table_instance.tables())
        directives.update(table_instance.directives())
    tg = TableGenerator(tables, directives, verbose = VERBOSE)
    # first generate C files
    c_files = []
    all_ske_files = [H_FILE_BEGIN]
    for name in H_FILE_SKELETONS:
        ske_file = name.format(P = "") + ".ske"
        all_ske_files.append(ske_file)
    for name in C_FILE_SKELETONS:
        ske_file = name.format(P = "") + ".ske"
        c_file = name.format(P = p) + ".c"
        c_path= os.path.join(C_DIR, c_file)
        print("Creating %s from %s" % (c_file, ske_file))
        tg.generate(ske_file, c_path)
        all_ske_files.append(ske_file)
        c_files.append(c_path)
    all_ske_files.append (H_FILE_END)

    # generate .h and .pxd file
    h_file =  H_FILE_NAME.format(P = p)
    h_path =  os.path.join(C_DIR, h_file)
    pxd_file =  PXD_FILE_NAME.format(P = p)
    print("Creating %s from previous .ske files" % h_file)
    tg.generate(all_ske_files, None, h_path)
    pyx_declarations = PYX_DECLARATIONS.format(
       INT_BITS = INT_BITS, P = p)
    tg.generate_pxd(pxd_file, h_file, pyx_declarations)
    return c_files,  [ pxd_file ]







##########################################################################
# Generating the .pyx file
##########################################################################




m_translate_pxd = re.compile("mm_op(\d+)_(\w+)")



def translate_pxd(name):
    m = m_translate_pxd.match(name)
    if (m):
        p, method_name = m.groups()
        return  "op_"  + method_name 
    else:
        return name



def generate_pyx(p, pxd_files):
    """The main function of this module for generating code

    This function generates the .pyx file with name given by PYX_FILE_NAME 
    and stores it in the current directory. Cython will use the .pyx file 
    to build a wrapper for all generated C functions. 
    """
    def pyx_comment(text, f):
        print("\n" + "#"*70 + "\n### %s\n" % text + "#"*70 + "\n\n",file=f)

    f_pyx = open(PYX_FILE_NAME.format(P = p), "wt")
    declarations = PYX_DECLARATIONS.format(INT_BITS = INT_BITS, P = 0)
    print(declarations, file = f_pyx)

    for pxd_f in pxd_files:
        pyx_comment("Wrappers for C functions from file %s" % pxd_f, f_pyx)
        pyx_code = pxd_to_pyx(pxd_f, None, translate_pxd)
        print(pyx_code, file = f_pyx)

    pyx_comment("Constants", f_pyx)
    basis = mm_basics.MM_Basics(p)
    for name in MM_BASICS_CONSTANTS:
        value = getattr(basis, name)
        declaration = "%s = %d\n" % (name, value) 
        print(declaration,  file = f_pyx)

    f_pyx.close()




##########################################################################
# Exported functions for generating code
##########################################################################






if __name__ == "__main__":
    for p in PRIMES:
        c_files,  pxd_files = make_c_h_pxd(p)
        generate_pyx(p, pxd_files)
