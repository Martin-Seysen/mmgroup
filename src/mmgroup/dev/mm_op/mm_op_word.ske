/** @file mm%{P}_op_word.c

 File ``mm%{P}_op_word.c`` implements the operation of the monster
 group on a vector in the representation  \f$\rho_{%{P}}\f$ of the
 monster.

 Here an element of the monster group is implemented as a word of
 atoms as described in the documentation of the header file
 ``mmgroup_generators.h``.

 The representation \f$\rho_{%{P}}\f$ is equal to the
 196884-dimensional representation  \f$\rho\f$ of the monster,
 with coefficients taken modulo %{P}, as defined in
 section **The representation of the monster group**
 in the **API reference**.

 An element of \f$\rho_{%{P}}\f$ is implemented as an array of
 integers of type ``uint_mmv_t`` as described in
 section **Description of the mmgroup.mm extension** 
 in this document.

 The functions in this module use functions from modules
 ``mm%{P}_op_pi.c``, ``mm%{P}_op_xy.c``, ``mm%{P}_op_t.c``, and
 ``mm%{P}_op_xi.c`` for implementing the operations of the 
 different kinds of atoms generating the monster group.
*/


#include "mm_op%{P}.h"   
   
// %%EXPORT_KWD MM_OP%{P}_API


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


/// @cond DO_NOT_DOCUMENT 
#define h (s_it.data)
/// @endcond



/** 
  @brief Compute operation of the monster group on a vector

  Let \f$v\f$ be a vector of the representation \f$\rho_{%{P}}\f$
  of the monster group stored in the array referred by ``v``.

  Let \f$g\f$ be the element of the monster group stored in the
  array of length ``len_g`` referred by the pointer ``g``.

  Then the function computes the vector \f$v \cdot g^e\f$  and 
  overwrites the vector in the array ``v`` with that vector.
  Here \f$e\f$ is the exponent given by the integer ``e``.

  The function requires a work buffer (referrd by ``work``), which
  is an array of ``MM_OP{P}_LEN_V`` entries of type ``uint_mmv_t``.
  So the work buffer has the same size as the vector ``v``.

  The function returns 0 in case of success and a nonzero
  value in case of failure.

  Internally, the function simplifies all substrings of the string 
  representing the word \f$g^e\f$, except for atoms corresponding
  to nonzero powers of the generator \f$\xi\f$. So the user need 
  not 'optimize' the input \f$g\f$. Of course, this simplification
  does not change the input array ``g``.
*/ 
// %%EXPORT px
uint32_t mm_op%{P}_word(uint_mmv_t *v, uint32_t *g, int32_t len_g, int32_t e, uint_mmv_t *work)
{
     uint32_t status;
     uint_mmv_t *p0 = v, *p1 = work, *pt;
     mm_group_iter_t s_it;



     mm_group_iter_start(&s_it, g, len_g, e);
     do {
         status = mm_group_iter_next(&s_it);
         if (h[0]) {
             mm_op%{P}_xi(p0, h[0], p1); 
             pt = p0; p0 = p1; p1 = pt;
         }
         if (h[1]) {
             mm_op%{P}_t(p0, h[1], p1);
             pt = p0; p0 = p1; p1 = pt;
         }
         if (h[2] | h[3]) {
             mm_op%{P}_xy(p0, h[2], h[3], h[4], p1);
             h[4] = 0;
             pt = p0; p0 = p1; p1 = pt;
         }
         if (h[5]) {
             mm_op%{P}_pi(p0, h[4], h[5], p1);
             pt = p0; p0 = p1; p1 = pt;
         } else if (h[4]) {
             mm_op%{P}_delta(p0, h[4], p1);
             pt = p0; p0 = p1; p1 = pt;
         }
     } while (status == 0);
     
     if (p0 != v) mm_op%{P}_copy(work, v);
     return status - 1;
}


/** 
  @brief Restriction of function ``mm_op%{P}_word`` to tag ``A``

  Function ``mm_op%{P}_pi`` computes the operation of an element
  \f$h = g^e\f$ of the monster  group a vector ``v`` and
  overwrites ``v`` with the result of that operation. \f$h\f$
  depends on parameters ``g, len_g,``  and ``e`` of this function.

  Function ``mm_op%{P}_word_tag_A`` computes the same automorphism 
  on the entries of the vector ``v`` with tag ``A`` only, and 
  ignores the other entries of ``v``.
  See section **The representation of the monster group**
  in the **API reference** for tags of entries of a vector in
  the representation of the monster.

  The function overwrites the vector ``v`` with the result. 
  Here only entries of ``v`` with tag ``A`` are changed. 

  Parameters and return value are the same as in function
  ``mm_op%{P}_word``, except that a work buffer is not required
  here. Also, the function fails and returns a nonzero value,
  if the word that makes up the group element \f$h\f$ contains
  any nonzero powers of the generator \f$\tau\f$ of the 
  monster group. Note that such a power of \f$\tau\f$ does 
  not fix the the part of the vector ``v`` with tag ``A``.
  Powers of the generator \f$\tau\f$ correspond to atoms with
  tag ``t``.

  This function is much faster than function ``mm_op%{P}_word``.
*/ 
// %%EXPORT px
int32_t mm_op%{P}_word_tag_A(uint_mmv_t *v, uint32_t *g, int32_t len_g, int32_t e)
{
     uint32_t status;
     mm_group_iter_t s_it;

     mm_group_iter_start(&s_it, g, len_g, e);
     do {
         status = mm_group_iter_next(&s_it);
         if (h[0])  mm_op%{P}_xi_tag_A(v, h[0]); 
         if (h[1])  return -1;
         if (h[2])  mm_op%{P}_y_tag_A(v, h[2]);
         if (h[5])  mm_op%{P}_pi_tag_ABC(v, h[5], 0, 1);
     } while (status == 0);
     if (mm_aux_reduce_mmv_fields(%{P}, v, MM_AUX_OFS_B) < 0) return -1;
     return status - 1;
}

/// @cond DO_NOT_DOCUMENT 
#undef  h 
/// @endcond




//  %%GEN h
/// @endcond
//  %%GEN c
