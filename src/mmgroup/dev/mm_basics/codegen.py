"""Generation of C code for the monster representations

This file geneates the C code for computing several representations
of the monster.

More specifically, we compute the rational representation [Seys19] 
of the monster, which is based on the Conway's construction [Conw85] 
of the monster, modulo various small integers p = 2**n-1, n <= 8.
Here the integer p is called the characteristic. We beg the pure 
mathematicians for pardon that p might not be prime, but supporting
different characteristics is useful, e.g. for computing traces of
elements of the monster. Here performance requirements dictate 
p = 2**n-1. Variable PRIMES in file config.py contains the list of
moduli p for which code will be gereated. 

Therefore several .c, .h, .pyd files are created, and also one .pyx
file. Then the Cython package can be used for integrating all C 
functions into a single python library. The action of the Cython
package is controlled by the .pyx file, which also includes the
generated .pyd files.

Function generate_pyx() in this module generates all these files.

Variable INT_BITS in file config.py should be set to 32 or 64 for
32-bit or 64-bit target systems. There might be performace issues
if INT_BITS is not chosen properly. 


Generating .c files
-------------------

We use the C code generation mechanism in class 
make_c_tables.TableGenerator. There .c and .h files are generated
from files with extension .ske which resemble .c files, augmented
with some code generation statements for entering (usually rather
large) tables and automatically generated code into the .c file
to be generated. These .ske files may also have statements for 
automatically generating .h files declaring the exported funtions.  
    
There are C programs that can be used for any characteristics and
C programs used for on special characteristic p only. Note that
writing programs that work for several p are slower than programs
dedicated to a specific p. Some names of .c files are:

   mm_aux,        auxliary functions (used for all p)
   mm_random,     random vector generation (used for all p)

   mm_op{P}_XXX   does operation XXX on the monster modulo p={P}
   mm_op{P}_misc  miscellaneous operations  modulo p={P} 
   
E.g. the .ske file for p=3 is mm_op_misc.ske and the corresponding
.c file to be generated is mm_op3_misc.c. 

Variable C_BASICS_SKELETONS is a list of all generic .ske files,  
C_FILE_SKELETONS is a list of all .ske files for specific values p.


Generating .h and .pxd files
----------------------------

Names of .h files are given by:
   H_BASICS_NAME = "mm_basics.h"  // name of generic header file
   H_FILE_NAME = "mm{P}_op.h"     // name of specific header files, 
                                  // e.g. mm3_op.h

E.g. file mm3_op.h contains all functions required for computing 
in the monster modulo 3. It includes file mm_basics.h.

.pxd files are just wrappers for including the C functions into 
python via the Cython package. They are in 1:1 correspondence to
the header files. Their names are controlled by the variables 
H_BASICS_NAME and H_FILE_NAME.

The header file named by H_BASICS_NAME has prefix given by
H_BASICS_BEGIN and suffix given by H_BASICS_END. The declarations
in this header are generated by function make_basics().
The header files named by H_BASICS_NAME are prefixed by
H_FILE_BEGIN and suffixed by H_FILE_END. The declarations in these
headers are  generated by function make_c_h_pxd(p) for each p.

Apart form the .h file, the functions make_basics() and 
make_c_h_pxd(p) also create the corresponding .c files and the
corresponding  .pxd file. Here each .pxd file is prefixed with 
the declarations given in the variable PXD_DECLARATIONS.

Variable H_FILE_SKELETONS is a list of all .ske files that are
entered ito the header file only, for all pecific values p.



Naming rules for external identifiers in C
------------------------------------------

All external identifiers in any C module in this project must 
follow the conventions for prefixes in file c_prefixes.txt. This 
includes also the names defined by a #define directive in any
C header. 

This convention is also valid for automatically generated C
modules and headers, but not for C modules or headers generated by 
the Cython compiler.


Entering tables and automatically generated code
------------------------------------------------

Class make_c_tables.TableGenerator in directory generate_c provides  
a mechansim for entering tables and automatically generated code 
into a .c file. Conventions for using this mechanism effectively
are given in class mat24aux.Lsbit24Function. 

Variable BASIC_TABLE_CLASSES contains a list of classes providing
tables and automatically generated code to the C functions
generated by the .ske files listed in C_BASICS_SKELETONS. 
Similarly, variable TABLE_CLASSES contains a list of classes 
providing such features to the .ske files listed in 
C_FILE_SKELETONS. All these classes must be coded according to the
conventions given by class at24aux.Lsbit24Function.  

Each C-code generation process done by make_c_tables.TableGenerator
may create tables to be used in C code generated later. The global
dictionary generated_tables maintains a list of all such tables.
That dictionary just stored the public names all of those tables as 
obtained by method export_tables() of class TableGenerator.


Generating the .pyx file
------------------------

A .pyx file with name PYX_FILE_NAME is generated. It controls the
generation of the python wrapper for the C functions with Cython.

The .pyx file contains wrappers for all exported C functions
from the modules listed in C_BASICS_SKELETONS and also for the
modules listed in C_FILE_SKELETONS for all selected
characteristics p. The structure of these exported funtions must 
be extremely simple, so that automatic generation of a wrappers
from the corresponding .pxd files is possible. For details of
this wrapper generation see function make_c_tables.pxd_to_pyx().


Adding functions from modules in mat24
--------------------------------------

Apart from the wrappers mentioned above, function im modules
mat24 und mat24_xi (generated by the process in subdirectory
mat24) are added to the pyx file. The corresponding C functions
are called by the C functions generated in this module. So they
are needed in the generated library anyway, and we add the
python wrappers to the .pyx file in order to avoid duplication
of C code. This is done in function  mat24_pyx_lines(). 


Augmenting the .pyx file
------------------------

The .pyx file is augmented by some python functions and classes 
which allow more convenient access to the C functions.

We add some hand coded functions to the .pyx file as given by 
the variable PYX_FUNCTIONS. Examples are the creation of a numpy
array suitable for storing a monster rep vector or the creation 
of a seed for the internal random generator.

Then we create classes that collect functions for operations
modulo p for each of the characteristics p supported. These 
classes are stored in the dictionary MM. So MM[p] contains 
functions for characteristic p.

Prefixes of functions collected in MM[p] are stripped off in 
a reasonable way. Details are given in class _MM_{p} in 
file mm_op.pyx. Here prefix manipulation is controlled by the 
variable PYX_PARTIALS. Function generate_mm_p_classes() creates 
the relevant part of the .pyx file.
 
 
Generating documentation
------------------------
 
Function generate_doc() may be used for generating some
documentation from the generated C files. 

References
----------
See file references.txt
"""


from __future__ import absolute_import, division, print_function
from __future__ import  unicode_literals


import sys
import os
import re
import collections
import warnings
from numbers import Integral

FILE_DIR = os.path.dirname(os.path.realpath(__file__))
DEV_DIR = os.path.dirname(FILE_DIR)
PACKAGE_DIR = os.path.dirname(DEV_DIR)
SRC_DIR =  os.path.dirname(PACKAGE_DIR)

sys.path.append(SRC_DIR)
import mmgroup.dev.mm_basics
from mmgroup.dev import config
from mmgroup.dev.config import INT_BITS, PRIMES
from mmgroup.dev.config import C_DIR, DOC_DIR
from mmgroup.dev.mm_basics import mm_aux, mm_tables, mm_basics
from mmgroup.dev.mm_basics import mm_tables_xi, mm_random
from mmgroup.dev.generate_c.make_c_tables import TableGenerator
from mmgroup.dev.generate_c.make_c_tables import format_item 
from mmgroup.dev.generate_c.make_c_tables import make_doc
from mmgroup.dev.generate_c.make_pyx import pxd_to_pyx
from mmgroup.dev.generate_c.make_pyx import pxd_to_function_list
assert sys.path.pop() == SRC_DIR


os.chdir(FILE_DIR)



VERBOSE = 0

##########################################################################
# Generating .c files
##########################################################################

C_BASICS_SKELETONS = [
   "mm_aux",
   "mm_sparse",
   "mm_random",
   "mm_tables",
   "mm_group_n",
   "mm_tables_xi",
]



##########################################################################
# Generating .h and .pxd files files
##########################################################################

H_BASICS_NAME = "mm_basics.h"


PXD_BASICS_NAME = "mm_basics.pxd"


### Generate the basic header


H_BASICS_BEGIN = """

// %%EXPORT_KWD MM_BASICS_API


// %%GEN h
#ifndef MM_BASICS_H
#define MM_BASICS_H

#include <stdint.h>
#include "mat24_functions.h"

// #define MM_BASICS_DLL  // We want a DLL!!


// Generic helper definitions for shared library support
#if defined _WIN32 || defined __CYGWIN__
  #define MM_BASICS_HELPER_DLL_IMPORT __declspec(dllimport)
  #define MM_BASICS_HELPER_DLL_EXPORT __declspec(dllexport)
  #define MM_BASICS_HELPER_DLL_LOCAL
#else
  #if __GNUC__ >= 4
    #define MM_BASICS_HELPER_DLL_IMPORT __attribute__ ((visibility ("default")))
    #define MM_BASICS_HELPER_DLL_EXPORT __attribute__ ((visibility ("default")))
    #define MM_BASICS_HELPER_DLL_LOCAL  __attribute__ ((visibility ("hidden")))
  #else
    #define MM_BASICS_HELPER_DLL_IMPORT
    #define MM_BASICS_HELPER_DLL_EXPORT
    #define MM_BASICS_HELPER_DLL_LOCAL
  #endif
#endif


// Now we use the generic helper definitions above to define MM_BASICS_API 
// and MM_BASICS_LOCAL.
// MM_BASICS_API is used for the public API symbols. It either DLL imports 
// or DLL exports (or does nothing for static build). 
// MM_BASICS_LOCAL is used for non-api symbols.

#ifdef MM_BASICS_DLL // defined if FOX is compiled as a DLL
  #ifdef MM_BASICS_DLL_EXPORTS // defined if we are building the FOX DLL 
                           // (instead of using it)
    #define MM_BASICS_API MM_BASICS_HELPER_DLL_EXPORT
  #else
    #define MM_BASICS_API MM_BASICS_HELPER_DLL_IMPORT
  #endif // MM_BASICS_DLL_EXPORTS
  #define MM_BASICS_LOCAL MM_BASICS_HELPER_DLL_LOCAL
#else // MM_BASICS_DLL is not defined: this means FOX is a static lib.
  #define MM_BASICS_API
  #define MM_BASICS_LOCAL
#endif // MM_BASICS_DLL



typedef uint{INT_BITS}_t uint_mmv_t;


#ifdef __cplusplus
extern "C" {
#endif

"""


H_BASICS_END = """
// %%GEN h

#ifdef __cplusplus
}
#endif
#endif  // #ifndef MM_BASICS_H
"""




### Declarations for the generated .pxd files


PXD_DECLARATIONS = """

from libc.stdint cimport uint32_t, uint16_t, uint8_t, int32_t
from libc.stdint cimport uint16_t
from libc.stdint cimport uint{INT_BITS}_t as uint_mmv_t

INT_BITS = {INT_BITS}
""".format(INT_BITS = INT_BITS)




##########################################################################
# Entering tables and automatically generated code
##########################################################################


BASIC_TABLE_CLASSES = [
    mm_basics.MM_Const,
    mm_aux.MM_IO24,
    mm_tables.MM_OctadTable,
    mm_random.MM_Random_Doc,
    mm_tables_xi.MM_TablesXi,  
]



    
##########################################################################
# Generating the .pyx file
##########################################################################



PXI_FILE_NAME = "mm_basics.pxi"







##########################################################################
# Functions of this module for generating .c, .h and .pyx file
##########################################################################

def list_basics_c_files():
    """Return list of names of c files generated by make_basics()"""
    def c_file(name):
         return os.path.join(C_DIR, name + ".c")
    return [c_file(name) for name in C_BASICS_SKELETONS]


def make_basics():
    """Generate basic .c files from  .ske files 

    The relevant .ske files are listed in variable
    C_BASICS_SKELETONS. One corresponding .h and .pxd file
    is also generated. The .c files and the .h file are written 
    to directory given by C_DIR, the .pxd file is written to the 
    current directory.

    Tables and directives for automatically generated C code
    are taken from the classes listed in BASIC_TABLE_CLASSES.

    Return pair of lists, one of the .c files and one of the.
    .pxd files generated
    """
    tables = {}
    directives = {}
    global generated_tables
    for table_class in BASIC_TABLE_CLASSES:
        table_instance = table_class()
        tables.update(table_instance.tables())
        directives.update(table_instance.directives())
    # print("Basic functions:\n",  directives.keys())
    tg = TableGenerator(tables, directives, verbose = VERBOSE)
    # first generate C files
    c_files = []
    all_ske_files = [H_BASICS_BEGIN]
    for name in C_BASICS_SKELETONS:
        ske_file = name + ".ske"
        c_file = name + ".c"
        c_path = os.path.join(C_DIR, c_file)
        print("Creating %s from %s" % (c_file, ske_file))
        tg.generate(ske_file, c_path)
        all_ske_files.append(ske_file)
        c_files.append(c_path)
    all_ske_files.append (H_BASICS_END)

    # generate .h and .pxd file
    h_file =  H_BASICS_NAME
    h_path =  os.path.join(C_DIR, h_file)
    pxd_file =  PXD_BASICS_NAME
    print("Creating %s from previous .ske files" % h_file)
    tg.generate(all_ske_files, None, h_path)
    tg.generate_pxd(pxd_file, h_file, PXD_DECLARATIONS)
    return c_files,  [ pxd_file ]







##########################################################################
# The main function for generating code
##########################################################################


def generate_files():
    """The main function of this module for generating code

    This function generates all reqired .c files and also the required
    headers.

    It also generates the .pxi file with name given by PYX_FILE_NAME and
    stores it in the current directory. Cython will use the .pxi file to
    build a wrapper for all generated C functions. 
    """
    def pxi_comment(text, f):
        print("\n" + "#"*70 + "\n### %s\n" % text + "#"*70 + "\n\n",file=f)
    c_files,  pxd_files =  make_basics() 
    f_pxi = open(PXI_FILE_NAME, "wt")
    print(PXD_DECLARATIONS, file = f_pxi)
    for pxd_f in pxd_files:
        pxi_comment("Wrappers for C functions from file %s" % pxd_f, f_pxi)
        print(pxd_to_pyx(pxd_f), file = f_pxi)
    f_pxi.close()
    return c_files


##########################################################################
# Functions of this module for generating documentation
##########################################################################


C_FILES_DOCUMENTED = ["mm_random", "mm_aux", "mm_tables" ]


def generate_doc():
    """Function for generating documentation from the genrated C files

    """
    for c_file in C_FILES_DOCUMENTED:
        c_path = os.path.join(C_DIR, c_file + ".c")
        doc_path = os.path.join(DOC_DIR, c_file + "_c_doc.txt")
        make_doc(c_path, doc_path)



if __name__ == "__main__":
    generate_files()
    generate_doc()
