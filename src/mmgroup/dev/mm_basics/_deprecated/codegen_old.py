"""Generation of C code for the monster representations

This file geneates the C code for computing several representations
of the monster.

More specifically, we compute the rational representation [Seys19] 
of the monster, which is based on the Conway's construction [Conw85] 
of the monster, modulo various small integers p = 2**n-1, n <= 8.
Here the integer p is called the characteristic. We beg the pure 
mathematicians for pardon that p might not be prime, but supporting
different characteristics is useful, e.g. for computing traces of
elements of the monster. Here performance requirements dictate 
p = 2**n-1. Variable PRIMES in file config.py contains the list of
moduli p for which code will be gereated. 

Therefore several .c, .h, .pyd files are created, and also one .pyx
file. Then the Cython package can be used for integrating all C 
functions into a single python library. The action of the Cython
package is controlled by the .pyx file, which also includes the
generated .pyd files.

Function generate_pyx() in this module generates all these files.

Variable INT_BITS in file config.py should be set to 32 or 64 for
32-bit or 64-bit target systems. There might be performace issues
if INT_BITS is not chosen properly. 


Generating .c files
-------------------

We use the C code generation mechanism in class 
make_c_tables.TableGenerator. There .c and .h files are generated
from files with extension .ske which resemble .c files, augmented
with some code generation statements for entering (usually rather
large) tables and automatically generated code into the .c file
to be generated. These .ske files may also have statements for 
automatically generating .h files declaring the exported funtions.  
    
There are C programs that can be used for any characteristics and
C programs used for on special characteristic p only. Note that
writing programs that work for several p are slower than programs
dedicated to a specific p. Some names of .c files are:

   mm_aux,        auxliary functions (used for all p)
   mm_random,     random vector generation (used for all p)

   mm_op{P}_XXX   does operation XXX on the monster modulo p={P}
   mm_op{P}_misc  miscellaneous operations  modulo p={P} 
   
E.g. the .ske file for p=3 is mm_op_misc.ske and the corresponding
.c file to be generated is mm_op3_misc.c. 

Variable C_BASICS_SKELETONS is a list of all generic .ske files,  
C_FILE_SKELETONS is a list of all .ske files for specific values p.


Generating .h and .pxd files
----------------------------

Names of .h files are given by:
   H_BASICS_NAME = "mm_basics.h"  // name of generic header file
   H_FILE_NAME = "mm{P}_op.h"     // name of specific header files, 
                                  // e.g. mm3_op.h

E.g. file mm3_op.h contains all functions required for computing 
in the monster modulo 3. It includes file mm_basics.h.

.pxd files are just wrappers for including the C functions into 
python via the Cython package. They are in 1:1 correspondence to
the header files. Their names are controlled by the variables 
H_BASICS_NAME and H_FILE_NAME.

The header file named by H_BASICS_NAME has prefix given by
H_BASICS_BEGIN and suffix given by H_BASICS_END. The declarations
in this header are generated by function make_basics().
The header files named by H_BASICS_NAME are prefixed by
H_FILE_BEGIN and suffixed by H_FILE_END. The declarations in these
headers are  generated by function make_c_h_pxd(p) for each p.

Apart form the .h file, the functions make_basics() and 
make_c_h_pxd(p) also create the corresponding .c files and the
corresponding  .pxd file. Here each .pxd file is prefixed with 
the declarations given in the variable PXD_DECLARATIONS.

Variable H_FILE_SKELETONS is a list of all .ske files that are
entered ito the header file only, for all pecific values p.



Naming rules for external identifiers in C
------------------------------------------

All external identifiers in any C module in this project must 
follow the conventions for prefixes in file c_prefixes.txt. This 
includes also the names defined by a #define directive in any
C header. 

This convention is also valid for automatically generated C
modules and headers, but not for C modules or headers generated by 
the Cython compiler.


Entering tables and automatically generated code
------------------------------------------------

Class make_c_tables.TableGenerator in directory generate_c provides  
a mechansim for entering tables and automatically generated code 
into a .c file. Conventions for using this mechanism effectively
are given in class mat24aux.Lsbit24Function. 

Variable BASIC_TABLE_CLASSES contains a list of classes providing
tables and automatically generated code to the C functions
generated by the .ske files listed in C_BASICS_SKELETONS. 
Similarly, variable TABLE_CLASSES contains a list of classes 
providing such features to the .ske files listed in 
C_FILE_SKELETONS. All these classes must be coded according to the
conventions given by class at24aux.Lsbit24Function.  

Each C-code generation process done by make_c_tables.TableGenerator
may create tables to be used in C code generated later. The global
dictionary generated_tables maintains a list of all such tables.
That dictionary just stored the public names all of those tables as 
obtained by method export_tables() of class TableGenerator.


Generating the .pyx file
------------------------

A .pyx file with name PYX_FILE_NAME is generated. It controls the
generation of the python wrapper for the C functions with Cython.

The .pyx file contains wrappers for all exported C functions
from the modules listed in C_BASICS_SKELETONS and also for the
modules listed in C_FILE_SKELETONS for all selected
characteristics p. The structure of these exported funtions must 
be extremely simple, so that automatic generation of a wrappers
from the corresponding .pxd files is possible. For details of
this wrapper generation see function make_c_tables.pxd_to_pyx().


Adding functions from modules in mat24
--------------------------------------

Apart from the wrappers mentioned above, function im modules
mat24 und mat24_xi (generated by the process in subdirectory
mat24) are added to the pyx file. The corresponding C functions
are called by the C functions generated in this module. So they
are needed in the generated library anyway, and we add the
python wrappers to the .pyx file in order to avoid duplication
of C code. This is done in function  mat24_pyx_lines(). 


Augmenting the .pyx file
------------------------

The .pyx file is augmented by some python functions and classes 
which allow more convenient access to the C functions.

We add some hand coded functions to the .pyx file as given by 
the variable PYX_FUNCTIONS. Examples are the creation of a numpy
array suitable for storing a monster rep vector or the creation 
of a seed for the internal random generator.

Then we create classes that collect functions for operations
modulo p for each of the characteristics p supported. These 
classes are stored in the dictionary MM. So MM[p] contains 
functions for characteristic p.

Prefixes of functions collected in MM[p] are stripped off in 
a reasonable way. Details are given in class _MM_{p} in 
file mm_op.pyx. Here prefix manipulation is controlled by the 
variable PYX_PARTIALS. Function generate_mm_p_classes() creates 
the relevant part of the .pyx file.
 
 
Generating documentation
------------------------
 
Function generate_doc() may be used for generating some
documentation from the generated C files. 

References
----------
See file references.txt
"""


from __future__ import absolute_import, division, print_function
from __future__ import  unicode_literals


import sys
import os
import re
import collections
import warnings
from numbers import Integral


import mm_basics
import config
from config import INT_BITS, PRIMES, C_DIR, DOC_DIR

import  mm_aux, mm_tables, mm_tables_xi
from make_c_tables import TableGenerator, format_item,  pxd_to_pyx
from make_c_tables import pxd_to_function_list
from make_c_tables import make_doc

import mm_op_pi,  mm_op_xy, mm_random, mm_op_xi

sys.path.append(os.path.join("..", "hadamard"))
import hadamard_t 
import hadamard_xi 

VERBOSE = 0

##########################################################################
# Generating .c files
##########################################################################

C_BASICS_SKELETONS = [
   "mm_aux",
   "mm_sparse",
   "mm_random",
   "mm_tables",
   "mm_group_n",
   "mm_tables_xi",
]


H_FILE_SKELETONS = [
    "mm{P}_op_defines",
]

C_FILE_SKELETONS = [
    "mm{P}_op_pi",
    "mm{P}_op_misc",
    "mm{P}_op_xy",
    "mm{P}_op_t",
    "mm{P}_op_xi",
    "mm{P}_op_word",
]

##########################################################################
# Generating .h and .pxd files files
##########################################################################

H_BASICS_NAME = "mm_basics.h"

H_FILE_NAME = "mm_op{P}.h"

PXD_BASICS_NAME = "mm_basics.pxd"

PXD_FILE_NAME = "mm_op{P}.pxd"

### Generate the basic header


H_BASICS_BEGIN = """
// %%GEN h
#ifndef MM_BASICS_H
#define MM_BASICS_H

#include <stdint.h>
#include "mat24_functions.h"

typedef uint{INT_BITS}_t uint_mmv_t;


#ifdef __cplusplus
extern "C" {
#endif

"""


H_BASICS_END = """
// %%GEN h

#ifdef __cplusplus
}
#endif
#endif  // #ifndef MM_BASICS_H
"""


### Generate the headers for specific p

H_FILE_BEGIN = """
// %%GEN h
// This header has been created automatically, do not edit!

#ifndef MM_OP{P}_H
#define MM_OP{P}_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mm_basics.h"

"""


H_FILE_END  = """
// %%GEN h
#ifdef __cplusplus
}
#endif
#endif  // #ifndef MM_OP{P}_H

"""


### Declarations for the generated .pxd files


PXD_DECLARATIONS = """
# cython: language_level=3

from __future__ import absolute_import, division, print_function
from __future__ import  unicode_literals

from libc.stdint cimport uint32_t, uint16_t, uint8_t, int32_t
from libc.stdint cimport uint16_t
from libc.stdint cimport uint{INT_BITS}_t as uint_mmv_t
""".format(INT_BITS = INT_BITS)


##########################################################################
# Entering contants from class MM_Basics 
##########################################################################

# List of constants added to classes for a specific p from MM_Basics(p)
MM_BASICS_CONSTANTS = [
   "MMV_ENTRIES", "INT_BITS", "LOG_INT_BITS",
   "P", "FIELD_BITS", "LOG_FIELD_BITS", 
   "INT_FIELDS", "LOG_INT_FIELDS", "P_BITS", "MMV_INTS", 
]   

##########################################################################
# Entering tables and automatically generated code
##########################################################################


BASIC_TABLE_CLASSES = [
    mm_basics.MM_Const,
    mm_aux.MM_IO24,
    mm_tables.MM_OctadTable,
    mm_random.MM_Random_Doc,
    mm_tables_xi.MM_TablesXi,  
]

TABLE_CLASSES = [
    mm_basics.MM_Op,
    #mm_op_pi.Perm24_Standard,
    mm_op_pi.Perm24_Benes,
    mm_op_pi.SmallPerm64,
    mm_op_pi.ScalarProd2048,    
    mm_op_xy.Perm64_xy, 
    hadamard_t.HadamardOpT64,
    hadamard_t.HadamardOpT3,
    hadamard_xi.HadamardOpXi64,
    hadamard_xi.HadamardOpXi16,
    mm_op_xi.MonomialOp_t,
]


# dictionary of generated tables, deprecated!!!
##!! generated_tables = {}

    
##########################################################################
# Generating the .pyx file
##########################################################################



PYX_FILE_NAME = "mm_op.pyx"

EXTERNAL_PXD_FILES = [
]



##########################################################################
# Augmenting the .pyx file
##########################################################################



# Dictionary of shape prefix : [list of names]
# This encodes a list of pairs <prefix> : <name>,  where name is an
# entry of the list PYX_PARTIALS[<prefix>].
# This is used for stripping of common prefixes of function names
# when collecting the corresponding functions in a class. 
# See class MM_P_ClassGenerator for more info.
PYX_PARTIALS = {
   "mm_aux_": [
       "mmv_size", 
        "read_mmv1", "write_mmv1",  "read_mmv24", "write_mmv24", 
        "get_mmv1", "put_mmv1", "get_mmv", "put_mmv",
        "mmv_to_bytes", "bytes_to_mmv", "random_mmv", 
        "reduce_mmv",
    ], 
   "mm_": ["vector"],
    
}



PYX_FUNCTIONS = """

from functools import partial
import numpy


PROTECT_OVERFLOW =  (17 << {INT_BITS}) // 19

def mmv_array(*args):
    {ap}Create array with data type suitable for a Monster rep vector 

    This is a numpy array of shape given by the positional arguments
    and of type suitable for the monster group.

    For internal purposes only.
    {ap}
    return numpy.zeros(args, dtype = numpy.uint{INT_BITS})

def mm_vector(p, *args):
    {ap}Create zero vector or array suitable for a Monster rep vector 

    Such vectors are implemented as numpy arrays
    E.g.
    mm_vector(3)   # Create a monster rep vector in characteristic p=3
    mm_vector(3,5) # Create an array of 5 such vectors

    The most convenient way to use this function is e.g.:

    from mm_op import MM
    mm3 = MM[3]        # Class containing monster functions for p=3
    v = mm3.vector()   # Create one monster rep vector v for p=3
    mm3.random_mmv(v)  # randomize the vector v
    w = mm3.vector(5)  # Create array of 5 such monster rep vectors 
    w[3] = v           # standard numpy operation
    mm3.get_mmv(v,3)   # get component 3 of v
    {ap}
    assert (p & (p + 1) == 0) and 3 <= p < 256
    vsize = mm_aux_mmv_size(p)
    result = numpy.zeros(args + (vsize + 1,), dtype = numpy.uint{INT_BITS})
    copy = result.reshape(-1, vsize + 1)
    for i in range(copy.shape[0]):
         copy[i, vsize] = PROTECT_OVERFLOW
    return result

def mm_rng_make_seed(rng_no = 0, data = None):
    {ap}Create a seed for the internal random generator

    Here rng_no is the number of the random generator, data is an
    array of bytes used for seeding it, see module mm_random.ske.
    {ap}
    seed = numpy.zeros(266, dtype = numpy.uint8)
    cdef uint8_t[::1] seed_v_ = seed
    if data and len(data):
       a_data =  numpy.array(data, dtype =  numpy.uint8)
       length = len(a_data)
    else:
       length, a_data = 0, numpy.zeros(1, dtype =  numpy.uint8)
    cdef uint8_t[::1] a_data_v_ = a_data
    mm_rng_seed(seed_v_, rng_no, a_data_v_, len(a_data)) 
    del a_data
    return seed


def tag_dict_from_compressed(uint32_t p, d, a):
    cdef uint32_t[::1] pa = a
    cdef uint32_t len_a = len(a)
    cdef uint32_t tag, i, i0, i1, x
    for i in range(len_a):
        x = pa[i]
        tag = (x >> 25) - 1
        i0 = (x >> 14) & 0x7ff
        i1 = (x >> 8) & 0x3f
        x &= p
        try:
            d[("ABCTXZY"[tag], i0, i1)] = x
        except IndexError:
            raise IndexError("Bad compressed entry %s" % hex(pa[i]))        
        

def tag_dict_to_compressed(d, a):
    cdef uint32_t[::1] pa = a
    cdef uint32_t len_a = len(a)
    cdef uint32_t i = 0
    cdef uint32_t tag, i0, i1, x
    for  (t, i0, i1), x in d.items():
        tag = "0ABCTXZY".index(t)
        pa[i] = (tag << 25) + (i0 << 14) + (i1 << 8) + x
        i = i + 1
        if i > len_a:
            raise IndexError("Compressed array tom short")
    return i

    
    
""".format(INT_BITS = INT_BITS, ap = r'"""')


##########################################################################
# Functions of this module for generating .c, .h and .pyx file
##########################################################################

def list_basics_c_files():
    """Return list of names of c files generated by make_basics()"""
    def c_file(name):
         return os.path.join(C_DIR, name + ".c")
    return [c_file(name) for name in C_BASICS_SKELETONS]


def make_basics():
    """Generate basic .c files from  .ske files 

    The relevant .ske files are listed in variable
    C_BASICS_SKELETONS. One corresponding .h and .pxd file
    is also generated. The .c files and the .h file are written 
    to directory given by C_DIR, the .pxd file is written to the 
    current directory.

    Tables and directives for automatically generated C code
    are taken from the classes listed in BASIC_TABLE_CLASSES.

    Return pair of lists, one of the .c files and one of the.
    .pxd files generated
    """
    tables = {}
    directives = {}
    global generated_tables
    for table_class in BASIC_TABLE_CLASSES:
        table_instance = table_class()
        tables.update(table_instance.tables())
        directives.update(table_instance.directives())
    # print("Basic functions:\n",  directives.keys())
    tg = TableGenerator(tables, directives, verbose = VERBOSE)
    # first generate C files
    c_files = []
    all_ske_files = [H_BASICS_BEGIN]
    for name in C_BASICS_SKELETONS:
        ske_file = name + ".ske"
        c_file = name + ".c"
        c_path = os.path.join(C_DIR, c_file)
        ##!! tg.import_names(generated_tables)
        print("Creating %s from %s" % (c_file, ske_file))
        tg.generate(ske_file, c_path)
        ##!! generated_tables.update(tg.export_tables())
        all_ske_files.append(ske_file)
        c_files.append(c_path)
    all_ske_files.append (H_BASICS_END)

    # generate .h and .pxd file
    h_file =  H_BASICS_NAME
    h_path =  os.path.join(C_DIR, h_file)
    pxd_file =  PXD_BASICS_NAME
    print("Creating %s from previous .ske files" % h_file)
    tg.generate(all_ske_files, None, h_path)
    tg.generate_pxd(pxd_file, h_file, PXD_DECLARATIONS)
    return c_files,  [ pxd_file ]


def list_c_files(p):
    """Return list of names of c files generated by make_c_h_pxd(p)"""
    def c_file(name):
         return os.path.join(C_DIR, name.format(P = p) + ".c")
    return [c_file(name) for name in C_FILE_SKELETONS]


def make_c_h_pxd(p):
    """Generate .c files for a specific p from  .ske files 

    The relevant .ske files are listed in variable
    C_FILE_SKELETONS. One corresponding .h and .pxd file
    is also generated. The .c files and the .h file are written 
    to directory given by C_DIR, the .pxd file is written to the 
    current directory.

    Tables and directives for automatically generated C code
    are taken from the classes listed in TABLE_CLASSES.

    Return pair of lists, one of the .c files and one of the.
    .pxd files generated
    """
    tables = {}
    directives = {}
    global generated_tables
    for table_class in TABLE_CLASSES:
        table_instance = table_class(p)
        tables.update(table_instance.tables())
        directives.update(table_instance.directives())
    tg = TableGenerator(tables, directives, verbose = VERBOSE)
    # first generate C files
    c_files = []
    all_ske_files = [H_FILE_BEGIN]
    for name in H_FILE_SKELETONS:
        ske_file = name.format(P = "") + ".ske"
        all_ske_files.append(ske_file)
    for name in C_FILE_SKELETONS:
        ske_file = name.format(P = "") + ".ske"
        c_file = name.format(P = p) + ".c"
        c_path= os.path.join(C_DIR, c_file)
        ##!! tg.import_names(generated_tables)
        print("Creating %s from %s" % (c_file, ske_file))
        tg.generate(ske_file, c_path)
        ##!! generated_tables.update(tg.export_tables())
        all_ske_files.append(ske_file)
        c_files.append(c_path)
    all_ske_files.append (H_FILE_END)

    # generate .h and .pxd file
    h_file =  H_FILE_NAME.format(P = p)
    h_path =  os.path.join(C_DIR, h_file)
    pxd_file =  PXD_FILE_NAME.format(P = p)
    print("Creating %s from previous .ske files" % h_file)
    tg.generate(all_ske_files, None, h_path)
    tg.generate_pxd(pxd_file, h_file, PXD_DECLARATIONS)
    return c_files,  [ pxd_file ]



##########################################################################
# Adding functions from modules in mat24 to the generated .pyx file
##########################################################################

def mat24_pyx_lines():
    """integrate functions from modules in subdirectory mat24

    The coresponding C functions are called as subroutines anyway,
    so we essentially copy the corresponding wrappers from file 
    mat24fast.pyx in subdirectory mat24.

    The function yields the lines from file  mat24fast.pyx to be
    inserted the the generated .pyx file, prefixed by the 
    required declarations.
    """
    pxdfiles =   [ "mat24_functions.pxd",
                   "mat24_xi_functions.pxd",
                 ]   
    pyxfile =   os.path.join("..", "mat24", "mat24fast.pyx")
    for f in pxdfiles: 
        yield '\ninclude r"%s" \n\n' % os.path.join("..", "mat24", f)
    copy = False
    with open(pyxfile, "rt") as f:
        for l in f:
            if l[:7] == "include":
                copy = True
            elif copy: 
                yield l
    yield "\n"




##########################################################################
# Creating classes collecting functions for specific characteristics p
##########################################################################




class MM_P_ClassGenerator(object):
    """Create collection of classes containing C functions

    Each class contains python wrappers for C functions related to the 
    monster group for a specific modulus p.

    The name of the python wrapper function corresponds to the name of 
    the corresponding C function, with a prefix of the C function name 
    being stripped off.

    We generate a dictionary MM with an entry MM[p] for each modulus p. 
    MM[p] is a class containing static functions.
    E.g. the function mm3_op_pi is equivalent to MM[3].op_pi. 

    The rules for stripping of prefixes are as follows:

    The list of .pxd file names given in the construtor is scanned for 
    functions with name mm<p>_<name>. Function mm<p>_<name> is mapped 
    to function MM[<p>].<name>, for an valid modulus p. We use function
    make_c_tables.pxd_to_function_list() to obtain the function names 
    from a .pxd file.

    A dictionary <partials>  is passed to the constructor. This 
    dictionary of shape prefix : [list of names].
    It encodes a list of pairs <prefix> : <name>,  where name is any 
    entry of the list <partials>[<prefix>]. It is used for stripping off 
    common prefixes of function names when collecting the corresponding 
    functions into a class. Then a python function with name 
    <prefix><name> and modulus p as its first parameter must exist. We 
    create an entry  MM[<p>].<name>  so that  MM[<p>].<name>(*args)  
    is equivalent to  <prefix><name>(p, *args). 
    A function obtained by fixing the first parameters(s) of another 
    function is called a 'partial function'. Note that python supports
    partial functions.
    """
    m = re.compile("mm_op(\d+)_(\w+)")

    def __init__(self, pxd_files, partials={}):
        """Create instance of class

        The user must provide a list 'pxd_files' of .pxd file names
        and a dictionary 'partials' of functions with prefixes as
        described in the constructor.   
        """
        self.pxd_files = pxd_files 
        self.partials = partials
        self.classes = {}     # dict  p : <generated code for class for p>
        self.class_names = {} # dict  p : <name of class for p> 
        self.done = False

    @staticmethod
    def iter_partials(partials):
        """Yield pairs (<prefix><name>, <name>) 

        These pairs are obtained from parameter 'partials' in the
        constructor as described in the documentation of the class.
        """  
        for prefix, function_list in partials.items():
            for f in function_list:
                 yield prefix + f, f

    def get_class(self, p):
        """Return container for code of the class for modulus p.

        Whenever a function with name mm<p>_XXX is found in a .pxd
        file, a class  with name _MM_<p> is created for modulus p.
        
        A container for the code of the class for modulus p is
        returned as a list of strings. For writing code to that
        class one may append strings to that list. 
        """
        try: 
            return self.classes[p]
        except: 
            class_name =  "_MM_{P}".format(P = p)
            self.class_names[p] = class_name
            self.classes[p] = ["class %s:\n" % class_name]
            return self.classes[p]

    def add_to_class(self, p, function_name, method_name):
        """Add member for encoding function to the class for p 

        We add a member to the class that encodes
              function_name = method_name
        as a static method.
        """
        cl = self.get_class(p)
        cl.append("    %s = staticmethod(%s)\n" % (
                             method_name, function_name))

    def add_partial_to_class(self, p, function_name, method_name):
        """Add member for encoding partial function to class for p 

        We add a static method 'function_name' to the class 
        corssponding to p that encodes
              function_name = partial(method_name, p)
        as a static method.
        """
        cl = self.get_class(p)
        cl.append( "    %s = staticmethod(partial(%s, %d))\n" % (
                             method_name, function_name, p))
         
    def add_comment(self, p, text):
        """Add comment given by 'text' to the class for p"""
        cl = self.get_class(p)
        cl.append("    # %s\n" % text)

    def methods_from_pxd_files(self):
        """Generate methods from the functions in the .pxd files 

        For each function with name 'mm<p>_<name>', where <p> is a
        modulus and <name> is an arbitrary string we add a static 
        method with name <name> to the class corresponding to 
        modulus p. This methods executes function  'mm<p>_<name>'
        as specified in the .pxd file. 
        """
        for pxd_file in self.pxd_files:
            functions = pxd_to_function_list(pxd_file)
            header_done = False
            for f in functions:
                mf = self.m.match(f)
                if mf:
                    p, method_name = mf.groups()
                    method_name = "op_" + method_name
                    p = int(p)
                    if not header_done:
                        self.add_comment(p, "from %s" % pxd_file)
                        header_done = True
                    self.add_to_class(p, f, method_name)

    def methods_from_partial_functions(self):
        """Add partial function to all classes generated so far 

        Parameter <partials> in the constructor specifies a list of
        function names and a mapping from these functions to partial 
        functions contained as methods in the generated classes. See 
        description of class MM_P_ClassGenerator and of method 
        add_partial_to_class() for details. 
        """
        for p in self.classes:
            self.add_comment(p, "Partial functions with 1st arg = %d" % p)
            for function_, method_ in self.iter_partials(self.partials):
                 self.add_partial_to_class(p, function_, method_)

    def add_constants(self):
        """Add constants frrom MM_Basics(p) for specific p """        
        for p in self.classes:
            cl = self.get_class(p)
            basis = mm_basics.MM_Basics(p)
            cl.append("    # constants\n")
            for name in MM_BASICS_CONSTANTS:
                value = getattr(basis, name)
                cl.append("    %s = %d\n" % (name, value)) 
            cl.append("")

    def generate_classes(self):
        """Generate code for the classes for all moduli p found"""
        s = "\n"
        if not self.done:
            self.methods_from_pxd_files()
            self.methods_from_partial_functions()
            self.add_constants()
            self.done = True
        for p, text in sorted(self.classes.items()):
             s += "".join(text) + "\n"
        return s
        
    def generate_class_dict(self):
        """Generate a dictionary of all classes previeously generated"""
        s = "\nMM = {\n" 
        for p, class_name in sorted(self.class_names.items()):
            s += "    %d : %s,\n" % (p, class_name)
        s += "}\n\n"
        return s    

    def generate(self): 
        """Generate the code for the .pyx file

        This code defines the appropriate classes for all moduli p,
        and it defines a dictionary MM such that MM[p].<name> refers
        to functions with given <name> in the class corresponding
        to modulus p.
        """  
        return (self.generate_classes() 
                  + self.generate_class_dict() ) 


#234567890123456789012345678901234567890123456789012345678901234567890


##########################################################################
# Prroviding a list of all generated c files
##########################################################################


def list_all_c_files():
    """Return list of names of all c files generated by this module

    This is a list of fully qaulified path names.
    """
    c_files = list_basics_c_files()
    for  p in PRIMES:
        c_files += list_c_files(p)
    return c_files


##########################################################################
# The main function for generating code
##########################################################################


def generate_pyx():
    """The main function of this module for generating code

    This function generates all reqired .c files and also the required
    headers.

    It also generates the .pyx file with name given by PYX_FILE_NAME and
    stores it in the current directory. Cython will use the .pyx file to
    build a wrapper for all generated C functions. 
    """
    def pyx_comment(text, f):
        print("\n" + "#"*70 + "\n### %s\n" % text + "#"*70 + "\n\n",file=f)
    c_files,  pxd_files =  make_basics() 
    for p in PRIMES:
        c_f, pxd_f = make_c_h_pxd(p)
        c_files += c_f
        pxd_files += pxd_f
    f_pyx = open(PYX_FILE_NAME, "wt")
    print(PXD_DECLARATIONS, file = f_pyx)
    pyx_comment("Functions from modules in mat24", f_pyx)
    for l in mat24_pyx_lines():
        print(l, file = f_pyx, end = "")
    for pxd_f in pxd_files + EXTERNAL_PXD_FILES:
        pyx_comment("Wrappers for C functions from file %s" % pxd_f, f_pyx)
        print(pxd_to_pyx(pxd_f), file = f_pyx)
    pyx_comment("Python functions added for convenience", f_pyx)
    print(PYX_FUNCTIONS,  file = f_pyx)
    pyx_comment(
      "Classes collecting functions for specific characteristics p", f_pyx)
    cg = MM_P_ClassGenerator(pxd_files, PYX_PARTIALS)
    print(cg.generate(), file = f_pyx)
    f_pyx.close()
    return c_files


##########################################################################
# Functions of this module for generating documentation
##########################################################################


C_FILES_DOCUMENTED = ["mm_random", "mm_aux", "mm_tables" ]


def generate_doc():
    """Function for generating documentation from the genrated C files

    """
    for c_file in C_FILES_DOCUMENTED:
        c_path = os.path.join(C_DIR, c_file + ".c")
        doc_path = os.path.join(DOC_DIR, c_file + "_c_doc.txt")
        make_doc(c_path, doc_path)



if __name__ == "__main__":
    generate_pyx()
    generate_doc()
