/** @file mm_aux.c

 File ``mm_aux.c`` provides the basic functions for dealing with the
 representations  of the monster group  modulo various small 
 integers ``p = 2**n-1``,  ``2 <= n <= 8``.
 Here the integer ``p`` is called the modulus. 

 Especially, we deal with vectors in such a representation as 
 described in  *The C interface of the mmgroup project*, 
 section *Description of the mmgroup.mm extension*.

 For such a vector there is an internal representation, an external
 representation, and also a sparse representation, as described in the
 documentation mentioned above.

 The functions in this file provide access to the internal representation 
 of such a vector. The also support the conversion between the different 
 representations of a vector.  

 Usually, the order of the parameters of functions in this file is:
      
       1. Modulus p, if present

       2. The input value or the input data array

       3. Any parameters that do not affect the positions in the output array

       4. The output data array

       5. Parameters (e.g. lengths, indices) that affect the positions of the 
          data being modified in the output array

*/



/// @cond DO_NOT_DOCUMENT 
#include <stdlib.h>
#include "clifford12.h"
#include "mm_basics.h"
/// @endcond  

// %%EXPORT_KWD MM_BASICS_API




/// @cond DO_NOT_DOCUMENT 

// %%USE_TABLE
static const uint32_t MMV_CONST_TABLE[] = {
// %%TABLE MMV_CONST_TAB, uint32
};


// %%PY_DOCSTR MM_AUX_IO24.abc_table, 1
static const uint16_t MM_AUX_TBL_ABC[] = {
// %%TABLE MM_AUX_TBL_ABC, uint16
};



// %%PY_DOCSTR MM_AUX_IO24.reduce_table, 1
static const uint_mmv_t MM_AUX_TBL_REDUCE[] = {
// %%TABLE MM_AUX_TBL_REDUCE, uint%{INT_BITS}
};

/// @endcond  





// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c

//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/**********************************************************************
*** Low-level functions supporting vectors of type uint_mmv_t[]
**********************************************************************/



/**
  @brief Read entries from vector in internal representation

  Read entries of vector ``mv`` (stored in internal representation
  with modulus ``p``) and store these entries  in the array ``b``.
  Here ``len`` is the number of entries to be read. ``len`` must 
  be a multiple of the number of entries in an integer
  of ``type uint_mmv_t``. It is ok if ``len`` is a multiple of 32. 
  Output vector ``b`` is reduced modulo ``p``.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_read_mmv1(uint32_t p, uint_mmv_t *mv, uint8_t *b, uint32_t len)
{
    uint_fast32_t i, sh, tmp;  
    uint_mmv_t source;
    // %%MMV_LOAD_CONST  p, i
    sh = %{MMV_CONST:P_BITS,i};        // This is P_BITS
    i = %{MMV_CONST:LOG_FIELD_BITS,i}; // This is LOG_FIELD_BITS
    len >>= %{LOG_INT_BITS} - i;

    switch (i) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                source = *mv++;
                // %%FOR jj in range(0, INT_BITS, 1 << LOG_F)
                tmp = (source >> %{jj}) & p;
                b[%{int:jj >> LOG_F}] = (uint8_t)((tmp + ((tmp + 1) >> sh)) & p);
                // %%END FOR
                b += %{int:INT_BITS >> LOG_F};
            }
            break;
        // %%END FOR
    }
}


/**
  @brief Read entries from vector in internal representation

  Same operation as in function ``mm_aux_read_mmv1()``, but the
  output vector ``b`` is not reduced. This is for debugging and less 
  optimized than ``mm_aux_read_mmv1()``. 

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_read_direct_mmv1(uint32_t p, uint_mmv_t *mv, uint8_t *b, uint32_t len)
{
    uint_fast32_t i, j;  
    uint_mmv_t source;
    // %%MMV_LOAD_CONST  p, i
    i = %{MMV_CONST:LOG_FIELD_BITS,i}; // This is LOG_FIELD_BITS
    len >>= %{LOG_INT_BITS} - i;
    i = 1 << i;                       // This is FIELD_BITS

    while (len--) {
        source = *mv++;
        for (j = 0; j < %{INT_BITS}; j += i) 
            *b++ = (uint8_t)((source >> j) & p);
    }
}


/**
  @brief Write data to a vector in internal representation

  Write data from the array ``b`` to the vector ``mv`` (stored 
  in internal representation with modulus ``p``). Here ``len`` is 
  the number of entries to be written. ``len`` must be a multiple 
  of the number of entries in an integer of type ``uint_mmv_t``. 
  It is ok if len is a multiple of 32. 

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_write_mmv1(uint32_t p, uint8_t *b, uint_mmv_t *mv, uint32_t len)
{
    uint_fast32_t i;  
    uint_mmv_t dest;
    // %%MMV_LOAD_CONST  p, i
    i = %{MMV_CONST:LOG_FIELD_BITS,i}; // This is LOG_FIELD_BITS
    len >>= %{LOG_INT_BITS} - i;
    
    switch(i) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                dest =  0;
                // %%FOR jj in range(0, INT_BITS, 1 << LOG_F)
                dest +=  (uint_mmv_t)(b[%{int:jj >> LOG_F}]) << %{jj};
                // %%END FOR
                *mv++ = dest;
                b += %{int:INT_BITS >> LOG_F};
            }
            break;
        // %%END FOR
    }
}

/**
  @brief Read blocks of length 24 from vector in internal representation

  Read entries of vector ``mv`` with modulus ``p`` and store these 
  entries in the array ``b``. Here ``mv`` is a vector of blocks
  of 24  entries, with 8 entries slack after each block. ``len``
  is the number of such blocks to be read. So  altogether 24 * ``len``
  entries are read from ``mv`` and written to array ``b``; the 8
  bytes slack after each 24-byte block are dropped.
  Vector ``b`` is reduced modulo ``p``.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_read_mmv24(uint32_t p, uint_mmv_t *mv, uint8_t *b, uint32_t len)
{
    uint_fast32_t i, sh, tmp;  
    uint_mmv_t source;
    // %%MMV_LOAD_CONST  p, i
    sh = %{MMV_CONST:P_BITS,i};        // This is P_BITS
    i = %{MMV_CONST:LOG_FIELD_BITS,i}; // This is LOG_FIELD_BITS

    switch(i) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                // %%FOR j in range(0, 24)         
                // %%IF* (j << LOG_F) % INT_BITS == 0  # then reload source
                source = *mv++;                 
                // %%END IF
                tmp = (source >> %{int:(j << LOG_F) % INT_BITS}) & p;
                b[%{int:j}] = (uint8_t)((tmp + ((tmp + 1) >> sh)) & p);
                // %%END FOR                           
                b += 24;
                // %%IF* (24 << LOG_F) % INT_BITS == 0  # then adjust mv
                mv += %{int: (8 << LOG_F) / INT_BITS};
                // %%END IF
            }
            break;
        // %%END FOR
    }
}    


/**
  @brief Write blocks of length 24 to vector in internal representation

  Write data from the array ``b`` to the vector ``mv`` with 
  modulus ``p``. We take ``24 * len`` bytes from the array b
  and write them to the vector ``mv``. Here ``mv`` is considered
  as a vector of blocks of 24 entries, with 8 entries slack 
  after each block; so ``len`` is the number of such 24-byte
  blocks to be written. The entries in the slack after each 
  block written to ``mv`` are set to zero.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_write_mmv24(uint32_t p, uint8_t *b, uint_mmv_t *mv, uint32_t len)
{
    uint_fast32_t i;  
    uint_mmv_t dest;
    // %%MMV_LOAD_CONST  p, i
    i = %{MMV_CONST:LOG_FIELD_BITS,i}; // This is LOG_FIELD_BITS


    switch(i) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                // %%FOR j in range(0, 24)             
                // %%IF* (j << LOG_F) % INT_BITS == 0  # then clear buffer
                // %%IF* (j > 0)                       # then write back data
                *mv++ = dest;                
                // %%END IF
                dest = 0;
                // %%END IF
                dest += (uint_mmv_t)(b[%{j}] & p) << %{int:(j<<LOG_F) % INT_BITS};
                // %%END FOR                           
                *mv++ = dest;                
                // %%FOR* k in range((8 << LOG_F) // INT_BITS)
                *mv++ = 0;
                // %%END FOR                              
                b += 24;
            }
            break;
        // %%END FOR
    }

} 


/**
  @brief Read one entry from vector in internal representation

  The  function returns the entry with index ``i`` of the
  vector ``mv`` with modulus ``p``. The return value
  is reduced modulo ``p``.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
uint8_t mm_aux_get_mmv1(uint32_t p, uint_mmv_t *mv, uint32_t i)
{
    uint_fast32_t  c, j, res;

    // %%MMV_LOAD_CONST p, c
    j = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS
    mv += i >> j;
    i &= (1 << j) - 1;
    j = %{LOG_INT_BITS} - j;           // This is LOG_FIELD_BITS
    res = (mv[0] >> (i << j)) & p;    // This is the result
    j = %{MMV_CONST:P_BITS,c};         // This is P_BITS
    // return result reduced modulo p
    return (uint8_t) ( (res + ((res + 1) >> j)) & p );
}


/**
  @brief Write one entry to a vector in internal representation

  The  function set the entry of the vector ``mv`` with modulus ``p``
  at the index ``i`` to the given value. ``0 <= value <= p``
  must hold.

  Caution:

  This is a low-level function. An illegal write operation might
  lead to an inconsistent vector ``mv``!

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_put_mmv1(uint32_t p, uint8_t value, uint_mmv_t *mv, uint32_t i)
// Set the entry of the vector mv with modulus p at the  index i  
// to the given value. 0 <= value <= p must hold.
{
    uint_fast32_t  j;

    // %%MMV_LOAD_CONST  p, j
    j = %{MMV_CONST:LOG_INT_FIELDS,j}; // This is LOG_INT_FIELDS
    mv += i >> j;
    i &= (1 << j) - 1;
    j = %{LOG_INT_BITS} - j;           // This is LOG_FIELD_BITS
    i <<= j;
    mv[0] &= ~(((uint_mmv_t)p) << i);
    mv[0] |= ((uint_mmv_t)(value & p)) << i;
}


/**********************************************************************
*** Functions for data transfer from and to vectors in R_p.
*** Here such a vector is given in internal representation and of type 
*** uint_mmv_t[]. For modulus p, p + 1 must be a power of two.
**********************************************************************/

/**
  @brief Return the size of a vector in internal representation

  The  function  return number of integers of type ``uint_mmv_t``
  required to store a vector with modulus ``p`` in internal
  representation.

  The function returns 0 if ``p`` is illegal modulus.
*/
// %%EXPORT px
uint32_t mm_aux_mmv_size(uint32_t p)
// Returns the number of integers of type uint_mmv_t required to store
// a vector of the representation R_p for a given p.
{
    uint_fast32_t tbl;
    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, tbl
    // return the value MMV_INTS for the specified p
    return%{MMV_CONST:MMV_INTS,tbl};
}


/**
  @brief Zero a vector in internal representation

  The  function sets all entries of the vector ``mv`` with 
  modulus ``p`` in internal  representation to zero.
*/
// %%EXPORT px
void mm_aux_zero_mmv(uint32_t p, uint_mmv_t *mv)
// Zero the vector of the representation R_p referred by mv,
{
    uint_fast32_t j;
    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, j
    j = %{MMV_CONST:MMV_INTS,j};
    do {
        *mv++ = 0;
    } while(--j);
}



/**
  @brief Read entry at index from vector in internal representation

  The  function returns the entry with index ``i`` of the
  vector ``mv`` with modulus ``p``. The return value is reduced 
  modulo ``p``. Index ``i`` must be given in external 
  representation. The function returns 0 in case  ``i >= 198884``.
*/
// %%EXPORT px
uint8_t mm_aux_get_mmv(uint32_t p, uint_mmv_t *mv, uint32_t i)
// Return the entry of the vector mv in R_p at  index  i.
{
    uint_fast32_t  j, c, res;
    if (mm_aux_bad_p(p)) return 0;
    if (i <  MM_AUX_XOFS_X) {
        if (i <  MM_AUX_XOFS_T) {
            // Tags A, B, C
            i = (MM_AUX_TBL_ABC[i] & 0x7ff) + i - 24;
        } else {
            // Tag T
            i += MM_AUX_OFS_T - MM_AUX_XOFS_T;
        } 
    } else {
        if (i >=  MM_AUX_XLEN_V) return 0;
        // Tags X, Z, Y
        i -=  MM_AUX_XOFS_X;
        // Put i += 8 * floor(i/24), for i <  3 * 2048 * 24
        i += (((i >> 3) * 0xaaab) >> 17) << 3; 
        i += MM_AUX_OFS_X;
    }

    // %%MMV_LOAD_CONST  p, c
    j = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS
    mv += i >> j;
    i = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    res = (mv[0] >> i) & p;             // This is the result
    //Reduce reult modulo p
    c = %{MMV_CONST:P_BITS,c}; // This is P_BITS
    return (uint8_t)((res + ((res + 1) >> c)) & p);
}










/**
  @brief Write entry to a vector at an index in internal representation

  The  function sets the entry of the vector ``mv`` with modulus ``p``
  at the index ``i`` to the given value. ``0 <= value <= p``
  must hold.

  Here the index ``i`` must be given in external representation.
  Writing at an index ``i >= 198884`` performs no action.
*/
// %%EXPORT px
void mm_aux_put_mmv(uint32_t p, uint8_t value, uint_mmv_t *mv, uint32_t i)
{

    uint_fast32_t  j, sh, diff;
    if (mm_aux_bad_p(p)) return;
    value &= p;

    // %%MMV_LOAD_CONST  p, j
    j = %{MMV_CONST:LOG_INT_FIELDS,j}; // This is LOG_INT_FIELDS

    if (i <  MM_AUX_XOFS_X) {
        if (i <  MM_AUX_XOFS_T) {
            // Tags A, B, C
            diff = 31 * (MM_AUX_TBL_ABC[i] >> 11);
            i = (MM_AUX_TBL_ABC[i] & 0x7ff) + i - 24;
            sh = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
            mv[i >> j] = (mv[i >> j] &  ~(((uint_mmv_t)p) << sh))
                  |   ((uint_mmv_t)(value)) << sh;
            i -= diff;
        } else {
            // Tag T
            i += MM_AUX_OFS_T - MM_AUX_XOFS_T;
        } 
    } else {
        if (i >=  MM_AUX_XLEN_V) return;
        // Tags X, Z, Y
        i -=  MM_AUX_XOFS_X;
        // Put i += 8 * floor(i/24), for i <  3 * 2048 * 24
        i += (((i >> 3) * 0xaaab) >> 17) << 3; 
        i += MM_AUX_OFS_X;
    }

    mv += i >> j;
    sh = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    mv[0] = (mv[0] &  ~(((uint_mmv_t)p) << sh))
              |   ((uint_mmv_t)(value)) << sh;
}


/**
  @brief Randomize a vector in internal representation

  The function randomizes all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation uniformly using the 
  internal random generator in file ``gen_random.c``. 
  Parameter ``seed`` must be a seed for a random generator as 
  described in file ``gen_random.c``.
*/
// %%EXPORT px
void mm_aux_random_mmv(uint32_t p, uint_mmv_t *mv, uint64_t *seed)
{
    uint8_t b1[3072];
    uint_fast32_t i, c;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST p, c
    c = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS

    // Do the small part
    gen_rng_bytes_modp(p,  (uint8_t *)(mv), 24 + 3 * 276, seed);
    mm_aux_small24_expand((uint8_t *)(mv), b1);
    mm_aux_write_mmv24(p, b1, mv, 72);
    mv += MM_AUX_OFS_T >> c;

    // Do the 759 * 64 vector; note that 759 = 11 * 69
    for (i = 0; i < 22; ++i) {
        gen_rng_bytes_modp(p, b1, 69 * 32, seed);
        mm_aux_write_mmv1(p, b1, mv, 69 * 32);
        mv += (69 * 32) >> c;
    } 

    // Do the 6144 * 24 vector
    for (i = 0; i < 48; ++i) {  
        gen_rng_bytes_modp(p, b1, 3072, seed);
        mm_aux_write_mmv24(p, b1, mv, 128);
        mv += 4096 >> c;
    } 
}


/**********************************************************************
*** Reducing and checking a vector in R_p
**********************************************************************/

/**
  @brief Reduce a vector in internal representation

  The function reduces all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation to a standard form, so 
  that equal vectors are represented by equal arrays of integers.

  Note that a zero entry in such a vector can be represented either 
  by the bit string  ``0...0`` or by ``1...1``. This functions sets 
  all zero entries of the vector to ``0...0``.

  The function returns 0 if it detects no error.
  It may return the following error codes:

  -1: Bad modulus ``p``

  -2: A one bit outside a valid bit field for an entry has been found
*/
// %%EXPORT px
int32_t mm_aux_reduce_mmv(uint32_t p, uint_mmv_t *mv)
{
    return mm_aux_reduce_mmv_fields(p, mv, MM_AUX_LEN_V);
}

/**
  @brief Auxiliary function of function ``mm_aux_reduce_mmv``

  The function performs the same operation as 
  function ``mm_aux_reduce_mmv``. But instead of all entries 
  of the vector ``mv``, it reduces the first ``len`` entries
  only.
*/
// %%EXPORT px
int32_t mm_aux_reduce_mmv_fields(uint32_t p, uint_mmv_t *mv, uint32_t nfields)
{
    uint_fast32_t i, sh;
    uint_mmv_t data, cy, mask_1, mask_p, acc;

    if (mm_aux_bad_p(p)) return -1;
    // %%MMV_LOAD_CONST  p, i
    sh = %{MMV_CONST:P_BITS, i};          // This is P_BITS
    i = %{MMV_CONST:LOG_INT_FIELDS, i};   // This is LOG_INT_FIELDS
    i = nfields >> i;                     // No of unit_mmv_t to process
    mask_1 =  MM_AUX_TBL_REDUCE[2*sh-4];
    mask_p =  MM_AUX_TBL_REDUCE[2*sh-3];
    if (sh & (sh - 1)) {
        // case P_BITS is not a power of two
        acc = 0;      // use acc for accumulating error bits
        do {
            data = *mv;
            acc |= data;
            data &= mask_p;
            cy = (data + mask_1) & ~mask_p;
            data += (cy >> sh) - cy;
            *mv++ = data;
        } while (--i);
        if (acc & ~mask_p) return -2;
    } else {
        // case P_BITS is a power of two
        // use acc for  (<high half> & <low half>) of fields
        sh >>= 1;   // halved P_BITS
        do {
            data = *mv;
            acc = data & (data >> sh) & mask_p;
            cy = (acc + mask_1) & ~mask_p;
            data += (cy >> sh) - (cy << sh);
            *mv++ = data;
        } while (--i);
    }
    return 0;
}



/// @cond DO_NOT_DOCUMENT 

static int32_t check24(uint32_t p, uint_mmv_t *mv, uint32_t length)
{
    uint_fast32_t d;
    uint_mmv_t  acc = 0, mask;

    // %%MMV_LOAD_CONST  p, d
    // Put d =  5 - LOG_INT_FIELDS
    d = 5 - %{MMV_CONST:LOG_INT_FIELDS, d}; 
    switch (d) {
        // %%IF %{INT_BITS} == 64
        case 0:
            mask = %{hex: -1 << (3*INT_BITS//4)};
            while (length--) acc |= *mv++ & mask;
            break;
        // %%END IF
        case 1:
            mask = %{hex: -1 << (INT_BITS//2)};
            while (length--) {
                acc |= mv[1] & mask; mv += 2;
            }
            break;
        case 2:
            while (length--) {
                acc |= mv[3]; mv += 4;
            }
            break;
        // %%IF %{INT_BITS} == 32
        case 3:
            while (--length) {
                acc |= mv[6] | mv[7]; mv += 8;
            }
        // %%END IF
        break;
    }
    return acc ? -3 : 0;
}


static int32_t check_sym(uint32_t p, uint_mmv_t *mv, uint8_t * buffer)
// buffer is a work buffer of size at least 72 * 32
// Side effect: Tmv entries with tags A, B, C are read to the buffer
{
    uint_fast32_t i, acc = 0;
    uint8_t  *p_row, *p_col;
    mm_aux_read_direct_mmv1(p, mv, buffer, 72*32);
    for(i = 768; i < 1536; i += 33)  
        acc |= buffer[i] | buffer[i + 768];
    if (acc) return -4;
    p_row = buffer;
    acc = 0;
    for (p_col = buffer; p_col < buffer + 24; ++p_col) {
         for (i = 0; i < 24; ++i)
             acc |= (p_row[i] ^ p_col[i << 5]) 
                  | (p_row[i + 768] ^ p_col[(i << 5) + 768])
                  | (p_row[i + 1536] ^ p_col[(i << 5) + 1536]);
         p_row+= 32;
    }
    return acc ? -5 : 0;
}



static int32_t check_mmv_buffer(uint32_t p, uint_mmv_t *mv, uint8_t * buffer)
// Workhorse for function mm_aux_check_mmv. buffer must have size 72*32.
// Side effect: mv entries with tags A, B, C are read to the buffer
{
    uint_fast32_t i;
    i = mm_aux_reduce_mmv(p, mv);
    if (i) return i;                 // Errors -1, -2 may occur here
    i = check24(p, mv, 72);          // check tags A,B,C
    if (i) return i;                 // Error -3 may occur here
    // %%MMV_LOAD_CONST  p, i
    i = %{MMV_CONST:LOG_INT_FIELDS, i}; //  LOG_INT_FIELDS
    i = check24(p, mv + (MM_AUX_OFS_X >> i), 6144); // check tags X,Y,Z
    if (i) return i - 100;                 // Error -3 may occur here
    return check_sym(p, mv, buffer); // Errors -4, -5 may occur here
}

/// @endcond


/**
  @brief Check a vector in internal representation for errors

  The function checks all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation for errors. It returns 0 
  if it detects no error. It may return the following error codes:

  -1: Bad modulus ``p``

  -2: A one bit outside a valid bit field for an entry has been found

  -3: A subfield of 24 entries has an illegal nonzero entry at index >= 24

  -4: The vector has an illegal nonzero diagonal entry 

  -5: The symmetric part of the vector is not actually symmetric 

As a side effect, ``mv`` is reduced with function ``mm_aux_reduce_mmv``.
*/
// %%EXPORT px
int32_t mm_aux_check_mmv(uint32_t p, uint_mmv_t *mv)
{
    uint8_t buffer[72*32];
    return check_mmv_buffer(p, mv, buffer);
}

/**********************************************************************
*** Low-level functions supporting external rep of vectors in R_p
**********************************************************************/

/** 
  @brief Convert part of vector from external to internal representation

  Conversion between the internal and the external representation 
  of a vector is straightforward, except for entries with
  tags ``A, B, C``. The entries with these tags are stored in the 
  first 852 entries of the external representation. In the internal
  representation the entries with these tags are spread over three
  symmetric 24 times 24 times matrices. 
 
  This function maps the 852 entries of the array ``b_src`` 
  (corresponding to tags ``A, B, C``) to the array ``b_dest`` of
  size 3 * 24 * 24 (corresponding to three
  symmetric 24 times 24 times matrices). 
  Function ``mm_aux_write_mmv24`` can be used to write the data
  from the array ``b_dest`` to the initial segment of the internal
  representation of a vector.
  
*/
// %%EXPORT px
void mm_aux_small24_expand(uint8_t *b_src, uint8_t *b_dest)
//
{
    uint_fast16_t j0, j1t, j1e;
    uint8_t *b_transpose = b_dest;
    for (j0 = 0; j0 < 24 * 25; j0 += 25) {
        b_dest[j0] = *b_src++;
        b_dest[j0 + 1152] =  b_dest[j0 + 576] = 0;
    }

    for (j0 = 0; j0 < 24; ++j0)  {
        j1e = 24 * j0;
        for (j1t = 0; j1t < j1e; j1t += 24) {
            b_transpose[j1t] = b_dest[0] = b_src[0];
            b_transpose[j1t + 576] = b_dest[576] = b_src[276];
            b_transpose[j1t + 1152] = b_dest[1152] = b_src[552];
            ++b_dest; ++b_src;
        }
        b_dest += 24 - j0;
        ++b_transpose;
    }
}

/** 
  @brief Convert part of vector from internal to external representation

  Conversion between the internal and the external representation 
  of a vector is straightforward, except for entries with
  tags ``A, B, C``. The entries with these tags are stored in the 
  first 852 entries of the external representation. In the internal
  representation the entries with these tags are spread over three
  symmetric 24 times 24 times matrices. 
 
  This function maps the 3 * 24 * 24 entries of the array ``b_src``
  (corresponding to three symmetric 24 times 24 times matrices)
  to the  852 entries of the array ``b_dest``  (corresponding to 
  tags ``A, B, C`` in external representation).

  This reverses the effect of function ``mm_aux_small24_expand``.
  Function ``mm_aux_read_mmv24`` can be used to read the data
  from the initial segment of the internal representation of a 
  vector to the array ``b_src``, before calling this function. 
*/
// %%EXPORT px
void mm_aux_small24_compress(uint8_t *b_src, uint8_t *b_dest)
//
{
    uint_fast16_t  j0, j1;
    for (j0 = 0; j0 < 24 * 25; j0 += 25) 
        *b_dest++ = b_src[j0];
    for (j0 = 0; j0 < 24; ++j0)  {
        for (j1 = j0; j1; --j1) {
            b_dest[0] = b_src[0];
            b_dest[276] = b_src[576];
            b_dest[552] = b_src[1152];
            ++b_dest; ++b_src;
        } 
        b_src += 24 - j0;
    }
}






/**********************************************************************
*** Conversion between internal and external rep of vectors in R_p
**********************************************************************/







/**
  @brief Convert vector from internal to external representation

  Read all entries of vector ``mv`` (stored in internal
  representation with modulus ``p``) and store these entries 
  in the array ``b`` in external representation.

  Output vector ``b`` is reduced modulo ``p``. It must have 
  length 196884.
*/
// %%EXPORT px
void mm_aux_mmv_to_bytes(uint32_t p, uint_mmv_t *mv, uint8_t *b)
{
    uint8_t b1[3*576]; 
    uint_fast32_t c;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, c
    c = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS
    
    mm_aux_read_mmv24(p, mv, b1, 72);
    mm_aux_small24_compress(b1, b);
    mv += MM_AUX_OFS_T >> c;
    b +=  MM_AUX_XOFS_T;
    mm_aux_read_mmv1(p, mv, b,  759*64);
    mv += (MM_AUX_OFS_X - MM_AUX_OFS_T) >> c;
    b +=  (MM_AUX_XOFS_X - MM_AUX_XOFS_T);
    mm_aux_read_mmv24(p, mv, b, 6144);
}


/**
  @brief Convert vector from external to internal representation

  Read all entries of the array ```b`` (of length 196884, containing 
  a vector in external representation) and store these entries the 
  vector ``mv``. Here ``mv`` is a vector stored in internal
  representation with modulus ``p``. 

  Any entry ``x`` in the array ``b`` must satisfy ``0 <= x <= p``.
  The vector ``mv`` is an array of ``n`` integers of type
  ``uint_mmv_t`` with ``n =  mm_aux_mmv_size(p)``.
*/
// %%EXPORT px
void mm_aux_bytes_to_mmv(uint32_t p, uint8_t *b, uint_mmv_t *mv)
{
    uint8_t b1[3*576];
    uint_fast32_t  c;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, c
    c = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS

    mm_aux_small24_expand(b, b1);   
    mm_aux_write_mmv24(p, b1, mv, 72);
    mv += MM_AUX_OFS_T >> c;
    b +=  MM_AUX_XOFS_T;
    mm_aux_write_mmv1(p, b, mv, 759*64);
    mv += (MM_AUX_OFS_X - MM_AUX_OFS_T) >> c;
    b +=  (MM_AUX_XOFS_X - MM_AUX_XOFS_T);
    mm_aux_write_mmv24(p, b, mv, 6144);
}




/**********************************************************************
*** Conversion between internal and sparse rep of vectors in R_p
**********************************************************************/

/**
  @brief Convert vector from internal to sparse representation

  Read all entries of vector ``mv`` (stored in internal
  representation with modulus ``p``) and store these entries
  in the array ``sp`` in sparse representation. Each entry
  in the array ``sp`` represents a nonzero entry of the vector.
  The function returns the length of the output array ``sp``
  or an negative value in case of error. Negative return
  values are as in function ``check_mmv_buffer``.

  Output vector ``sp`` is reduced modulo ``p``. The buffer for
  array ``sp`` must have length 196884. Input vector ``mv``
  is checked with function ``check_mmv_buffer``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_to_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp)
{
    int32_t status;
    uint_fast32_t row, row_end,i, j, isp = 0, value;
    uint_fast32_t field_bits, lg_int_fields, ofs, sh;
    uint_mmv_t source;
    uint8_t b[72*32], *p_row;

    if ((status = check_mmv_buffer(p, mv, b)) != 0) return status;
    
    // %%MMV_LOAD_CONST  p, j
    field_bits = %{MMV_CONST:FIELD_BITS,j}; // This is FIELD_BITS
    lg_int_fields = %{MMV_CONST:LOG_INT_FIELDS,j}; // This is LOG_INT_FIELDS
    sh = 8 - %{LOG_INT_BITS} + lg_int_fields; // This is 8 - LOG_FIELD_BITS; 
 
    // Do tags A, B, C
    p_row = b;
    for (row = 0; row < 3; ++row) for (i = 0; i < 24; ++i) {
         for (j = 0; j <= i; ++j) {
            if ((value = p_row[j]) != 0)  sp[isp++] =
                0x2000000 + (row << 25) + (i << 14) + (j << 8) + value; 
        } 
        p_row += 32;
    }
    
    // Do tag T
    mv += MM_AUX_OFS_T >> lg_int_fields;
    row_end = (MM_AUX_OFS_X - MM_AUX_OFS_T) >> lg_int_fields;
    for (row = 0; row < row_end; ++row) if ((source = *mv++) != 0) {
        ofs = 0x8000000 + (row << (8 + lg_int_fields));
        for (j = 0; j < %{INT_BITS}; j += field_bits) {
            if ((value = (source >> j) & p) != 0)  {
                sp[isp++] = ofs + (j << sh) + value;
            } 
        }           
    }

    row_end = (MM_AUX_LEN_V - MM_AUX_OFS_X) >> lg_int_fields;
    for (row = 0; row < row_end; ++row) if ((source = *mv++) != 0) {
        ofs = 0x5000000 + (row << (8 + lg_int_fields));
        ofs += ofs & 0xfffe000;
        for (j = 0; j < %{INT_BITS}; j += field_bits) {
            if ((value = (source >> j) & p) != 0)  {
                 sp[isp++] = ofs + (j << sh) + value;
            } 
        }           
    }

    return (int32_t)isp; 
}

/**
  @brief Extract entries from a vector in internal representation

  The function extracts certain entries from the vector ``mv`` 
  depending on the vector ``sp``. Here ``mv`` is a vector stored 
  in internal representation with modulus ``p``.  Vector ``sp``
  is a vector of length ``length`` in sparse representation.

  The entries of vector ``sp`` are updated with the corresponding 
  entries of ``mv``. If ``sp`` has an entry with a certain label
  then the coordinate of that entry is set to the corresponding 
  coordinate of vector ``mv``. If several entries of ``sp`` have the 
  same label then the same coordinate is taken from ``mv`` 
  several times.

  Bit 7,...,0 of any entry of ``sp`` should be either 0 or p. If that
  value is 0 then the coordinate is read to bits 7,...,0 of that entry. 
  If that entry is ``p`` then the negative coordinate is read instead. 
  Other values of these bits are strongly discouraged; but technically 
  we XOR the corresponding coordinate of vector ``mv`` to these bits; 
  and we then change a result ``p`` to zero. There is a special case 
  where this detail is relevant.   
*/
// %%EXPORT px
void mm_aux_mmv_extract_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t length)
{
    uint_fast32_t i0, lg_int_fields, lg_field_bits, p_bits, index_mask;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, i0
    p_bits = %{MMV_CONST:P_BITS,i0}; // This is P_BITS
    lg_field_bits = %{MMV_CONST:LOG_FIELD_BITS,i0}; // This is LOG_FIELD_BITS
    lg_int_fields = %{MMV_CONST:LOG_INT_FIELDS,i0}; // This is LOG_INT_FIELDS
    index_mask = (1 << lg_int_fields) - 1;

    for ( ;length--; ++sp) {
        uint_fast32_t v = *sp, index;
        uint_fast32_t tag = v >> 25,i = (v >> 14) & 0x7ff, j = (v >> 8) & 0x3f;
        switch (tag) {
            case 2:  // tag B
            case 3:  // tag C
                if (i == j) continue;
                // Fall trough to case tag A
            case 1:  // tag A
                if (i >= 24 || j >= 24) continue;
                index = (tag - 1) * 768  + (i << 5) + j;
                break;
            case 4:  // tag T
                if (i >= 759) continue;
                index = MM_AUX_OFS_T + (i << 6) + j;
                break;
            case 5:  // tag X
            case 6:  // tag Z
            case 7:  // tag Y
                if (j >= 24) continue;
                index = ((v >> 14) << 5) + j - 0x50000 + MM_AUX_OFS_X;
                break;
            default:
                continue;
        }
        i = ((index) & index_mask) << lg_field_bits; 
        i = ((mv[index >> lg_int_fields] >> i) ^ v) & p; 
        // i is the (possibly negated) entry of vector mv. reduce i mod p.
        i = (i + ((i + 1) >> p_bits)) & p;
        *sp = (v & 0xffffff00) + i; 
    }
}


/**
  @brief Extract one entry of a vector in internal representation

  The statement ``uint32_t sp1 = mm_aux_mmv_get_sparse(p, mv, sp);`` 
  is equivalent to

        uint32_t sp1 = sp; mm_aux_mmv_extract_sparse(p, mv, &sp1, 1);
      
*/
// %%EXPORT px
uint32_t mm_aux_mmv_get_sparse(uint32_t p, uint_mmv_t *mv, uint32_t sp)
{
     mm_aux_mmv_extract_sparse(p, mv, &sp, 1);
     return sp;
}


/// @cond DO_NOT_DOCUMENT 

#define add_sparse_value(index, value) \
    { \
        uint_fast32_t idx = (index) >> lg_int_fields; \
        uint_fast32_t sh = ((index) & index_mask) << lg_field_bits; \
        uint_mmv_t old_value = (mv[idx] >> sh)  & p; \
        uint_mmv_t new_value = old_value + (value & p); \
        new_value = (new_value + (new_value >> p_bits)) & p; \
        mv[idx]  ^=  (old_value ^ new_value) << sh; \
    }
 
/// @endcond 

       

/**
  @brief Add vector in sparse rep to vector in internal representation

  The function adds a vector ``sp`` in sparse representation to a
  vector ``mv`` in internal representation with modulus ``p``. 
  Vector ``sp`` has length ``length``, and each value ``x`` in an 
  entry of vector ``sp`` must satisfy ``0 <= x <= p``. Different 
  entries in ``sp`` with the same index are added up.
*/
// %%EXPORT px
void mm_aux_mmv_add_sparse(uint32_t p, uint32_t *sp, uint32_t length, uint_mmv_t *mv)
{
    uint_fast32_t i0, lg_int_fields, lg_field_bits, p_bits, index_mask;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, i0
    lg_field_bits = %{MMV_CONST:LOG_FIELD_BITS,i0}; // This is LOG_FIELD_BITS
    lg_int_fields = %{MMV_CONST:LOG_INT_FIELDS,i0}; // This is LOG_INT_FIELDS
    p_bits = %{MMV_CONST:P_BITS,i0};               // This is P_BITS
    index_mask = (1 << lg_int_fields) - 1;

    for ( ;length--; ++sp) {
        uint_fast32_t v = *sp, index;
        uint_fast32_t tag = v >> 25,i = (v >> 14) & 0x7ff, j = (v >> 8) & 0x3f;
        switch (tag) {
            case 2:  // tag B
            case 3:  // tag C
                if (i == j) continue;
                // Fall trough to case tag A
            case 1:  // tag A
                if (i >= 24 || j >= 24) continue;
                index = (tag - 1) * 768 + (i << 5) + j;
                if (i != j) add_sparse_value(index, v);
                index += 31 * (j - i);
                break;
            case 4:  // tag T
                if (i >= 759) continue;
                index = MM_AUX_OFS_T + (i << 6) + j;
                break;
            case 5:  // tag X
            case 6:  // tag Z
            case 7:  // tag Y
                if (j >= 24) continue;
                index = ((v >> 14) << 5) + j - 0x50000 + MM_AUX_OFS_X;
                break;
            default:
                continue;
        }
        add_sparse_value(index, v);
    }
}



    
/// @cond DO_NOT_DOCUMENT 

#define set_sparse_value(index, v) \
    { \
        uint_fast32_t idx = (index) >> lg_int_fields; \
        uint_fast32_t sh = ((index) & index_mask) << lg_field_bits; \
        uint_mmv_t value = ((mv[idx] >> sh)  ^ v) & p; \
        mv[idx]  ^= value << sh; \
    }

/// @endcond  


/**
  @brief Set certain entries of a vector in internal representation

  The function sets certain entries of the vector ``mv `` depending on 
  the vector ``sp ``. Vector ``mv`` is given in internal representation 
  with modulus ``p``.  Vector ``sp`` is given in sparse representation 
  and has length ``length``. 

  If  ``sp `` has an entry with a certain label then the corresponding 
  entry of ``mv `` is set to to the value coded in that entry of ``sp ``.
  Each of these values ``x`` must  satisfy ``0 <= x <= p``. 
  Duplicate entries in ``sp `` with the same label and different values
  are illegal; in that case the value of ``mv `` is undefined.
*/
// %%EXPORT px
void mm_aux_mmv_set_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t length)
// Set certain entries of the vector   ``mv `` depending on the vector
//  ``sp ``. Here  ``mv `` in and  ``sp `` are vectors in the representation R_p 
// of the monster, with  ``mv `` given in internal representation and 
//  ``sp `` given in sparse format.  ``sp `` has  length  ``length ``.
// If  ``sp `` has an entry with label  ``l `` then the corresponding entry 
// of  ``mv `` is set to to the value coded in the entry of  ``sp ``.
{
    uint_fast32_t i0, lg_int_fields, lg_field_bits, index_mask;

    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, i0
    lg_field_bits = %{MMV_CONST:LOG_FIELD_BITS,i0}; // This is LOG_FIELD_BITS
    lg_int_fields = %{MMV_CONST:LOG_INT_FIELDS,i0}; // This is LOG_INT_FIELDS
    index_mask = (1 << lg_int_fields) - 1;

    for ( ;length--; ++sp) {
        uint_fast32_t v = *sp, index;
        uint_fast32_t tag = v >> 25, i = (v >> 14) & 0x7ff, j = (v >> 8) & 0x3f;
        switch (tag) {
            case 2:  // tag B
            case 3:  // tag C
                if (i == j) continue;
                // Fall trough to case tag A
            case 1:  // tag A
                if (i >= 24 || j >= 24) continue;
                index = (tag - 1) * 768 + (i << 5) + j;
                set_sparse_value(index, v);
                index += 31 * (j - i);
                break;
            case 4:  // tag T
                if (i >= 759) continue;
                index = MM_AUX_OFS_T + (i << 6) + j;
                break;
            case 5:  // tag X
            case 6:  // tag Z
            case 7:  // tag Y
                if (j >= 24) continue;
                index = ((v >> 14) << 5) + j - 0x50000 + MM_AUX_OFS_X;
                break;
            default:
                continue;
        }
        set_sparse_value(index, v);
    }
}



/**
  @brief Extract signs of a vector in internal representation

  The function extracts the signs of certain entries of the
  vector ``mv`` depending on the vector ``sp ``. Vector ``mv`` is 
  given in internal representation  with modulus ``p``.  Vector ``sp`` 
  is given in sparse representation  and has length ``n``. 

  Entry ``sp[i]`` specifies a multiple ``c[i] * u[i]`` of a unit 
  vector ``u[i]``. Let ``m[i]`` be the coordinate of
  vector ``mv`` with respect to the unit vector ``u[i]``. We
  put ``s[i] = 0`` if ``m[i] = c[i]`` and ``s[i] = 1`` 
  if ``m[i] = -c[i]``. In all other cases we assign a random
  value 0 or 1 to ``s[i]``. Then the function returns the sum of
  the values ``s[i] << i``, where ``i`` ranges from ``0``
  to ``n - 1``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_extract_sparse_signs(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t n)
{
    uint_fast32_t i, v1 = 0, t;
    uint32_t sp1[32];

    if (mm_aux_bad_p(p)) return -1L;
    if (n > 31) return -1L;
    for (i = 0; i < n; ++i) sp1[i] = sp[i] & 0xffffff00UL;
    mm_aux_mmv_extract_sparse(p, mv, sp1, n);
    for (i = 0; i < n; ++i) {
        if ((sp1[i] & p) == 0) return -1L;
        t = (sp[i] ^ sp1[i]) & p;
        if ((t != 0) && (t != p)) return -1L;
        v1 |= (t & 1) << i;
    }
    return (int32_t)v1;
}




/**
  @brief Extract some bits of a vector in internal representation

  The function extracts the least significant bits of certain entries
  of the vector ``mv`` depending on the vector ``a``. Vector ``mv`` is
  given in internal representation  of the Monster with modulus ``p``.
 
  Vector ``a`` is a an array of ``n`` elements of the group ``Q_x0``
  of structure \f$2^{1+24}\f$, with each element given
  in **Leech lattice encoding**. Here each element of ``Q_x0`` must
  correspond to a Leech lattice vector of type 2; otherwise the
  function fails.

  The array ``elem`` represents an element of the group ``G_x0`` of
  structure \f$2^{1+24}.\mbox{Co}_1\f$, given in **G_x0 representation**.
  Internally, the function transforms (i.e. conjugates) all elements
  of ``Q_x0`` in the array ``a`` with the element ``elem``, i.e. it
  calculates the element ``a'[i] = elem^-1 * a[i] * elem`` of ``Q_x0``.
  Then it extracts the least significant bit ``b[i]`` of the entry of
  the vector ``mv`` with the coordinate labelled by ``a'[i]``.

  Note that negating ``a'[i]`` corresponds to negating the coordinate
  with label ``a'[i]`` in the vector ``mv``. Hence when
  negating ``a'[i]`` we also have to flip the bit ``b[i]``.
  The function fails in case ``a'[i] = 0``.

  The function returns the sum of the values ``b[i] << i``,
  where ``i`` ranges from ``0`` to ``n - 1``. The function also fails
  in case ``i > 31``. It returns a negative value in case of failure.

  Assume that a vector ``mv' = mv * q * g`` is given with a known
  vector ``mv``, a  known ``g`` in ``G_x0``, and an unknown ``q``
  in ``Q_x0``. Then the  main use case of this function  is to
  find the element ``q`` (up to sign)  without modifying ``mv'``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_extract_x_signs(uint32_t p, uint_mmv_t *mv, uint64_t *elem, uint32_t *a, uint32_t n)
{
    uint_fast32_t i, v1 = 0, b;
    uint32_t sp1[32];
    uint64_t ax[32];
    int32_t res;

    if (mm_aux_bad_p(p)) return -10001L;
    if (n > 31) return -10002L;
    for (i = 0; i < n; ++i) ax[i] = a[i];
    res = xsp2co1_xspecial_conjugate(elem, n, ax, 1);
    if (res < 0) return res;
    for (i = 0; i < n; ++i) {
        res = mm_aux_index_leech2_to_sparse((uint32_t)ax[i]);
        if (res == 0) return -10003L;
        sp1[i] = res & 0xffffff00;
    }
    mm_aux_mmv_extract_sparse(p, mv, sp1, n);
    for (i = 0; i < n; ++i) {
        if ((sp1[i] & p) == 0) return -10004L;
        b =  (sp1[i] ^ (uint_fast32_t)(ax[i] >> 24)) & 1;
        v1 |= b << i;
    }
    return (int32_t)v1;
}




/**********************************************************************
*** Operation on a sparse rep of a vector in R_p
**********************************************************************/

/**
  @brief Scalar multiplication and modular reduction in sparse representation

  The function multiplies a vector ``sp`` in sparse representation 
  with a factor ``f`` and reduces the result modulo a number ``p1``.
  
  The vector ``sp`` has length ``length`` and is stored in sparse
  representation as a vector modulo an odd number ``2 < p < 256``.
  The result is reduced modulo the number ``p1`` and stored in 
  sparse representation in the array ``sp1``.
  
  The number ``p1`` must be odd and satisfy ``2 < p < 256``. In case 
  ``f != 0`` the number ``p1`` must divide  ``p * abs(f)``.
  
  The function returns the length of the array ``sp1`` in case of 
  success and ``-1`` in case of failure. 
  
  The two arrays ``sp`` and ``sp1`` may be non overlapping or equal.
  
*/
// %%EXPORT px
int32_t mm_aux_mul_sparse(uint32_t p, uint32_t *sp, uint32_t length, int64_t f, uint32_t p1, uint32_t *sp1)
{
    uint8_t a[256], bad[256];
    uint_fast32_t mask = 4, i, is_bad = 0, difficult;
    
    if (p < 3 ||  p > 255 || (p & 1) == 0 ||
       p1 < 3 || p1 > 255 || (p1 & 1) == 0) return -1;
        
    f = f % (int64_t)p1;
    while (f < 0) f += p1;
    difficult = (f * p) % p1 != 0;

    if (f == 0) {
        mask = 0xffffff00;
        for (i = 0; i < length; ++i) sp1[i] = sp[i] & mask;
        return 0;
    }
    while (mask < p) mask += mask;
    if (mask > 256) return -1;
    --mask;
    if (p == p1 && f == 1) {
        mask |= 0xffffff00;
        for (i = 0; i < length; ++i) sp1[i] = sp[i] & mask;
        return length;
    }
    for (i = 0; i <= mask; ++i) a[i] = (uint8_t)((i * f) % p1);
    if (!difficult) {
        for (i = 0; i < length; ++i) {
            sp1[i] = (sp[i] & 0xffffff00) | a[sp[i] & mask]; 
        }
    } else {
        for (i = 0; i <= mask; ++i) {
            bad[i] = (uint8_t)((i * f * p) % p1);
        }
        for (i = 0; i < length; ++i) {
            sp1[i] = (sp[i] & 0xffffff00) | a[sp[i] & mask]; 
            is_bad |= bad[sp[i] & mask]; 
        }
    } 
    return is_bad ? -1 : length;
}

/**********************************************************************
*** Index conversion between external and sparse rep of vectors in R_p
**********************************************************************/


/**
  @brief Convert an index from external to sparse representation

  The function converts an index ``i`` for the external representation 
  of a vector to an index for the sparse representation of a vector
  and returns the converted index. The function returns 0 in case
  ``i >= 196884```. 

  Indices for the sparse representation are defined as 
  in ``enum MM_SPACE_TAG`` in file ``mm_basics.h``.
*/
// %%EXPORT px
uint32_t mm_aux_index_extern_to_sparse(uint32_t i)
// Convert external index i to sparse index.
// Return 0 if index i is bad
{
    if (i <  MM_AUX_XOFS_X) {
        if (i <  MM_AUX_XOFS_T) {
            // Tags A, B, C
            i = (MM_AUX_TBL_ABC[i] & 0x7ff) + i - 24;
            // put i += (i / 0x300) * 0x100; assuming 0 <= i < 0x900 
            i += (0x2A54000 >> ((i >> 8) << 1)) & 0x300;
            // now 0 <= i < 0xc00. output bits of old i as 
            // (tag - 1) = bits 11..10, i = bits 9..5, j = bits 4..0
            return 0x2000000 + ((i & 0xc00) << 15) +
                   ((i & 0x3e0) << 9) + ((i & 0x1f) << 8);
        } else {
            // Tag T
            i += 0x80000 - MM_AUX_XOFS_T;
            return i << 8;
        } 
    } else if (i <  MM_AUX_XLEN_V) {
        // Tags X, Z, Y
        i -=  MM_AUX_XOFS_X;
        // Put i += 8 * floor(i/24), for i <  3 * 2048 * 24
        i += (((i >> 3) * 0xaaab) >> 17) << 3; 
        // shift bits 17..5 of i to bit positions 18...6
        i += i & 0x3ffe0;
        i += 0xA0000;
        return i << 8;
    } else return 0;
}


/**
  @brief Convert index array from external to sparse representation

  The function converts an array ``a`` of indices for the external 
  representation to an array of indices for the sparse representation 
  of a vector. All indices in the array ``a`` of length ``len`` are
  converted in place, using function ``mm_aux_index_extern_to_sparse``.
*/
// %%EXPORT px
void mm_aux_array_extern_to_sparse(uint32_t *a, uint32_t len)
{
    for(; len--; ++a) *a = mm_aux_index_extern_to_sparse(*a); 
}


/**
  @brief Convert an index from sparse to external representation

  The function converts an index ``i`` for the sparse representation 
  of a vector to an index for the external representation of a vector
  and returns the converted index. The function returns -1 if the
  input ``i`` denotes an illegal index. The coordinate value encoded
  in the input ``i`` is ignored.
 
  Indices for the sparse representation are defined as 
  in ``enum MM_SPACE_TAG`` in file ``mm_basics.h``.
*/
// %%EXPORT px
int32_t mm_aux_index_sparse_to_extern(uint32_t i)
{
    uint_fast32_t tag = i >> 25, j = (i >> 8) & 0x3f;
    i = (i >> 14) & 0x7ff;
    switch (tag) {
        case 2:  // tag B
        case 3:  // tag C
            if (i == j) return -1;
            // Fall trough to case tag A
        case 1:  // tag A
            if (i >= 24 || j >= 24) return -1;
            if (i == j) return i;
            return  MM_AUX_XOFS_A - 276 + tag * 276 
                  + ((i * i - i) >> 1) + j;
        case 4:  // tag T
            if (i >= 759) return -1;
            return MM_AUX_XOFS_T + (i << 6) + j;
        case 5:  // tag X
        case 6:  // tag Z
        case 7:  // tag Y
            if (j >= 24) return -1;
            return  MM_AUX_XOFS_X - 0x3c000
                + 24 * ((tag << 11) + i) + j; 
        default:
            return -1;
    }
}

/**
  @brief Convert sparse index to a short vector in the Leech lattice

  The function converts an index ``i`` for the sparse representation
  of a vector to a vector ``v`` in the Leech lattice. This conversion 
  is successful if ``i`` denotes a legal index for one of the tags
  tags ``B, C, T, X``. Then the function computes a short Leech 
  lattice vector  (scaled to norm 32)  in the array ``v``. 
  Output ``v`` is determined up to sign only; that sign is 
  implementation dependent.

  The function returns 0 in case of a successful conversion and -1
  in case of failure.
*/
// %%EXPORT px
int32_t mm_aux_index_sparse_to_leech(uint32_t i, int32_t *v)
// Convert sparse index i to a short vector v in the Leech lattice.
// Vector v has norm 32. The sign of v is implementation dependent.
// Return -1 if index i is bad or does not map to a short vector
{
    uint_fast32_t tag = i >> 25, j = (i >> 8) & 0x3f, k, w, u_sub;
    i = (i >> 14) & 0x7ff;
    switch (tag) {
        case 2:  // tag B
        case 3:  // tag C
            if (i == j || i >= 24 || j >= 24) return -1;
            for (k = 0; k < 24; ++k) v[k] = 0;
            v[i] = v[j] = 4;
            if (i < j) i = j;
            if ((tag & 1) == 0) v[i] = -4;
            return 0;
        case 4:  // tag T
            if (i >= 759) return -1;
            w = mat24_octad_to_vect(i);
            // Put k = parity of j
            k = (0x96 >> ((j ^ (j >> 3)) & 7)) & 1;  
            // Let u_sub be a vector representing suboctad j of w 
            j = k + (j << 1);  // even-parity adjusted j
            u_sub = mat24_spread_b24(j, w);
            for (k = 0; k < 24; ++k) v[k] = 
                 2 * ((w >> k) & 1) - 4 * ((u_sub >> k) & 1);
            return 0;
        case 5:  // tag X
            if (j >= 24) return -1;
            w = mat24_gcode_to_vect(i);
            for (k = 0; k < 24; ++k) v[k] = 1 - 2 * ((w >> k) & 1);
            v[j] = v[j] < 0 ? 3 : -3;
            return  0; 
        default:
            return -1;
    }
}


/**
  @brief Convert sparse index to a short vector in the Leech lattice mod 2

  The function converts an index ``i`` for the sparse representation
  of a vector to a vector ``v`` in the Leech lattice mod 2. This 
  conversion  is successful if ``i`` denotes a legal index for one of 
  the tags tags ``B, C, T, X``. The function returns a short Leech 
  lattice vector modulo 2, encoded in **Leech lattice encoding**, as
  described in 
  section **Description of the mmgroup.generators extension**. 

  The function returns 0 in case of failure.
*/
// %%EXPORT px
uint32_t mm_aux_index_sparse_to_leech2(uint32_t i)
{
    uint_fast32_t tag = i >> 25, j = (i >> 8) & 0x3f,  res = 0;
    i = (i >> 14) & 0x7ff;
    switch (tag) {
        case 3:  // tag C
            res = 0x800000;
        case 2:  // tag B
            if (i == j || i >= 24 || j >= 24) return 0;
            return res + mat24_vect_to_cocode((1 << i) ^ (1 << j));
        case 4:  // tag T
            if (i >= 759) return 0;
            {
                uint_fast32_t w, gcode, cocode, v;
                // Put w = bitweight(j)  (mod 4)
                w = (j & 0x15) + ((j >> 1) & 0x15);
                w = w + (w >> 2) + (w >> 4);
                // Double j and adjust parity of j to even
                j = (j << 1) + (w & 1);
                gcode = MAT24_OCT_DEC_TABLE[i] & 0xfff;
                v = mat24_gcode_to_vect(gcode);
                cocode = mat24_vect_to_cocode(mat24_spread_b24(j, v));
                // Put w = bitweight(adjusted j)   (mod 4)
                w += w & 1;
                gcode ^= ((w >> 1) & 1) << 11;
                cocode ^= MAT24_THETA_TABLE[gcode & 0x7ff] & 0xfff;
                res = (gcode << 12) + cocode;
            }
            return res;
        case 5:  // tag X
            if (j >= 24) return 0;
            {
                uint_fast32_t w, gcode, cocode, theta;
                cocode = mat24_vect_to_cocode(1 << j);
                theta = MAT24_THETA_TABLE[i & 0x7ff];
                w = ((theta >> 12) & 1) ^ (i & cocode);
                mat24_def_parity12(w);
                gcode = i ^ (w << 11); 
                cocode ^= theta & 0xfff;
                res = (gcode << 12) + cocode;
            }
            return res;
        default:
            return 0;
    }
}





/**
  @brief Convert short vector in the Leech lattice mod 2 to sparse rep

  The function converts an value ``v2`` representing a vector in
  the Leech lattice mod 2 to a sparse index and returns that sparse
  index. It returns 0 if ``v2`` is not a short Leech lattice vector.
*/
// %%EXPORT px
uint32_t mm_aux_index_leech2_to_sparse(uint32_t v2)
{
    uint_fast32_t theta, syn, scalar, w, coc, octad, cw, lsb, cocodev, sub;

    // in the sequel we cut and paste the code for the detection of 
    // a short vector v2 in the Leech lattice mod 2 from 
    // function ``gen_leech2_type2`` in file ``gen_leech.c``.
    // After detecting such a short vector we convert that
    // vector to a sparse index.

    // Deal with odd cocode words
    if (v2 & 0x800) {   // Deal with odd cocode words
         // Let syn be the syndrome table entry for the cocode part
         theta = MAT24_THETA_TABLE[(v2 >> 12) & 0x7ff];
         syn = MAT24_SYNDROME_TABLE[(theta ^ v2) & 0x7ff];
         // Return 0 if syn does not encode a cocode word of length 1
         if ((syn & 0x3ff) < (24 << 5)) return 0;
         // Return  0 if scalar product <code, cocode> == 1  (mod 2)
         scalar = (v2 >> 12) &  v2 & 0xfff;
         mat24_def_parity12(scalar);
         if (scalar) return 0;
         // Here v2 is a short vector of shape (3^1,^1^23)
         // Return sparse vector with tag X
         return 0xA000000 + ((v2 & 0x7ff000) << 2) + ((syn & 0x1f) << 8);
    }
    // Deal with Golay code word 0
    if ((v2 & 0x7ff000L) == 0) {
         // Let syn be the syndrome table entry for the cocode part 
         syn = MAT24_SYNDROME_TABLE[v2 & 0x7ff];
         // Return 1 iff tab does not encode a cocode word of length 2
         if ((syn & 0x8000) == 0) return 0;

         // Compute cocode entries of v2
         syn = MAT24_SYNDROME_TABLE[(v2 ^ MAT24_RECIP_BASIS[23]) & 0x7ff];
         syn &= 0x3ff;
         // Bits 9..5 and bits 4..0 contain high and low cocode bit index.
         // Change a high cocode bit index 24 to 23.
         syn -= ((syn + 0x100) & 0x400) >> 5;

         // Return sparse vector with tag B is bit 23 of v2 is 0
         // and with tag C otherwise.
         return  ((syn >> 5) << 14) + ((syn & 0x1f) << 8) + 0x4000000 
                 + ((0x800000 & v2) << 2);
    }

    theta = MAT24_THETA_TABLE[(v2 >> 12) & 0x7ff];

    // Here (theta >> 12) & 7 is the bit weight of 
    // v2 + Omega * b23, where b23 is bit 23 of v2.
    // If bit 12 of theta is odd then v2 is a dodecad
    // and hence never short.
    if (theta & 0x1000) return 0;
    // Now v2 is a (possibly complemented) octad.
    // Put w = 1 if v2 is an octad and w = 0 otherwise.
    w = ((theta >> 13) ^ (v2 >> 23)) & 1;
    // XOR v2 with Omega if it has weight 16
    v2 ^= (1 - w) << 23;
    // Let coc be the cocode part of v2 (this is even)
    coc = (v2 ^ theta) & 0x7ff;
    // Let octad be the octad in vector representaition
    octad = mat24_def_gcode_to_vect(v2 >> 12); 

    // Now we proceed as in function suboctad_type(octad, w, coc)

    // Let cw be the halved bit weight of coc
    cw = MAT24_SYNDROME_TABLE[coc & 0x7ff] >> 15;
    // Put cocodev = cocode word of v (in vector rep), such 
    // that the cocode word is a suboctad of octad if possible.
    lsb = mat24_def_lsbit24(octad);
    coc ^= MAT24_RECIP_BASIS[lsb];
    syn = MAT24_SYNDROME_TABLE[coc & 0x7ff];
    cocodev = mat24_def_syndrome_from_table(syn) ^ (1UL << lsb);
    // Set sub = 0 iff cocodev is a subset of octad.
    sub = (octad & cocodev) != cocodev;
    // Check if v2 is short as in function suboctad_type().
    // Return 0 if this is not the case
    if (((~w ^ cw) & 1) | sub) return 0;

    // Here v2 is of type 2 and 'cocodev' is the cocode vector. 
    // Now we compute the number of the octad and the suboctad.
    v2 = mat24_def_gcode_to_octad(v2 >> 12); // Number of octad
    // Compute the suboctad in w
    w = mat24_extract_b24(cocodev, octad);   // This is the suboctad
    // Compute the number of the suboctad in w
    if (w & 0x80) w ^= 0xff;                 // Clear MSBit of suboctad
    w = (w >> 1) & 63;                       // Number of suboctad
    // Return sparse vector with tag 'T', octad, and suboctad
    return 0x8000000 + (v2 << 14) + (w << 8);
}



/**********************************************************************
*** Index conversion between internal and sparse rep of vectors in R_p
**********************************************************************/

/**
  @brief Convert an index from internal to sparse representation

  The function converts an index ``i`` for the internal representation 
  of a vector to an index for the sparse representation of a vector
  and returns the converted index. The function returns 0 in case
  of a bad index. 

  Indices for the sparse representation are defined as 
  in ``enum MM_SPACE_TAG`` in file ``mm_basics.h``.
*/
// %%EXPORT px
uint32_t mm_aux_index_intern_to_sparse(uint32_t i)
// Convert internal index i to sparse index.
// Return 0 if index i is bad
{
    uint32_t t, i0, i1, tmp;
    if (i <  MM_AUX_OFS_X) {
        if (i <  MM_AUX_OFS_T) {
            // put t =  (i / 0x300); assuming 0 <= i < 0x900 
            t = (0x2A540 >> ((i >> 8) << 1)) & 3;
            i0 = i - t * 0x300;
            i1 = i0 & 31;
            i0 >>= 5;
            if (i0 < i1) {
                tmp = i0; i0 = i1; i1 = tmp;
            }
            if (i0 >= 24) return 0;
            if (t && i0 == i1) return 0;
            return ((t + 1) << 25) + (i0 << 14) + (i1 << 8);
        } else {
            // Tag T
            i += 0x80000 - MM_AUX_OFS_T;
            return i << 8;
        } 
    } else if (i < MM_AUX_LEN_V) {
        // Tags X, Z, Y
        i -=  MM_AUX_OFS_X;
        i0 = i >> 5;
        i1 = i & 31;
        if (i1 >= 24) return 0;
        return  MM_SPACE_TAG_X + (i0 << 14) + (i1 << 8);
    } else return 0;
}




/**
  @brief Read entry from vector in internal rep indexed by Leech lattice 

  The  function returns the entry with index ``i`` of the
  vector ``mv`` with modulus ``p``. Here ``i`` must be an index
  referring to a vector of type 2 in the Leech lattice modulo 2
  in **Leech lattice encoding**. The sign bit 24 of ``i`` is
  evaluated as expected. The return value is reduced modulo ``p``.

  The function returns a negative value if ``i`` is not a vector of
  type 2 in the Leech lattice modulo 2 or ``p`` is not a legal modulus.
*/
// %%EXPORT px
int32_t mm_aux_get_mmv_leech2(uint32_t p, uint_mmv_t *mv, uint32_t v2)
{
    uint32_t ind = mm_aux_index_leech2_to_sparse(v2 & 0xffffffUL);
    if (ind == 0 || mm_aux_bad_p(p)) return -1; 
    ind += (0 - ((v2 >> 24) & 1)) & p;
    mm_aux_mmv_extract_sparse(p, mv, &ind, 1);    
    return ind & p;
}



/**********************************************************************
*** hashing
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 


#define CH 0x9e3779b97f4a7c15ULL // close to 2**63 * (sqrt(5)-1)
#define HASH_MAX_NOTZERO 2
#define LOG2_NHASH 3
#define HASH_MIN_GAP 512

/**
  @brief Compute hash value of vector of given length

  The  function returns a hash value of the  vector ``mv`` with 
  modulus ``p``. Here ``mv`` has ``n`` entries of type ``uint_mmv_t``.
  Parameter ``mask_1`` must have the value ``1`` in ech bit field
  of an integer of type ``uint_mmv_t``.

  The value of parameter ``hash`` (e.g. from a previously computed 
  hash value) will enter into the returned hash value.

  We first scan over blocks of four integers of type ``uint_mmv_t``
  until a such a block with at least one nonzero is found.
  The we enter the index of that block and the four entires of
  the block into the hash value. After having 
  found ``HASH_MAX_NOTZERO`` such blocks, we will hash 
  over ``1 << LOG2_NHASH`` more integers of type ``uint_mmv_t``,
  at fixed positions in the remaining part of the vector.
  We hash over the remaining part of the vector only if it
  contains at least ``HASH_MIN_GAP`` integers.
   
  Note that ``n`` might be rounded up to a multiple of four.
  This is no problem if a possible slack is still within 
  the original vector to be hashed. 
*/
static inline uint64_t do_hash(
    uint_mmv_t *mv,
    uint32_t n,
    uint32_t p,
    uint_mmv_t mask_1,
    uint64_t hash
)
{
    uint_mmv_t *m_end = mv + ((n + 3) & (0 - 4ULL));
    uint_mmv_t mask_p = (uint_mmv_t)(p) * mask_1;
    uint_mmv_t mask_ph = (mask_p & ~mask_1) >> 1;
    uint_mmv_t v, w;
    int32_t k = 0, j, d;

    while (mv < m_end) {
        w = mv[0];
        v = w ^ (w >> 1);
        w = mv[1];
        v |= w ^ (w >> 1);
        w = mv[2];
        v |= w ^ (w >> 1);
        w = mv[3];
        v |= w ^ (w >> 1);
        if (v & mask_ph) {
            hash = hash * CH + (uint64_t)(m_end - mv);
            for (j = 0; j < 4; ++j) {
                v = mv[j] & mask_p;
                v ^= (v >> 1) & mask_ph;    // map 11..1 to 10..0
                w = (v & mask_ph) + mask_1; // high bit is 0 iff v = x0..0
                v &= w | mask_ph;           // map 10..0 to 00..0
                hash = hash * CH + (uint64_t)v;
            }
            if (++k >= HASH_MAX_NOTZERO) {
                mv += 4;
                break;
            }
        }
        mv += 4;
    }
    hash = hash * CH + (uint64_t)(m_end + 1 - mv);
    d = (int32_t)(m_end - mv);
    if (d < HASH_MIN_GAP) return hash;
    d = (d >> LOG2_NHASH) - ((d & 1) ^ 1);
    for (j = d >> 1; j < d << LOG2_NHASH; j += d) {
        v = mv[j] & mask_p;
        v ^= (v >> 1) & mask_ph;
        w = (v & mask_ph) + mask_1;
        v &= w | mask_ph;
        hash = hash * CH + (uint64_t)v;   
    }
    return hash;
}

static uint32_t HASH_SECTIONS[6] = {
        MM_AUX_OFS_A,  MM_AUX_OFS_B, MM_AUX_OFS_T,
        MM_AUX_OFS_X, MM_AUX_OFS_Z, MM_AUX_LEN_V
};  



/// @endcond 


/**
  @brief Compute hash value of vector in internal

  The  function returns a hash value of the  vector ``mv`` with
  modulus ``p``. It also tries to distinguish between different
  sparse vectors. Therefore it tries to hash over about 100 nonzero
  integers of type ``uint_mmv_t``. So if ``mv`` is sparse then the
  function might have to scan considerably  more zero entries.
*/
// %%EXPORT px
uint64_t mm_aux_hash(uint32_t p, uint_mmv_t *mv)
{

    uint_fast32_t i, p_bits, l_if;
    uint_mmv_t mask_1; 
    uint64_t hash = p; 

    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, i
    p_bits = %{MMV_CONST:P_BITS, i};         // This is P_BITS
    l_if = %{MMV_CONST:LOG_INT_FIELDS, i};   // This is LOG_INT_FIELDS
    mask_1 =  MM_AUX_TBL_REDUCE[2*p_bits-4];

    for (i = 0; i < 5; ++i) hash = do_hash(
        mv + (HASH_SECTIONS[i] >> l_if),
        (HASH_SECTIONS[i+1] - HASH_SECTIONS[i]) >> l_if,
        p,
        mask_1,
        hash
    );
    return hash;
}


//  %%GEN h
/// @endcond 
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif
//  %%GEN c




