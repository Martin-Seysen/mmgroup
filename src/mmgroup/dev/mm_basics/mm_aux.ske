/** @file mm_aux.c

 File ``mm_aux.c`` provides the basic functions for dealing with the
 representations  of the monster group  modulo various small 
 integers ``p = 2**n-1``,  ``2 <= n <= 8``.
 Here the integer ``p`` is called the modulus. 

 Especially, we deal with vectors in such a representation as 
 described in  *The C interface of the mmgroup project*, 
 section *Description of the mmgroup.mm extension*.

 For such a vector there is an internal representation, an external
 representation, and also a sparse representation, as described in the
 documentation mentioned above.

 The functions in this file provide access to the internal representation 
 of such a vector. The also support the conversion between the different 
 representations of a vector.  

 Usually, the order of the parameters of functions in this file is:
      
       1. Modulus p, if present

       2. The input value or the input data array

       3. Any parameters that do not affect the positions in the output array

       4. The output data array

       5. Parameters (e.g. lengths, indices) that affect the positions of the 
          data being modified in the output array

 Among others, functions in this file use functions from
 file ``mm_index.c`` for converting indices of vectors to different
 representations.

 A vector modulo ``p`` is organized in rows of 32 entries. In many rows
 only 24 of the 32 bits are used; but in some all 32 bit are used. 
 Dtails are given in the *API reference* of the project. 
*/



/// @cond DO_NOT_DOCUMENT 
#include <stdlib.h>
#include "clifford12.h"
#include "mm_basics.h"
/// @endcond  





/// @cond DO_NOT_DOCUMENT 



// %%USE_TABLE
static const uint32_t MMV_CONST_TABLE[] = {
// %%TABLE MMV_CONST_TAB, uint32
};


static const uint_mmv_t MM_AUX_TBL_REDUCE[] = {
// %%TABLE MM_AUX_TBL_REDUCE, uint%{INT_BITS}
};

/// @endcond  





// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c

//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/**********************************************************************
*** Reading and writing entries of vectors of type uint_mmv_t[]
**********************************************************************/



/**
  @brief Read entry at index from vector in internal representation

  The  function returns the entry with index ``i`` of the
  vector ``mv`` with modulus ``p``. The return value is reduced 
  modulo ``p``. Index ``i`` must be given in internal 
  representation. The function returns garbage in case of an illegal
  index.
*/
// %%EXPORT px
uint8_t mm_aux_get_mmv(uint32_t p, uint_mmv_t *mv, uint32_t i)
// Return the entry of the vector mv in R_p at  index  i.
{
    uint_fast32_t  j, sh, res, c;
    if (mm_aux_bad_p(p)) return 0;

    // Store constant table for p to c
    // %%MMV_LOAD_CONST  p, c
    j = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS

    if (i >= MM_AUX_LEN_V) return 0; 

    sh = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    res = (uint_fast32_t)((mv[i >> j] >> sh) & p); // The result
    // Reduce result modulo p
    c = %{MMV_CONST:P_BITS,c}; // This is P_BITS
    return (uint8_t)((res + ((res + 1) >> c)) & p);
}







/**
  @brief Write entry to a vector at an index in internal representation

  The  function sets the entry of the vector ``mv`` with modulus ``p``
  at the index ``i`` to the given value. ``0 <= value <= p``
  must hold.

  Here the index ``i`` must be given in internal representation.
  Writing at an illegal index performs no action.
*/
// %%EXPORT px
void mm_aux_put_mmv(uint32_t p, uint8_t value, uint_mmv_t *mv, uint32_t i)
{

    uint_fast32_t  j, sh;
    int_fast32_t i_twin;
    uint_mmv_t value1 = value & p, mask = p;
    if (mm_aux_bad_p(p)) return;

    // %%MMV_LOAD_CONST  p, j
    j = %{MMV_CONST:LOG_INT_FIELDS,j}; // This is LOG_INT_FIELDS

    i_twin = mm_aux_index_check_intern(i);
    if (i_twin < 0) return; 

    sh = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    mv[i >> j] = (mv[i >> j] & ~(mask << sh)) | (value1 << sh);
    if (i_twin == 0) return;
    sh = (i_twin & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    mv[i_twin >> j] = (mv[i_twin >> j] & ~(mask << sh)) | (value1 << sh);
}




/**
  @brief Add to entry of a vector at an index in internal representation

  The  function adds the given value to the entry of the vector ``mv``
  with modulus ``p`` at the index ``i``. Here ``0 <= value <= p`` must
  hold.

  The index ``i`` must be given in internal representation.
  Writing at an illegal index performs no action.
*/
// %%EXPORT px
void mm_aux_add_mmv(uint32_t p, uint8_t value, uint_mmv_t *mv, uint32_t i)
{

    uint_fast32_t  j, sh, c;
    int_fast32_t i_twin;
    uint_mmv_t value1 = value & p, mask = p, old;
    if (mm_aux_bad_p(p)) return;

    // %%MMV_LOAD_CONST  p, c
    j = %{MMV_CONST:LOG_INT_FIELDS,c}; // This is LOG_INT_FIELDS
    c = %{MMV_CONST:P_BITS,c}; // This is P_BITS

    i_twin = mm_aux_index_check_intern(i);
    if (i_twin < 0) return; 

    // Read old value
    sh = (i & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    old = (mv[i >> j] >> sh) & p;
    // Add old value to value and reduce result
    value1 += old;
    value1 = (value1 + ((value1 + 1) >> c)) & p;

    mv[i >> j] = (mv[i >> j] & ~(mask << sh)) | (value1 << sh);
    if (i_twin == 0) return;
    sh = (i_twin & ((1 << j) - 1)) << (%{LOG_INT_BITS} - j);
    mv[i_twin >> j] = (mv[i_twin >> j] & ~(mask << sh)) | (value1 << sh);
}



/**********************************************************************
*** Reading and writing rows of vectors of type uint_mmv_t[]
**********************************************************************/





/**
  @brief Read entries from vector in internal representation

  Read entries of vector ``mv`` (stored in internal representation
  with modulus ``p``) and store these entries  in the array ``b``.
  Here ``len`` is the number of rows to be read starting at
  row ``i``. Each row consists of 32 entries.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_read_mmv32(uint32_t p, uint_mmv_t *mv, uint32_t i, uint8_t *b, uint32_t len)
{
    uint_fast32_t log_f, sh, tmp;  
    uint_mmv_t source;
    // %%MMV_LOAD_CONST  p, log_f
    sh = %{MMV_CONST:P_BITS,log_f};        // This is P_BITS
    log_f = %{MMV_CONST:LOG_FIELD_BITS,log_f}; // This is LOG_FIELD_BITS
    len = (len << 5) >> (%{LOG_INT_BITS} - log_f);
    mv += (i << 5) >> (%{LOG_INT_BITS} - log_f);

    switch (log_f) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                source = *mv++;
                // %%FOR jj in range(0, INT_BITS, 1 << LOG_F)
                tmp = (source >> %{jj}) & p;
                b[%{int:jj >> LOG_F}] = (uint8_t)((tmp + ((tmp + 1) >> sh)) & p);
                // %%END FOR
                b += %{int:INT_BITS >> LOG_F};
            }
            break;
        // %%END FOR
    }
}




/**
  @brief Write data to a vector in internal representation

  Write data from the array ``b`` to the vector ``mv`` (stored
  in internal representation with modulus ``p``). Here ``len``
  is the number of rows to be read starting at row ``i``. Each
  row consists of 32 entries.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_write_mmv32(uint32_t p, uint8_t *b, uint_mmv_t *mv, uint32_t i, uint32_t len)
{
    uint_fast32_t log_f;  
    uint_mmv_t dest;
    // %%MMV_LOAD_CONST  p, log_f
    log_f = %{MMV_CONST:LOG_FIELD_BITS,log_f}; // This is LOG_FIELD_BITS
    len = (len << 5) >> (%{LOG_INT_BITS} - log_f);
    mv += (i << 5) >> (%{LOG_INT_BITS} - log_f);
    
    switch(log_f) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                dest =  0;
                // %%FOR jj in range(0, INT_BITS, 1 << LOG_F)
                dest +=  (uint_mmv_t)(b[%{int:jj >> LOG_F}]) << %{jj};
                // %%END FOR
                *mv++ = dest;
                b += %{int:INT_BITS >> LOG_F};
            }
            break;
        // %%END FOR
    }
}

/**
  @brief Read rows of length 24 from vector in internal representation

  Read entries of vector ``mv`` with modulus ``p`` and store these 
  entries in the array ``b``, , starting at row ``i``. Here ``mv`` 
  is a vector of rows of 24  entries, with 8 entries slack after each 
  row. ``len`` is the number of such rows to be read. So altogether 
  24 * ``len`` entries are read from ``mv`` and written to 
  array ``b``; the 8 bytes slack after each 24-byte row are dropped.
  Vector ``b`` is reduced modulo ``p``.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_read_mmv24(uint32_t p, uint_mmv_t *mv, uint32_t i, uint8_t *b, uint32_t len)
{
    uint_fast32_t log_f, sh, tmp;  
    uint_mmv_t source;
    // %%MMV_LOAD_CONST  p, log_f
    sh = %{MMV_CONST:P_BITS,log_f};        // This is P_BITS
    log_f = %{MMV_CONST:LOG_FIELD_BITS,log_f}; // This is LOG_FIELD_BITS
    mv += (i << 5) >> (%{LOG_INT_BITS} - log_f);

    switch(log_f) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                // %%FOR j in range(0, 24)         
                // %%IF* (j << LOG_F) % INT_BITS == 0  # then reload source
                source = *mv++;                 
                // %%END IF
                tmp = (source >> %{int:(j << LOG_F) % INT_BITS}) & p;
                b[%{int:j}] = (uint8_t)((tmp + ((tmp + 1) >> sh)) & p);
                // %%END FOR                           
                b += 24;
                // %%IF* (24 << LOG_F) % INT_BITS == 0  # then adjust mv
                mv += %{int: (8 << LOG_F) / INT_BITS};
                // %%END IF
            }
            break;
        // %%END FOR
    }
}    


/**
  @brief Write rows of length 24 to vector in internal representation

  Write data from the array ``b`` to the vector ``mv`` with
  modulus ``p``. We take ``24 * len`` bytes from the array ``b``
  and write them to the vector ``mv``, starting at row ``i``.
  Here ``mv`` is considered as a vector of rows of 24 entries,
  with 8 entries slack after each row; so ``len`` is the number
  of such 24-byte rows to be written. The entries in the slack
  after each row written to ``mv`` are set to zero.

  Here ``p`` must be a legal modulus.
*/
// %%EXPORT px
void mm_aux_write_mmv24(uint32_t p, uint8_t *b, uint_mmv_t *mv, uint32_t i, uint32_t len)
{
    uint_fast32_t log_f;
    uint_mmv_t dest;
    // %%MMV_LOAD_CONST  p, log_f
    log_f = %{MMV_CONST:LOG_FIELD_BITS,log_f}; // This is LOG_FIELD_BITS
    mv += (i << 5) >> (%{LOG_INT_BITS} - log_f);

    switch(log_f) {
        // %%FOR LOG_F in [1, 2, 3]
        case %{LOG_F}:
            while (len--) {
                // %%FOR j in range(0, 24)             
                // %%IF* (j << LOG_F) % INT_BITS == 0  # then clear buffer
                // %%IF* (j > 0)                       # then write back data
                *mv++ = dest;                
                // %%END IF
                dest = 0;
                // %%END IF
                dest += (uint_mmv_t)(b[%{j}] & p) << %{int:(j<<LOG_F) % INT_BITS};
                // %%END FOR                           
                *mv++ = dest;                
                // %%FOR* k in range((8 << LOG_F) // INT_BITS)
                *mv++ = 0;
                // %%END FOR                              
                b += 24;
            }
            break;
        // %%END FOR
    }
} 



/**********************************************************************
*** Functions for data transfer from and to vectors in R_p.
*** Here such a vector is given in internal representation and of type 
*** uint_mmv_t[]. For modulus p, p + 1 must be a power of two.
**********************************************************************/

/**
  @brief Return the size of a vector in internal representation

  The  function returns the number of integers of type ``uint_mmv_t``
  required to store a vector of the representation \f$\rho_p\f$
  (in internal representation) with modulus ``p``.

  The function returns 0 if ``p`` is illegal modulus.
*/
// %%EXPORT px
uint32_t mm_aux_mmv_size(uint32_t p)
{
    uint_fast32_t tbl;
    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, tbl
    // return the value MMV_INTS for the specified p
    return%{MMV_CONST:MMV_INTS,tbl};
}


/**
  @brief Return number of entries stored in integer of type ``uint_mmv_t``

  The function returns the number of entries of a vector of the
  representation \f$\rho_p\f$ (in internal representation) that
  can be stored in an integer of type ``uint_mmv_t``.

  The function returns 0 if ``p`` is illegal modulus.
*/
uint32_t mm_aux_int_fields(uint32_t p)
{
    uint_fast32_t tbl;
    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, tbl
    // return the value INT_FIELDS for the specified p
    return%{MMV_CONST:INT_FIELDS,tbl};
}


/**
  @brief Return number of integers of type ``uint_mmv_t`` to store 24 entries

  The function returns the number of integers of type ``uint_mmv_t``
  required to store a part of 24 entries of a vector of the
  representation \f$\rho_p\f$ (in internal representation) with
  modulus ``p``. Such parts of 24 entries arise naturally in the
  construction of \f$\rho_p\f$.

  The function returns 0 if ``p`` is illegal modulus.
*/
uint32_t mm_aux_v24_ints(uint32_t p)
{
    uint_fast32_t tbl;
    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, tbl
    // return the value V24_INTS for the specified p
    return%{MMV_CONST:V24_INTS,tbl};
}


/**
  @brief Zero a vector in internal representation

  The  function sets all entries of the vector ``mv`` with 
  modulus ``p`` in internal  representation to zero.
*/
// %%EXPORT px
void mm_aux_zero_mmv(uint32_t p, uint_mmv_t *mv)
// Zero the vector of the representation R_p referred by mv,
{
    uint_fast32_t j;
    if (mm_aux_bad_p(p)) return;
    // %%MMV_LOAD_CONST  p, j
    j = %{MMV_CONST:MMV_INTS,j};
    do {
        *mv++ = 0;
    } while(--j);
}




/**
  @brief Randomize a vector in internal representation

  The function randomizes all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation uniformly using the 
  internal random generator in file ``gen_random.c``. 
  Parameter ``seed`` must be a seed for a random generator as 
  described in file ``gen_random.c``.
*/
// %%EXPORT px
void mm_aux_random_mmv(uint32_t p, uint_mmv_t *mv, uint64_t *seed)
{
    uint8_t b1[3072];
    uint_fast32_t i;

    if (mm_aux_bad_p(p)) return;

    // Do the small part
    gen_rng_bytes_modp(p,  (uint8_t *)(mv), 24 + 3 * 276, seed);
    mm_aux_small24_expand((uint8_t *)(mv), b1);
    mm_aux_write_mmv24(p, b1, mv, 0, 72);

    // Do the 759 * 64 vector; note that 759 = 11 * 69
    for (i = 0; i < 22; ++i) {
        gen_rng_bytes_modp(p, b1, 69 * 32, seed);
        mm_aux_write_mmv32(p, b1, mv, MM_AUX_OFS_T/32 + i*69, 69);
    } 

    // Do the 6144 * 24 vector
    for (i = 0; i < 48; ++i) {  
        gen_rng_bytes_modp(p, b1, 3072, seed);
        mm_aux_write_mmv24(p, b1, mv, MM_AUX_OFS_X/32 + i*128, 128);
    } 
}


/**********************************************************************
*** Reducing and checking a vector in R_p
**********************************************************************/

/**
  @brief Reduce a vector in internal representation

  The function reduces all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation to a standard form, so 
  that equal vectors are represented by equal arrays of integers.

  Note that a zero entry in such a vector can be represented either 
  by the bit string  ``0...0`` or by ``1...1``. This functions sets 
  all zero entries of the vector to ``0...0``.

  The function returns 0 if it detects no error.
  It may return the following error codes:

  -1: Bad modulus ``p``

  -2: A one bit outside a valid bit field for an entry has been found
*/
// %%EXPORT px
int32_t mm_aux_reduce_mmv(uint32_t p, uint_mmv_t *mv)
{
    return mm_aux_reduce_mmv_fields(p, mv, MM_AUX_LEN_V);
}

/**
  @brief Auxiliary function of function ``mm_aux_reduce_mmv``

  The function performs the same operation as 
  function ``mm_aux_reduce_mmv``. But instead of all entries 
  of the vector ``mv``, it reduces the first ``len`` entries
  only.
*/
// %%EXPORT px
int32_t mm_aux_reduce_mmv_fields(uint32_t p, uint_mmv_t *mv, uint32_t nfields)
{
    uint_fast32_t i, sh;
    uint_mmv_t data, cy, mask_1, mask_p, acc;

    if (mm_aux_bad_p(p)) return -1;
    // %%MMV_LOAD_CONST  p, i
    sh = %{MMV_CONST:P_BITS, i};          // This is P_BITS
    i = %{MMV_CONST:LOG_INT_FIELDS, i};   // This is LOG_INT_FIELDS
    i = nfields >> i;                     // No of unit_mmv_t to process
    mask_1 =  MM_AUX_TBL_REDUCE[2*sh-4];
    mask_p =  MM_AUX_TBL_REDUCE[2*sh-3];
    if (sh & (sh - 1)) {
        // case P_BITS is not a power of two
        acc = 0;      // use acc for accumulating error bits
        do {
            data = *mv;
            acc |= data;
            data &= mask_p;
            cy = (data + mask_1) & ~mask_p;
            data += (cy >> sh) - cy;
            *mv++ = data;
        } while (--i);
        if (acc & ~mask_p) return -2;
    } else {
        // case P_BITS is a power of two
        // use acc for  (<high half> & <low half>) of fields
        sh >>= 1;   // halved P_BITS
        do {
            data = *mv;
            acc = data & (data >> sh) & mask_p;
            cy = (acc + mask_1) & ~mask_p;
            data += (cy >> sh) - (cy << sh);
            *mv++ = data;
        } while (--i);
    }
    return 0;
}



/// @cond DO_NOT_DOCUMENT 

static int32_t check24(uint32_t p, uint_mmv_t *mv, uint32_t length)
{
    uint_fast32_t d;
    uint_mmv_t  acc = 0, mask;

    // %%MMV_LOAD_CONST  p, d
    // Put d =  5 - LOG_INT_FIELDS
    d = 5 - %{MMV_CONST:LOG_INT_FIELDS, d}; 
    switch (d) {
        // %%IF %{INT_BITS} == 64
        case 0:
            mask = %{hex: -1 << (3*INT_BITS//4)};
            while (length--) acc |= *mv++ & mask;
            break;
        // %%END IF
        case 1:
            mask = %{hex: -1 << (INT_BITS//2)};
            while (length--) {
                acc |= mv[1] & mask; mv += 2;
            }
            break;
        case 2:
            while (length--) {
                acc |= mv[3]; mv += 4;
            }
            break;
        // %%IF %{INT_BITS} == 32
        case 3:
            while (--length) {
                acc |= mv[6] | mv[7]; mv += 8;
            }
        // %%END IF
        break;
    }
    return acc ? -3 : 0;
}


static int32_t check_sym(uint32_t p, uint_mmv_t *mv, uint8_t * buffer)
// buffer is a work buffer of size at least 72 * 32
// Side effect: Tmv entries with tags A, B, C are read to the buffer
{
    uint_fast32_t i, acc = 0;
    uint8_t  *p_row, *p_col;
    mm_aux_read_mmv32(p, mv, 0, buffer, 72);
    for(i = 768; i < 1536; i += 33)  
        acc |= buffer[i] | buffer[i + 768];
    if (acc) return -4;
    p_row = buffer;
    acc = 0;
    for (p_col = buffer; p_col < buffer + 24; ++p_col) {
         for (i = 0; i < 24; ++i)
             acc |= (p_row[i] ^ p_col[i << 5]) 
                  | (p_row[i + 768] ^ p_col[(i << 5) + 768])
                  | (p_row[i + 1536] ^ p_col[(i << 5) + 1536]);
         p_row+= 32;
    }
    return acc ? -5 : 0;
}



static int32_t check_mmv_buffer(uint32_t p, uint_mmv_t *mv, uint8_t * buffer)
// Workhorse for function mm_aux_check_mmv. buffer must have size 72*32.
// Side effect: mv entries with tags A, B, C are read to the buffer
{
    uint_fast32_t i;
    i = mm_aux_reduce_mmv(p, mv);
    if (i) return i;                 // Errors -1, -2 may occur here
    i = check24(p, mv, 72);          // check tags A,B,C
    if (i) return i;                 // Error -3 may occur here
    // %%MMV_LOAD_CONST  p, i
    i = %{MMV_CONST:LOG_INT_FIELDS, i}; //  LOG_INT_FIELDS
    i = check24(p, mv + (MM_AUX_OFS_X >> i), 6144); // check tags X,Y,Z
    if (i) return i - 100;                 // Error -3 may occur here
    return check_sym(p, mv, buffer); // Errors -4, -5 may occur here
}

/// @endcond


/**
  @brief Check a vector in internal representation for errors

  The function checks all entries of the vector ``mv`` with 
  modulus ``p`` in internal representation for errors. It returns 0 
  if it detects no error. It may return the following error codes:

  -1: Bad modulus ``p``

  -2: A one bit outside a valid bit field for an entry has been found

  -3: A subfield of 24 entries has an illegal nonzero entry at index >= 24

  -4: The vector has an illegal nonzero diagonal entry 

  -5: The symmetric part of the vector is not actually symmetric 

As a side effect, ``mv`` is reduced with function ``mm_aux_reduce_mmv``.
*/
// %%EXPORT px
int32_t mm_aux_check_mmv(uint32_t p, uint_mmv_t *mv)
{
    uint8_t buffer[72*32];
    return check_mmv_buffer(p, mv, buffer);
}

/**********************************************************************
*** Low-level functions supporting external rep of vectors in R_p
**********************************************************************/

/** 
  @brief Convert part of vector from external to internal representation

  Conversion between the internal and the external representation 
  of a vector is straightforward, except for entries with
  tags ``A, B, C``. The entries with these tags are stored in the 
  first 852 entries of the external representation. In the internal
  representation the entries with these tags are spread over three
  symmetric 24 times 24 times matrices. 
 
  This function maps the 852 entries of the array ``b_src`` 
  (corresponding to tags ``A, B, C``) to the array ``b_dest`` of
  size 3 * 24 * 24 (corresponding to three
  symmetric 24 times 24 times matrices). 
  Function ``mm_aux_write_mmv24`` can be used to write the data
  from the array ``b_dest`` to the initial segment of the internal
  representation of a vector.
  
*/
// %%EXPORT px
void mm_aux_small24_expand(uint8_t *b_src, uint8_t *b_dest)
//
{
    uint_fast16_t j0, j1t, j1e;
    uint8_t *b_transpose = b_dest;
    for (j0 = 0; j0 < 24 * 25; j0 += 25) {
        b_dest[j0] = *b_src++;
        b_dest[j0 + 1152] =  b_dest[j0 + 576] = 0;
    }

    for (j0 = 0; j0 < 24; ++j0)  {
        j1e = 24 * j0;
        for (j1t = 0; j1t < j1e; j1t += 24) {
            b_transpose[j1t] = b_dest[0] = b_src[0];
            b_transpose[j1t + 576] = b_dest[576] = b_src[276];
            b_transpose[j1t + 1152] = b_dest[1152] = b_src[552];
            ++b_dest; ++b_src;
        }
        b_dest += 24 - j0;
        ++b_transpose;
    }
}

/** 
  @brief Convert part of vector from internal to external representation

  Conversion between the internal and the external representation 
  of a vector is straightforward, except for entries with
  tags ``A, B, C``. The entries with these tags are stored in the 
  first 852 entries of the external representation. In the internal
  representation the entries with these tags are spread over three
  symmetric 24 times 24 times matrices. 
 
  This function maps the 3 * 24 * 24 entries of the array ``b_src``
  (corresponding to three symmetric 24 times 24 times matrices)
  to the  852 entries of the array ``b_dest``  (corresponding to 
  tags ``A, B, C`` in external representation).

  This reverses the effect of function ``mm_aux_small24_expand``.
  Function ``mm_aux_read_mmv24`` can be used to read the data
  from the initial segment of the internal representation of a 
  vector to the array ``b_src``, before calling this function. 
*/
// %%EXPORT px
void mm_aux_small24_compress(uint8_t *b_src, uint8_t *b_dest)
//
{
    uint_fast16_t  j0, j1;
    for (j0 = 0; j0 < 24 * 25; j0 += 25) 
        *b_dest++ = b_src[j0];
    for (j0 = 0; j0 < 24; ++j0)  {
        for (j1 = j0; j1; --j1) {
            b_dest[0] = b_src[0];
            b_dest[276] = b_src[576];
            b_dest[552] = b_src[1152];
            ++b_dest; ++b_src;
        } 
        b_src += 24 - j0;
    }
}






/**********************************************************************
*** Conversion between internal and external rep of vectors in R_p
**********************************************************************/







/**
  @brief Convert vector from internal to external representation

  Read all entries of vector ``mv`` (stored in internal
  representation with modulus ``p``) and store these entries 
  in the array ``b`` in external representation.

  Output vector ``b`` is reduced modulo ``p``. It must have 
  length 196884.
*/
// %%EXPORT px
void mm_aux_mmv_to_bytes(uint32_t p, uint_mmv_t *mv, uint8_t *b)
{
    uint8_t b1[3*576]; 

    if (mm_aux_bad_p(p)) return;
    
    mm_aux_read_mmv24(p, mv, 0, b1, 72);
    mm_aux_small24_compress(b1, b);
    b +=  MM_AUX_XOFS_T;
    mm_aux_read_mmv32(p, mv, MM_AUX_OFS_T/32, b,  2*759);
    b +=  (MM_AUX_XOFS_X - MM_AUX_XOFS_T);
    mm_aux_read_mmv24(p, mv, MM_AUX_OFS_X/32, b, 6144);
}


/**
  @brief Convert vector from external to internal representation

  Read all entries of the array ```b`` (of length 196884, containing 
  a vector in external representation) and store these entries the 
  vector ``mv``. Here ``mv`` is a vector stored in internal
  representation with modulus ``p``. 

  Any entry ``x`` in the array ``b`` must satisfy ``0 <= x <= p``.
  The vector ``mv`` is an array of ``n`` integers of type
  ``uint_mmv_t`` with ``n =  mm_aux_mmv_size(p)``.
*/
// %%EXPORT px
void mm_aux_bytes_to_mmv(uint32_t p, uint8_t *b, uint_mmv_t *mv)
{
    uint8_t b1[3*576];

    if (mm_aux_bad_p(p)) return;

    mm_aux_small24_expand(b, b1);   
    mm_aux_write_mmv24(p, b1, mv, 0, 72);
    b +=  MM_AUX_XOFS_T;
    mm_aux_write_mmv32(p, b, mv, MM_AUX_OFS_T/32, 759*2);
    b +=  (MM_AUX_XOFS_X - MM_AUX_XOFS_T);
    mm_aux_write_mmv24(p, b, mv, MM_AUX_OFS_X/32, 6144);
}




/**********************************************************************
*** Conversion between internal and sparse rep of vectors in R_p
**********************************************************************/

/**
  @brief Convert vector from internal to sparse representation

  Read all entries of vector ``mv`` (stored in internal
  representation with modulus ``p``) and store these entries
  in the array ``sp`` in sparse representation. Each entry
  in the array ``sp`` represents a nonzero entry of the vector.
  The function returns the length of the output array ``sp``
  or an negative value in case of error. Negative return
  values are as in function ``check_mmv_buffer``.

  Output vector ``sp`` is reduced modulo ``p``. The buffer for
  array ``sp`` must have length 196884. Input vector ``mv``
  is checked with function ``check_mmv_buffer``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_to_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp)
{
    int32_t status;
    uint_fast32_t row, row_end,i, j, isp = 0, value;
    uint_fast32_t field_bits, lg_int_fields, ofs, sh;
    uint_mmv_t source;
    uint8_t b[72*32], *p_row;

    if ((status = check_mmv_buffer(p, mv, b)) != 0) return status;
    
    // %%MMV_LOAD_CONST  p, j
    field_bits = %{MMV_CONST:FIELD_BITS,j}; // This is FIELD_BITS
    lg_int_fields = %{MMV_CONST:LOG_INT_FIELDS,j}; // This is LOG_INT_FIELDS
    sh = 8 - %{LOG_INT_BITS} + lg_int_fields; // This is 8 - LOG_FIELD_BITS; 
 
    // Do tags A, B, C
    p_row = b;
    for (row = 0; row < 3; ++row) for (i = 0; i < 24; ++i) {
         for (j = 0; j <= i; ++j) {
            if ((value = p_row[j]) != 0)  sp[isp++] =
                0x2000000 + (row << 25) + (i << 14) + (j << 8) + value; 
        } 
        p_row += 32;
    }
    
    // Do tag T
    mv += MM_AUX_OFS_T >> lg_int_fields;
    row_end = (MM_AUX_OFS_X - MM_AUX_OFS_T) >> lg_int_fields;
    for (row = 0; row < row_end; ++row) if ((source = *mv++) != 0) {
        ofs = 0x8000000 + (row << (8 + lg_int_fields));
        for (j = 0; j < %{INT_BITS}; j += field_bits) {
            if ((value = (source >> j) & p) != 0)  {
                sp[isp++] = ofs + (j << sh) + value;
            } 
        }           
    }

    row_end = (MM_AUX_LEN_V - MM_AUX_OFS_X) >> lg_int_fields;
    for (row = 0; row < row_end; ++row) if ((source = *mv++) != 0) {
        ofs = 0x5000000 + (row << (8 + lg_int_fields));
        ofs += ofs & 0xfffe000;
        for (j = 0; j < %{INT_BITS}; j += field_bits) {
            if ((value = (source >> j) & p) != 0)  {
                 sp[isp++] = ofs + (j << sh) + value;
            } 
        }           
    }

    return (int32_t)isp; 
}

/**
  @brief Extract entries from a vector in internal representation

  The function extracts certain entries from the vector ``mv`` 
  depending on the vector ``sp``. Here ``mv`` is a vector stored 
  in internal representation with modulus ``p``.  Vector ``sp``
  is a vector of length ``length`` in sparse representation.

  The entries of vector ``sp`` are updated with the corresponding 
  entries of ``mv``. If ``sp`` has an entry with a certain label
  then the coordinate of that entry is set to the corresponding 
  coordinate of vector ``mv``. If several entries of ``sp`` have the 
  same label then the same coordinate is taken from ``mv`` 
  several times.

  Bit 7,...,0 of any entry of ``sp`` should be either 0 or p. If that
  value is 0 then the coordinate is read to bits 7,...,0 of that entry. 
  If that entry is ``p`` then the negative coordinate is read instead. 
  Other values of these bits are strongly discouraged; but technically 
  we XOR the corresponding coordinate of vector ``mv`` to these bits; 
  and we then change a result ``p`` to zero. There is a special case 
  where this detail is relevant.   
*/
// %%EXPORT px
void mm_aux_mmv_extract_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t length)
{
    uint_fast32_t p_bits;
    if (mm_aux_bad_p(p)) return;

    // %%MMV_LOAD_CONST  p, p_bits
    p_bits = %{MMV_CONST:P_BITS,p_bits}; // This is P_BITS

    for ( ;length--; ++sp) {
        uint32_t i_intern = mm_aux_index_sparse_to_intern(*sp);
        // set k to the (possibly negated) entry of vector mv. reduce v mod p.
        uint32_t k = (mm_aux_get_mmv(p, mv, i_intern) ^ *sp) & p;
        *sp = (*sp & 0xffffff00) + k; 
    }
}


/**
  @brief Extract one entry of a vector in internal representation

  The statement ``uint32_t sp1 = mm_aux_mmv_get_sparse(p, mv, sp);`` 
  is equivalent to

        uint32_t sp1 = sp; mm_aux_mmv_extract_sparse(p, mv, &sp1, 1);
      
*/
// %%EXPORT px
uint32_t mm_aux_mmv_get_sparse(uint32_t p, uint_mmv_t *mv, uint32_t sp)
{
     mm_aux_mmv_extract_sparse(p, mv, &sp, 1);
     return sp;
}




/**
  @brief Add vector in sparse rep to vector in internal representation

  The function adds a vector ``sp`` in sparse representation to a
  vector ``mv`` in internal representation with modulus ``p``. 
  Vector ``sp`` has length ``length``, and each value ``x`` in an 
  entry of vector ``sp`` must satisfy ``0 <= x <= p``. Different 
  entries in ``sp`` with the same index are added up.
*/
// %%EXPORT px
void mm_aux_mmv_add_sparse(uint32_t p, uint32_t *sp, uint32_t length, uint_mmv_t *mv)
{
    if (mm_aux_bad_p(p)) return;

    for ( ;length--; ++sp) {
        uint32_t i_intern = mm_aux_index_sparse_to_intern(*sp);
        mm_aux_add_mmv(p, (uint8_t)(*sp), mv, i_intern);
    }
}



/**
  @brief Set certain entries of a vector in internal representation

  The function sets certain entries of the vector ``mv `` depending on 
  the vector ``sp ``. Vector ``mv`` is given in internal representation 
  with modulus ``p``.  Vector ``sp`` is given in sparse representation 
  and has length ``length``. 

  If  ``sp `` has an entry with a certain label then the corresponding 
  entry of ``mv `` is set to to the value coded in that entry of ``sp ``.
  Each of these values ``x`` must  satisfy ``0 <= x <= p``. 
  Duplicate entries in ``sp `` with the same label and different values
  are illegal; in that case the value of ``mv `` is undefined.
*/
// %%EXPORT px
void mm_aux_mmv_set_sparse(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t length)
{
    if (mm_aux_bad_p(p)) return;

    for ( ;length--; ++sp) {
        uint32_t i_intern = mm_aux_index_sparse_to_intern(*sp);
        mm_aux_put_mmv(p, (uint8_t)(*sp), mv, i_intern);
    }
}



/**
  @brief Extract signs of a vector in internal representation

  The function extracts the signs of certain entries of the
  vector ``mv`` depending on the vector ``sp ``. Vector ``mv`` is 
  given in internal representation  with modulus ``p``.  Vector ``sp`` 
  is given in sparse representation  and has length ``n``. 

  Entry ``sp[i]`` specifies a multiple ``c[i] * u[i]`` of a unit 
  vector ``u[i]``. Let ``m[i]`` be the coordinate of
  vector ``mv`` with respect to the unit vector ``u[i]``. We
  put ``s[i] = 0`` if ``m[i] = c[i]`` and ``s[i] = 1`` 
  if ``m[i] = -c[i]``. In all other cases we assign a random
  value 0 or 1 to ``s[i]``. Then the function returns the sum of
  the values ``s[i] << i``, where ``i`` ranges from ``0``
  to ``n - 1``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_extract_sparse_signs(uint32_t p, uint_mmv_t *mv, uint32_t *sp, uint32_t n)
{
    uint_fast32_t i, v1 = 0, t;
    uint32_t sp1[32];

    if (mm_aux_bad_p(p)) return -1L;
    if (n > 31) return -1L;
    for (i = 0; i < n; ++i) sp1[i] = sp[i] & 0xffffff00UL;
    mm_aux_mmv_extract_sparse(p, mv, sp1, n);
    for (i = 0; i < n; ++i) {
        if ((sp1[i] & p) == 0) return -1L;
        t = (sp[i] ^ sp1[i]) & p;
        if ((t != 0) && (t != p)) return -1L;
        v1 |= (t & 1) << i;
    }
    return (int32_t)v1;
}




/**
  @brief Extract some bits of a vector in internal representation

  The function extracts the least significant bits of certain entries
  of the vector ``mv`` depending on the vector ``a``. Vector ``mv`` is
  given in internal representation  of the Monster with modulus ``p``.
 
  Vector ``a`` is a an array of ``n`` elements of the group ``Q_x0``
  of structure \f$2^{1+24}\f$, with each element given
  in **Leech lattice encoding**. Here each element of ``Q_x0`` must
  correspond to a Leech lattice vector of type 2; otherwise the
  function fails.

  The array ``elem`` represents an element of the group ``G_x0`` of
  structure \f$2^{1+24}.\mbox{Co}_1\f$, given in **G_x0 representation**.
  Internally, the function transforms (i.e. conjugates) all elements
  of ``Q_x0`` in the array ``a`` with the element ``elem``, i.e. it
  calculates the element ``a'[i] = elem^-1 * a[i] * elem`` of ``Q_x0``.
  Then it extracts the least significant bit ``b[i]`` of the entry of
  the vector ``mv`` with the coordinate labelled by ``a'[i]``.

  Note that negating ``a'[i]`` corresponds to negating the coordinate
  with label ``a'[i]`` in the vector ``mv``. Hence when
  negating ``a'[i]`` we also have to flip the bit ``b[i]``.
  The function fails in case ``a'[i] = 0``.

  The function returns the sum of the values ``b[i] << i``,
  where ``i`` ranges from ``0`` to ``n - 1``. The function also fails
  in case ``i > 31``. It returns a negative value in case of failure.

  Assume that a vector ``mv' = mv * q * g`` is given with a known
  vector ``mv``, a  known ``g`` in ``G_x0``, and an unknown ``q``
  in ``Q_x0``. Then the  main use case of this function  is to
  find the element ``q`` (up to sign)  without modifying ``mv'``.
*/
// %%EXPORT px
int32_t mm_aux_mmv_extract_x_signs(uint32_t p, uint_mmv_t *mv, uint64_t *elem, uint32_t *a, uint32_t n)
{
    uint_fast32_t i, v1 = 0, b;
    uint32_t sp1[32];
    uint64_t ax[32];
    int32_t res;

    if (mm_aux_bad_p(p)) return -10001L;
    if (n > 31) return -10002L;
    for (i = 0; i < n; ++i) ax[i] = a[i];
    res = xsp2co1_xspecial_conjugate(elem, n, ax, 1);
    if (res < 0) return res;
    for (i = 0; i < n; ++i) {
        res = mm_aux_index_leech2_to_sparse((uint32_t)ax[i]);
        if (res == 0) return -10003L;
        sp1[i] = res & 0xffffff00;
    }
    mm_aux_mmv_extract_sparse(p, mv, sp1, n);
    for (i = 0; i < n; ++i) {
        if ((sp1[i] & p) == 0) return -10004L;
        b =  (sp1[i] ^ (uint_fast32_t)(ax[i] >> 24)) & 1;
        v1 |= b << i;
    }
    return (int32_t)v1;
}




/**********************************************************************
*** Operation on a sparse rep of a vector in R_p
**********************************************************************/

/**
  @brief Scalar multiplication and modular reduction in sparse representation

  The function multiplies a vector ``sp`` in sparse representation 
  with a factor ``f`` and reduces the result modulo a number ``p1``.
  
  The vector ``sp`` has length ``length`` and is stored in sparse
  representation as a vector modulo an odd number ``2 < p < 256``.
  The result is reduced modulo the number ``p1`` and stored in 
  sparse representation in the array ``sp1``.
  
  The number ``p1`` must be odd and satisfy ``2 < p < 256``. In case 
  ``f != 0`` the number ``p1`` must divide  ``p * abs(f)``.
  
  The function returns the length of the array ``sp1`` in case of 
  success and ``-1`` in case of failure. 
  
  The two arrays ``sp`` and ``sp1`` may be non overlapping or equal.
  
*/
// %%EXPORT px
int32_t mm_aux_mul_sparse(uint32_t p, uint32_t *sp, uint32_t length, int64_t f, uint32_t p1, uint32_t *sp1)
{
    uint8_t a[256], bad[256];
    uint_fast32_t mask = 4, i, is_bad = 0, difficult;
    
    if (p < 3 ||  p > 255 || (p & 1) == 0 ||
       p1 < 3 || p1 > 255 || (p1 & 1) == 0) return -1;
        
    f = f % (int64_t)p1;
    while (f < 0) f += p1;
    difficult = (f * p) % p1 != 0;

    if (f == 0) {
        mask = 0xffffff00;
        for (i = 0; i < length; ++i) sp1[i] = sp[i] & mask;
        return 0;
    }
    while (mask < p) mask += mask;
    if (mask > 256) return -1;
    --mask;
    if (p == p1 && f == 1) {
        mask |= 0xffffff00;
        for (i = 0; i < length; ++i) sp1[i] = sp[i] & mask;
        return length;
    }
    for (i = 0; i <= mask; ++i) a[i] = (uint8_t)((i * f) % p1);
    if (!difficult) {
        for (i = 0; i < length; ++i) {
            sp1[i] = (sp[i] & 0xffffff00) | a[sp[i] & mask]; 
        }
    } else {
        for (i = 0; i <= mask; ++i) {
            bad[i] = (uint8_t)((i * f * p) % p1);
        }
        for (i = 0; i < length; ++i) {
            sp1[i] = (sp[i] & 0xffffff00) | a[sp[i] & mask]; 
            is_bad |= bad[sp[i] & mask]; 
        }
    } 
    return is_bad ? -1 : length;
}



/**********************************************************************
***  Read entry from vector indexed by Leech lattice
**********************************************************************/




/**
  @brief Read entry from vector in internal rep indexed by Leech lattice 

  The  function returns the entry with index ``i`` of the
  vector ``mv`` with modulus ``p``. Here ``i`` must be an index
  referring to a vector of type 2 in the Leech lattice modulo 2
  in **Leech lattice encoding**. The sign bit 24 of ``i`` is
  evaluated as expected. The return value is reduced modulo ``p``.

  The function returns a negative value if ``i`` is not a vector of
  type 2 in the Leech lattice modulo 2 or ``p`` is not a legal modulus.
*/
// %%EXPORT px
int32_t mm_aux_get_mmv_leech2(uint32_t p, uint_mmv_t *mv, uint32_t v2)
{
    uint32_t ind = mm_aux_index_leech2_to_sparse(v2 & 0xffffffUL);
    if (ind == 0 || mm_aux_bad_p(p)) return -1; 
    ind += (0 - ((v2 >> 24) & 1)) & p;
    mm_aux_mmv_extract_sparse(p, mv, &ind, 1);    
    return ind & p;
}



/**********************************************************************
*** hashing
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 


#define CH 0x9e3779b97f4a7c15ULL // close to 2**63 * (sqrt(5)-1)
#define HASH_MAX_NOTZERO 2
#define LOG2_NHASH 3
#define HASH_MIN_GAP 512

/**
  @brief Compute hash value of vector of given length

  The  function returns a hash value of the  vector ``mv`` with 
  modulus ``p``. Here ``mv`` has ``n`` entries of type ``uint_mmv_t``.
  Parameter ``mask_1`` must have the value ``1`` in ech bit field
  of an integer of type ``uint_mmv_t``.

  The value of parameter ``hash`` (e.g. from a previously computed 
  hash value) will enter into the returned hash value.

  We first scan over blocks of four integers of type ``uint_mmv_t``
  until a such a block with at least one nonzero is found.
  The we enter the index of that block and the four entires of
  the block into the hash value. After having 
  found ``HASH_MAX_NOTZERO`` such blocks, we will hash 
  over ``1 << LOG2_NHASH`` more integers of type ``uint_mmv_t``,
  at fixed positions in the remaining part of the vector.
  We hash over the remaining part of the vector only if it
  contains at least ``HASH_MIN_GAP`` integers.
   
  Note that ``n`` might be rounded up to a multiple of four.
  This is no problem if a possible slack is still within 
  the original vector to be hashed. 
*/
static inline uint64_t do_hash(
    uint_mmv_t *mv,
    uint32_t n,
    uint32_t p,
    uint_mmv_t mask_1,
    uint64_t hash
)
{
    uint_mmv_t *m_end = mv + ((n + 3) & (0 - 4ULL));
    uint_mmv_t mask_p = (uint_mmv_t)(p) * mask_1;
    uint_mmv_t mask_ph = (mask_p & ~mask_1) >> 1;
    uint_mmv_t v, w;
    int32_t k = 0, j, d;

    while (mv < m_end) {
        w = mv[0];
        v = w ^ (w >> 1);
        w = mv[1];
        v |= w ^ (w >> 1);
        w = mv[2];
        v |= w ^ (w >> 1);
        w = mv[3];
        v |= w ^ (w >> 1);
        if (v & mask_ph) {
            hash = hash * CH + (uint64_t)(m_end - mv);
            for (j = 0; j < 4; ++j) {
                v = mv[j] & mask_p;
                v ^= (v >> 1) & mask_ph;    // map 11..1 to 10..0
                w = (v & mask_ph) + mask_1; // high bit is 0 iff v = x0..0
                v &= w | mask_ph;           // map 10..0 to 00..0
                hash = hash * CH + (uint64_t)v;
            }
            if (++k >= HASH_MAX_NOTZERO) {
                mv += 4;
                break;
            }
        }
        mv += 4;
    }
    hash = hash * CH + (uint64_t)(m_end + 1 - mv);
    d = (int32_t)(m_end - mv);
    if (d < HASH_MIN_GAP) return hash;
    d = (d >> LOG2_NHASH) - ((d & 1) ^ 1);
    for (j = d >> 1; j < d << LOG2_NHASH; j += d) {
        v = mv[j] & mask_p;
        v ^= (v >> 1) & mask_ph;
        w = (v & mask_ph) + mask_1;
        v &= w | mask_ph;
        hash = hash * CH + (uint64_t)v;   
    }
    return hash;
}

static uint32_t HASH_SECTIONS[6] = {
        MM_AUX_OFS_A,  MM_AUX_OFS_B, MM_AUX_OFS_T,
        MM_AUX_OFS_X, MM_AUX_OFS_Z, MM_AUX_LEN_V
};  



/// @endcond 


/**
  @brief Compute hash value of vector in internal

  The  function returns a hash value of the  vector ``mv`` with
  modulus ``p``. It also tries to distinguish between different
  sparse vectors. Therefore it tries to hash over about 100 nonzero
  integers of type ``uint_mmv_t``. So if ``mv`` is sparse then the
  function might have to scan considerably  more zero entries.
*/
// %%EXPORT px
uint64_t mm_aux_hash(uint32_t p, uint_mmv_t *mv)
{

    uint_fast32_t i, p_bits, l_if;
    uint_mmv_t mask_1; 
    uint64_t hash = p; 

    if (mm_aux_bad_p(p)) return 0;
    // %%MMV_LOAD_CONST  p, i
    p_bits = %{MMV_CONST:P_BITS, i};         // This is P_BITS
    l_if = %{MMV_CONST:LOG_INT_FIELDS, i};   // This is LOG_INT_FIELDS
    mask_1 =  MM_AUX_TBL_REDUCE[2*p_bits-4];

    for (i = 0; i < 5; ++i) hash = do_hash(
        mv + (HASH_SECTIONS[i] >> l_if),
        (HASH_SECTIONS[i+1] - HASH_SECTIONS[i]) >> l_if,
        p,
        mask_1,
        hash
    );
    return hash;
}


//  %%GEN h
/// @endcond 
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif
//  %%GEN c




