/// @cond DO_NOT_DOCUMENT 
#define CLIFFORD12_INTERN
#include "clifford12.h"
#include "mm_basics.h"
/// @endcond 

// %%EXPORT_KWD MM_BASICS_API


// %%GEN h

/// @cond DO_NOT_DOCUMENT 

typedef struct {
    // public members:
    uint32_t data[6];
    uint32_t lookahead;
    // private members: storing input parameters
    uint32_t *g;
    int32_t e;
      // int32_t len_g; // not needed
    // private members: counters:
    int32_t index;
    // private members: compensations for negative exponents
    int32_t i_start;
    int32_t i_stop;
    int32_t i_step; 
    int32_t sign; 
} mm_group_iter_t;

/// @endcond

// %%GEN c



// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c

//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


#define END_WORD 0xffffffff

static inline void mm_group_iter_next_atom(mm_group_iter_t *pit)
{
    uint32_t result;
    if (pit->e == 0)  {
        pit->lookahead = END_WORD;
        return;
    }
    result =  pit->g[pit->index];
    if ((pit->index += pit->i_step) == pit->i_stop) {
        pit->index = pit->i_start;
        --pit->e;
    }
    pit->lookahead = result ^ pit->sign;
}



// %%EXPORT 
void mm_group_iter_start(mm_group_iter_t *pit, uint32_t *g, int32_t len_g, int32_t e)
{
    pit->g = g;
    pit->e = e;
    if (len_g == 0) pit->e = 0;
    if (e >= 0) {
        pit->i_start = 0; pit->i_stop = len_g; pit->i_step = 1;
        pit->sign = 0;
    } else {
        pit->i_start = len_g - 1; pit->i_stop = pit->i_step = -1;
        pit->sign = 0x80000000;
        pit->e = -e;
    }
    pit->index = pit->i_start;
    pit->lookahead = 0;
}




// %%EXPORT 
uint32_t  mm_group_iter_next(mm_group_iter_t *pit)
{
    uint32_t atom, tag, i, xi_used, *g;

    g = pit->data + 1;
    for (i = 0; i < 6; ++i) pit->data[i] = 0;
    xi_used = 0;

    while (1)  {
        atom = pit->lookahead;
        tag = (atom >> 28) & 0xf;
        switch (tag) {
            case 8:
            case 0:
                break;
            case 8 + 1:
            case 1:
                mm_group_n_mul_delta_pi(g, atom & 0xfff, 0);
                xi_used = 1;
                break;
            case 8 + 2:
                mm_group_n_mul_inv_delta_pi(g, 0, atom & 0xfffffff);
                xi_used = 1;
                break;
            case 2:
                mm_group_n_mul_delta_pi(g, 0, atom & 0xfffffff);
                xi_used = 1;
                break;
            case 8 + 3:
                atom ^= MAT24_THETA_TABLE[atom & 0x7ff] & 0x1000;
            case 3:
                mm_group_n_mul_x(g, atom & 0x1fff);
                xi_used = 1;
                break;
            case 8 + 4:
                atom ^= MAT24_THETA_TABLE[atom & 0x7ff] & 0x1000;
            case 4:
                mm_group_n_mul_y(g, atom & 0x1fff);
                xi_used = 1;
                break;
            case 8 + 5:
                atom ^= 0xfffffff;
            case 5:
                mm_group_n_mul_t(g, atom & 0xfffffff);
                xi_used = 1;
                break;
            case 8 + 6:
                atom ^= 0xfffffff;
            case 6:              
                if (xi_used)  return 0;
                pit->data[0] = (pit->data[0] + (atom & 0xfffffff)) % 3;
                break;
            default:
                atom |= 0x80000000;
                if (atom == END_WORD) return 1; 
                if (atom == 0xf0000000) return pit->lookahead = 0;
                return 2;
        }
        mm_group_iter_next_atom(pit);
    }

}



/////////////////////////////////////////////////////////////////////////
// Sspport for operation on part ABC on a vector
/////////////////////////////////////////////////////////////////////////

// %%EXPORT 
int32_t mm_group_prepare_op_ABC(uint32_t *g, uint32_t len_g, uint32_t *a)
{
    uint32_t i, tag, len_a; 
    uint32_t g_status = 0; // bit 0: tag t has been found
                           // bit 1: tag l has been found
                           // bit 2: g must be reduced
    for (i = 0; i < len_g; ++i) {
        // Gf both, tag t and l peviously have occcured
        // The we must reduce g
        g_status |= (g_status + 1) & 4;
        // Srore current tag in t
        tag = (g[i] >> 28) & 7;
        switch (tag) {
            case 5:  // tag t
                if (g[i] & 0xfffffff) g_status |= 1;
                break;
            case 6:   //tag l
                if (g[i] & 0xfffffff) g_status |= 2;
                // Reduce g if tag l occures after tag t
                g_status |= (g_status & 1) << 2;
            default:  // any tag except for t
                break;
        }
    }

    if ((g_status & 2) == 0) {
        // If tag t is not present, compute in subgroupe N_0
        uint32_t gn[5];
        mm_group_n_clear(gn);
        if (mm_group_n_mul_word_scan(gn, g, len_g) < 0) return -1;
        a[0] = 0;
        len_a = mm_group_n_to_word(gn, a + 1);
        return len_a + 0x101;
    } else if ((g_status & 4) || len_g > 16) {
       // Reduce g if this is required. The we present a prefix of g 
       // as a product of ``elem`` in G_x0 and ``gn`` in N_0
       uint32_t gn[5];    
       uint64_t elem[26];
       uint32_t pos = 0, scan, e;

       // Scan longest prefix of ``g`` in G_x0, and store it in ``elem``
       scan = xsp2co1_set_elem_word_scan(elem, g, len_g, 0);
       pos += scan;
       // Store remaining part of ``g`` in N_x0 if possible; 
       // abort if this is impossible.
       mm_group_n_clear(gn);
       scan = mm_group_n_mul_word_scan(gn, g + pos, len_g - pos);
       if (pos + scan < len_g) return -1;
       // If ``elem`` is in N0 then store  ``g`` as an element 
       // of ``N_x0`` in ``a`` with a preceding zero atom
       if (xsp2co1_elem_subtype(elem) == 0x48) {
           // Store ``elem`` in a + 1 as an element of N_x0
           if (xsp2co1_elem_to_N0(elem, a + 1)) return -1;
           // multiply it with ``gn``.
           mm_group_n_mul_element(a + 1, gn, a + 1);
           // Return g as a ward in a, preceded by a zero atom
           a[0] = 0;
           len_a = mm_group_n_to_word(gn, a + 1);
           return len_a + 0x101;
       } else {
           e = mm_group_n_right_coset_N_x0(gn);
           len_a = mm_group_n_to_word(gn, gn);
           if (xsp2co1_mul_elem_word(elem, gn, len_a) < 0) return -1;
           len_a =xsp2co1_elem_to_word(elem, a);
           if (len_a < 0) return -1;
           if (e) a[len_a++] = 0x5000000 + e;
           return len_a + 0x100;
       }
       
    } else {
       return len_g;
    }
}



//  %%GEN h
/// @endcond 
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif
//  %%GEN c

