// %%COMMENT
// For this module we refer to the section
// 'Computation in the Clifford group' in the guide, see
// https://mmgroup.readthedocs.io/en/latest/



/*************************************************************************
** External references 
*************************************************************************/

#include <string.h>
#include "mat24_functions.h"

#define CLIFFORD12_INTERN
#include "clifford12.h"


// %%EXPORT_KWD CLIFFORD12_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


/*************************************************************************
*** Basic definitions
*************************************************************************/


// Error codes returned by functions n this module
// These error codes extend those defined in  
// ``enum qstate12_error_type`` in file qstate12.h.
#define ERR_LEECH_OP -201  // Internal error in operation of group Co_0
#define ERR_REP_GX1 -202   // Error in operation of group 2^{{1+24}}.Co_1
#define ERR_NOTIN_XSP -203 // Element of 2^{{1+24}}.Co_1 not in 2^{{1+24}}
#define ERR_GX1_TAG -204   // Bad tag for atom in group 2^{{1+24}}.Co_1 

// The standard short Leech lattice vector modulo 3
#define STD_V3  0x8000004ULL
// The negative of STD_V3
#define STD_V3_NEG  0x4000008ULL


// If ERROR_POOL is defined then function xp2co1_error_pool() can
// read data from an "error pool" that contains debug information
// for certain functions after calling them.
// #define ERROR_POOL

// Number of entries of type uit64_t of the ERROR_POOL
#define LEN_ERROR_POOL 20

// Exchange the bits masked by ``mask`` of the integer ``a``
// with the corresponding bits masked by ``mask << sh``.
// ``mask & (mask << sh)` = 0`` must hold. ``aux`` must be an 
// integer variable of the same type as variable ``a``.
#define SHIFT_MASKED(a, aux, mask, sh) \
    aux = (a ^ (a >> sh)) & mask; \
    a ^=  aux ^  (aux << sh);


// Standard size of a buffer for a quaratic state matrix
// representing an element of the group G_{{x0}}. 
#define MAXROWS_ELEM 30


/*************************************************************************
*** Using a pool for recording errors (for debugging)
*************************************************************************/



#ifdef  ERROR_POOL

static uint64_t error_pool[LEN_ERROR_POOL];
#endif

// %%EXPORT px
uint32_t xp2co1_error_pool(uint64_t *dest, uint32_t length)
{
  #ifdef ERROR_POOL
    uint32_t i;
    if (length > LEN_ERROR_POOL) length = LEN_ERROR_POOL;
    for (i = 0; i < length; ++i) dest[i] = error_pool[i];   
    return length;
  #else
    return 0;  // Dummy if  ERROR_POOL is not #defined.
  #endif   // #ifdef  ERROR_POOL 
}



/*************************************************************************
*** Functions for supporting the Leech lattice mod 3
*************************************************************************/


// %%EXPORT px
uint64_t xp2co1_short_2to3(uint64_t x)
{
    uint64_t  gcodev, cocodev, theta, w, result;
    // Put gcodev = codeword (in vector rep)
    gcodev = mat24_gcode_to_vect((uint32_t)x >> 12); 
    theta = MAT24_THETA_TABLE[((uint32_t)x >> 12) & 0x7ff]; 
    // Put w = weight(code word gcodev) / 4
    w = 0 - ((x >> 23) & 1);
    w = (((theta >> 12) & 7) ^ w) + (w & 7);  
    #ifdef ERROR_POOL
        memset(error_pool, 0, sizeof(error_pool));
        error_pool[0] = x; error_pool[1] = gcodev; 
        error_pool[2] = theta; error_pool[3] = w; 
    #endif    

    if (x & 0x800) {  // case odd cocode
        uint_fast32_t scalar; 
        // Put cocodev = cocode word (in vector rep)
        cocodev = mat24_cocode_syndrome((uint32_t)(x ^ theta), 0);    
        #ifdef ERROR_POOL
            error_pool[4] = cocodev; 
        #endif    
        if (cocodev & (cocodev - 1)) return 0;
        // Put scalar = scalar product (code, cocode)
        scalar = (x >> 12) &  x & 0xfff;
        scalar ^= scalar >> 6;
        scalar ^= scalar >> 3;
        scalar = (0x96 >> (scalar & 7));
        #ifdef ERROR_POOL
            error_pool[5] = scalar & 1; 
        #endif    
        if (scalar & 1) return 0;
        result = (gcodev ^ ((gcodev ^ 0xffffff) << 24))
               & ~(cocodev | (cocodev << 24));
        #ifdef ERROR_POOL
            error_pool[6] = result; 
        #endif 
        return result;        
    } else { 
        uint_fast32_t  c_w;
        uint8_t c_list[4];
        // Put x[11...0] = cocode word (in cocode rep)
        x ^= theta; 
        #ifdef ERROR_POOL
            error_pool[4] = x; 
        #endif    
        switch (w) {
            case 4:
                gcodev ^= 0xffffff;
            case 2:
                // Put cocodev = cocode word (in vector rep)
                cocodev = mat24_cocode_syndrome((uint32_t)x, 
                    mat24_lsbit24((uint32_t)gcodev));
                // Put c_w = min weight of cocode word
                c_w = mat24_bw24((uint32_t)cocodev);
                #ifdef ERROR_POOL
                    error_pool[4] = gcodev; 
                    error_pool[5] = cocodev; 
                    error_pool[6] = c_w; 
                #endif    
                if ( ((cocodev & gcodev) != cocodev)
                    ||  (c_w ^ 2 ^ w) & 3 ) return 0;
                result = (gcodev & ~cocodev) | (cocodev << 24);
                #ifdef ERROR_POOL
                    error_pool[7] = result; 
                #endif    
                return result;
            case 3:
                return 0;
            default:  // can be case 0 or 6 only
                // Put c_w = min weight of cocode word
                // and store cocode bits in c_list.
                c_w = mat24_cocode_to_bit_list((uint32_t)x, 0, c_list);
                #ifdef ERROR_POOL
                    error_pool[4] = c_w; 
                    error_pool[5] = c_list[0]; 
                    error_pool[6] = c_list[1]; 
                #endif    
                if (c_w != 2) return 0;
                result = (ONE <<  c_list[0]) + (ONE <<  (c_list[1] + 24 - 4 * w));
                #ifdef ERROR_POOL
                    error_pool[7] = result; 
                #endif    
                return result;
        }
    } 
}



static inline uint32_t short_3_scalprod(uint64_t x1, uint64_t x2)
{
    uint64_t zero, res;
    
    // Set all bits i in ``zero`` to 0 where x1[i] * x2[i] is 0
    zero = ((x1 ^ (x1 >> 24)) & (x2 ^ (x2 >> 24))) & 0xffffffUL;
    // Store scalar products of entries of x1 and x2 in res
    // Each scalar product is >= 0 and <= 2.
    res = (x1 ^ x2) & 0xffffff000000ULL;
    res = (res & (zero << 24)) | (zero & ~(res >> 24));
    // Sum up entries of res, counting the high 24 bits twice
    res = (res & 0x555555555555ULL) + ((res >> 1) & 0x555555555555ULL);
    res = (res & 0x333333333333ULL) + ((res >> 2) & 0x333333333333ULL);
    res = (res & 0x0f0f0f0f0f0fULL) + ((res >> 4) & 0x0f0f0f0f0f0fULL);
    res = (res & 0xffffffULL) + ((res >> 23) & 0x1fffffeULL);
    res = ((res >> 16) + (res >> 8) + res) & 0xff;
    // Reduce res modulo 3; we have 0 <= res <= 48
    res = (res & 3) + (res >> 2) + 1; // res <= 19; res is one too big
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 7
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 4
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 3
    return (uint32_t)res - 1;
}


static inline uint64_t short_3_reduce(uint64_t x)
{
    uint64_t a = (x & (x >> 24)) & 0xffffffUL;
    x ^=  a | (a << 24);
    return x  & 0xffffffffffffULL;
}



// %%EXPORT px
uint64_t xp2co1_short_3to2(uint64_t x)
{
    uint_fast32_t  gcodev, cocodev, theta, w1, w2;
    x = short_3_reduce(x);
    w1 = mat24_bw24((uint32_t)x); 
    w2 = mat24_bw24((uint32_t)(x >> 24));
    switch (w1 + w2) {
        case 23:
            cocodev = ~(uint32_t)(x | (x >> 24)) & 0xffffffUL;
            if ((cocodev == 0) || (cocodev & (cocodev - 1))) return 0; 
            gcodev = (uint32_t)(x >> ((0-(w1 & 1)) & 24)) & 0xffffffUL;
            if ((w1 + 1) & 4)  gcodev ^= 0xffffffUL;
            break;              
        case 8:
            if (w1 & 1) return 0;
            gcodev = (x | (x >> 24)) & 0xffffffUL;
            cocodev = x & 0xffffffUL;
            if (w1 & 2) gcodev ^= 0xffffffUL;
            break;
        case 2:
            cocodev = (x |  (x >> 24)) & 0xffffffUL;
            gcodev = (w1 & 1) ? 0 : 0xffffffUL;
            break;
        default:
            return 0;        
    }
    gcodev = mat24_vect_to_gcode(gcodev);
    if (gcodev & 0xfffff000UL) return 0;
    theta = MAT24_THETA_TABLE[gcodev & 0x7ff] & 0xfff;
    cocodev = mat24_vect_to_cocode(cocodev);
    return (gcodev << 12) ^ theta ^ cocodev;
}



/*************************************************************************
*** Conversion between the two standard bases for group elements
*************************************************************************/





static inline
int32_t xp2co1_conv_conjugate_basis(qstate12_type *pqs)
{
    return qstate12_gate_h(pqs, 0x800800);
}



static inline uint32_t conv_pauli_vector_xspecial(uint32_t x)
{  
    uint32_t t;
    x &= 0x1ffffff;
    t = (x ^ (x >> 12)) & 0x800UL;
    x ^= (t << 12) ^ t;       
    t = x & (x >> 12) & 0x7ff;
    t ^= t >> 6; t ^= t >> 3; 
    t = (0x96 >> (t & 7)) & 1;
    x ^= t << 24;
    return x;
}



static inline uint32_t conv_pauli_vector_xspecial_nosign(uint32_t x)
{  
    uint32_t t;
    t = (x ^ (x >> 12)) & 0x800UL;
    x ^= (t << 12) ^ t;       
    return x;
}

/*************************************************************************
*** Chains of short vectors in the Leech lattice mod 3
*************************************************************************/


// %%EXPORT px
uint64_t xp2co1_find_chain_short_3(uint64_t x1, uint64_t x2)
{
    uint64_t mask;
    uint_fast32_t support1, support2, c1, c2;
    x1 = short_3_reduce(x1);
    x2 = short_3_reduce(x2);
    // Compute the support of x1 in variable support1
    support1 = (uint32_t)((x1 | (x1 >> 24)) & 0xffffffUL);
    // Compute the support of x2 in variable support2
    support2 = (uint32_t)((x2 | (x2 >> 24)) & 0xffffffUL);
    if (support1 & ~support2) {
        // Find a bit c1 in (support1 & ~support2) and a bit c2 in
        // support2 and return a vector with support at bit positions
        // at c1 and c2, and entries taken from vector x1.
        // Fail if x2 ==  0
        c1 = mat24_lsbit24(support1 & ~support2);
        c2 = mat24_lsbit24(support2);
        if (c2 >= 24) return 0;
        mask = (ONE << c1) ^ (ONE << c2);
        mask = x1 & (mask | (mask << 24));
        if ((mask & (mask-1)) == 0) mask |= (ONE << c2);
        return mask;
    }
    if (support2 & ~support1) {
        // Similar to previous case, exchanging the roles of x1 and x2.
        c2 = mat24_lsbit24(support2 & ~support1);
        c1 = mat24_lsbit24(support1);
        if (c1 >= 24) return 0;
        mask = (ONE << c1) ^ (ONE << c2);
        mask = x2 & (mask | (mask << 24));
        if ((mask & (mask-1)) == 0) mask |= (ONE << c1);
        return mask;
    }
    if (support2 & support2) {
        // If (~support1 & ~support2) is not empty then take an entry
        // with one nonzero value at a position in (support2 & support2)
        // and one nonzero value at a position in (~support2 & ~support2).
        c1 = mat24_lsbit24(support1 & support2);
        c2 = mat24_lsbit24(~support1 & ~support2);
        if (c2 < 24) return (ONE << c1) ^ (ONE << c2);
        // Here the support of both, x1 and x2, comprises all 24 bits.
        // Find two bit positions c1 and c2, where both, x1 and x2, have 
        // equal values. Return a vector with support at bit positions
        // at c1 and c2, and entries taken from vector x1.
        mask = (x1 ^ x2) & 0xffffffUL;
        if ((mask & (mask-1)) == 0) mask ^= 0xfffffffUL;
        c1 = mat24_lsbit24((uint32_t)mask);
        mask ^= ONE << c1;
        c2 = mat24_lsbit24((uint32_t)mask); 
        mask = (ONE << c1) ^ (ONE << c2);       
        return x1 & (mask | (mask << 24));
    }
    return 0;
}





// %%EXPORT p
int32_t xp2co1_chain_short_3(qstate12_type *pqs, uint32_t length, uint64_t *psrc, uint64_t *pdest)
{
    uint64_t dest0, prod, src_prod;
    int_fast32_t res, ok;
    uint_fast32_t i;

    if bad_state(pqs) return ERR_QSTATE12_INCONSISTENT;
    if (pqs->ncols != 24 || pqs->shape1 != 12) 
         return ERR_QSTATE12_SHAPE_OP;
    
    if (length <= 0) return 0;
    dest0 = short_3_reduce(pdest[0]);
    for (i = 0; i < length; ++i) {
        pdest[i] = xp2co1_short_3to2(psrc[i]);
        pdest[i] = conv_pauli_vector_xspecial_nosign((uint32_t)pdest[i]);
    }
    res = qstate12_pauli_conjugate(pqs, length, pdest);
    if (res < 0) return res;
    for (i = 0; i < length; ++i) {
        pdest[i] = conv_pauli_vector_xspecial_nosign((uint32_t)pdest[i]);
        pdest[i] = xp2co1_short_2to3(pdest[i]);
    }    
    ok = (pdest[0] ==  dest0) || 
        (short_3_reduce(pdest[0] ^ 0xffffffffffffULL) == dest0);
    pdest[0] = ok ? dest0 : 0;
    for (i = 1; i < length;  ++i) {
        src_prod = short_3_scalprod(psrc[i-1], psrc[i]);
        prod =  short_3_scalprod(pdest[i-1], pdest[i]);
        if (prod != src_prod) pdest[i] = 
            short_3_reduce(pdest[i] ^ 0xffffffffffffULL);
        ok = ok && src_prod  &&  prod;
    }
    return ok ? 0 : ERR_LEECH_OP;
}



/*************************************************************************
*** Conversion between quadratic state matrices and group elements
*************************************************************************/


// %%EXPORT p
int32_t xp2co1_elem_to_qs(uint64_t *e, qstate12_type *pqs)
{
    int32_t res;
    res = qstate12_set_mem(pqs, e + 1, 25); 
    if (res < 0) return res;
    pqs->maxrows = pqs->nrows = 25;
    pqs->ncols = 24;
    pqs->shape1 = 12;
    pqs->factor = -12 * 16;
    while (pqs->nrows > 1 && pqs->data[pqs->nrows - 1] == 0) {
        --pqs->nrows;
        pqs->factor += 16;
    }
    return 0;
}



static inline 
int32_t xp2co1_qs_to_elem_noreduce(qstate12_type *pqs, uint64_t x1, uint64_t *e)
{
    uint_fast32_t i;
    if (pqs->nrows > 25) return ERR_QSTATE12_BUFFER_OVFL;
    for (i = 0; i < pqs->nrows; ++i) {
        e[i+1] =  pqs->data[i] & 0x1fffffeffffffULL;
    }
    for (i = pqs->nrows; i < 25; ++i) e[i+1] = 0;
    if (pqs->factor & 4) x1 ^= 0xffffffffffffULL;
    e[0] = short_3_reduce(x1);  
    return 0;    
}

// %%EXPORT p
int32_t xp2co1_qs_to_elem(qstate12_type *pqs, uint64_t x1, uint64_t *e)
{
    int32_t res;
    res = qstate12_reduce(pqs); 
    if (res < 0) return res;
    res = qstate12_check(pqs);
    if (res < 0) return res;
    return  xp2co1_qs_to_elem_noreduce(pqs, x1, e);    
}



// %%EXPORT px
int32_t xp2co1_reduce_elem(uint64_t *e)
{
    int32_t res;
    qstate12_type qs;
    res = xp2co1_elem_to_qs(e, &qs);
    if (res < 0) return res;
    return xp2co1_qs_to_elem(&qs, e[0], e); 
}


/*************************************************************************
*** Elementary function operating on group elements
*************************************************************************/




// %%EXPORT px
void xp2co1_neg_elem(uint64_t *e)
{
    e[0] = short_3_reduce(e[0] ^ 0xffffffffffffULL);
}


// %%EXPORT px
void xp2co1_copy_elem(uint64_t *e1, uint64_t *e2)
{
    uint_fast32_t i;
    for (i = 0; i < 26; ++i) e2[i] = e1[i];
}






/*************************************************************************
*** Group multiplication and inversion
*************************************************************************/


// %%EXPORT px
int32_t xp2co1_mul_elem(uint64_t *e1, uint64_t *e2, uint64_t *e3)
{
    int32_t res;
    qstate12_type qs1, qs2, qs3;
    uint64_t data3[MAXROWS_ELEM], asrc[3], adest[3];
    res = xp2co1_elem_to_qs(e1, &qs1);
    if (res < 0) return res;
    res = xp2co1_elem_to_qs(e2, &qs2);
    if (res < 0) return res;
    res = qstate12_set_mem(&qs3, data3, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_matmul(&qs2, &qs1, &qs3);
    if (res < 0) return res;
    
    asrc[0] = STD_V3;
    adest[0] = e2[0];
    asrc[2] = e1[0];
    asrc[1] = xp2co1_find_chain_short_3(asrc[0], asrc[2]);
    res = xp2co1_chain_short_3(&qs2, 3, asrc, adest);
    #ifdef ERROR_POOL
        memcpy(error_pool+9, asrc, 3 * sizeof(uint64_t));
        memcpy(error_pool+12, adest, 3 * sizeof(uint64_t));
    #endif    
    if (res < 0) return res;
    res = xp2co1_qs_to_elem(&qs3, adest[2], e3);
    return res;
}


// %%EXPORT px
int32_t xp2co1_inv_elem(uint64_t *e1, uint64_t *e2)
{
    int32_t res;
    qstate12_type qs1, qs2;
    uint64_t data2[MAXROWS_ELEM], asrc[3], adest[3];
    res = xp2co1_elem_to_qs(e1, &qs1);
    if (res < 0) return res;
    res = qstate12_copy_alloc(&qs1, &qs2, data2, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_mat_inv(&qs2);
    if (res < 0) return res;

    asrc[0] = e1[0];
    adest[0] = STD_V3;
    asrc[2] = STD_V3;
    asrc[1] = xp2co1_find_chain_short_3(asrc[0], asrc[2]);
    res = xp2co1_chain_short_3(&qs2, 3, asrc, adest);
    if (res < 0) return res;
    res = xp2co1_qs_to_elem(&qs2, adest[2], e2);
    return res;
}



/*************************************************************************
*** Conjugation of extraspecial element with group element
*************************************************************************/


// %%EXPORT px
int32_t xp2co1_xspecial_conjugate(uint64_t *elem, uint32_t n, uint64_t *pv)
{
    qstate12_type qs, qs1;
    uint64_t data[MAXROWS_ELEM];
    int_fast32_t res;
    uint_fast32_t i;

    res = xp2co1_elem_to_qs(elem, &qs);
    if (res < 0) return res;
    res = qstate12_copy_alloc(&qs, &qs1, data, MAXROWS_ELEM);
    if (res < 0) return res;

    for (i = 0; i < n; ++i) {
        pv[i] = conv_pauli_vector_xspecial((uint32_t)pv[i]);
    }
    res = qstate12_pauli_conjugate(&qs, n, pv);
    if (res < 0) return res;
    for (i = 0; i < n; ++i) {
        pv[i] = conv_pauli_vector_xspecial((uint32_t)pv[i]);
    }    
    return 0;
}

/*************************************************************************
*** Check if an element is in the extraspecial group
*************************************************************************/




// %%EXPORT px
int32_t xp2co1_xspecial_vector(uint64_t *elem, uint32_t *pv)
{
    int32_t res;
    qstate12_type qs, qs1;
    uint64_t data[MAXROWS_ELEM], v, e0;
    res = xp2co1_elem_to_qs(elem, &qs);
    if (res < 0) return res;
    res = qstate12_copy_alloc(&qs, &qs1, data, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_pauli_vector(&qs1, &v);
    if (res < 0) {
       return res == ERR_QSTATE12_PAULI_GROUP ? ERR_NOTIN_XSP : res;
    }
    e0 = short_3_reduce(elem[0]);
    if (e0 == STD_V3_NEG) v ^= 0x1000000;
    else if (e0 != STD_V3) return ERR_NOTIN_XSP;
    *pv = conv_pauli_vector_xspecial((uint32_t) v);
    return 0;
}


/*************************************************************************
*** Construction of  elements in the extraspecial subgroup
*************************************************************************/


// %%EXPORT px
void xp2co1_unit_elem(uint64_t *e)
{
    uint_fast32_t i;
    uint64_t mask = 0x800800ULL;
    e[0] = STD_V3;
    e[1] = 0;
    for (i = 2; i < 14; ++i) {
        e[i] = mask;
        mask >>= 1;
    }
    for (i = 14; i < 26; ++i) e[i] = 0;
}




static inline 
int32_t elem_op_xspecial(uint64_t *e1, uint32_t x)
// Multiplies the element ``e1`` of the group ``G_{{x1}}`` with
// the element ``x`` of the extraspecial group. Here 
// ``x_d`` * ``x_delta`` in the notation of :cite:``Seys19``
// is encoded as ``x = 0x1000 * d + delta``, ``0 <= x < 0x2000``,
// ``0 <= delta < 0x1000``.
{
    int32_t res;
    qstate12_type qs; 
    uint64_t w;
    
    res = xp2co1_elem_to_qs(e1, &qs);
    if (res < 0) return res;
    x = conv_pauli_vector_xspecial(x);
    // Apply phase pi gate to rows i = 0,...,11 if bit i of x is 1.
    if ((res = qstate12_mul_Av(&qs, (x & 0xfff) << 12, &w)) < 0) 
        return res;
    e1[1] ^= (w & (0-2ULL)) << 24;
    // Apply not gate to rows i = 0,...,11 if bit i+12 of x is 1.
    e1[1] ^= x & 0xfff000;
    // Negate element if necessary
    if ((w ^ (x >> 24)) & 1) {
        e1[0] = short_3_reduce(e1[0] ^ 0xffffffffffff);
    }
    return 0;
}



// %%EXPORT px
int32_t xp2co1_elem_xspecial(uint64_t *e1, uint32_t x)
{
    xp2co1_unit_elem(e1);
    return elem_op_xspecial(e1, x);
}


// %%EXPORT px
int32_t xp2co1_elem_x_delta(uint64_t *e1, uint32_t x, uint32_t delta)
{
    uint_fast32_t v;
    v =  ((x & 0x1fffUL) << 12) + (delta & 0xfffUL);
    v ^=  MAT24_THETA_TABLE[x & 0x7ff] & 0xfff;
    xp2co1_unit_elem(e1);
    return elem_op_xspecial(e1, v);
}



/*************************************************************************
*** Construction of other group elements
*************************************************************************/


static 
int32_t elem_delta_pi_aut(uint64_t *e1, uint8_t perm[24], uint32_t aut[12])
{
    int32_t res;
    uint_fast32_t i;
    uint64_t data[MAXROWS_ELEM], x;
    qstate12_type qs;
    
    data[0] = 0;
    for (i = 0; i < 12; ++i) data[i+1] = aut[i];
    res = qstate12_set_mem(&qs, data, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_monomial_column_matrix(&qs, 12, data);
    if (res < 0) return res;
    res = xp2co1_conv_conjugate_basis(&qs);
    if (res < 0) return res;
    
    x = (ONE << perm[2]) + (ONE << (perm[3] + 24));
    return xp2co1_qs_to_elem(&qs, x, e1);
}




// %%EXPORT px
int32_t xp2co1_elem_delta_pi(uint64_t *e1, uint32_t delta, uint32_t pi)
{
    uint8_t perm[24];
    uint32_t aut[12];
    
    mat24_m24num_to_perm(pi, perm);
    mat24_perm_to_autpl(delta, perm, aut);
    return elem_delta_pi_aut(e1, perm, aut);
}








static uint32_t MAPY_STD_V3[4] = {
   0x8000004UL, 0x4000008UL, 0xC, 0xC000000UL
};

// %%EXPORT px
int32_t xp2co1_elem_y(uint64_t *e1, uint32_t y)
{

    int32_t res, i;
    uint64_t d, s, data[MAXROWS_ELEM], assoc, theta_y, theta_d, v;
    qstate12_type qs;

    theta_y = MAT24_THETA_TABLE[y & 0x7ff] & 0x7ff;
    data[0] = y & 0x17ff;
    for (i = 0; i < 11; ++i) {
        d = ONE << i;
        theta_d = MAT24_THETA_TABLE[d & 0x7ff];
        s =  theta_d & y;
        s ^= s >> 6; s ^= s >> 3; 
        s = (0x96 >> (s & 7)) & 1;
        assoc = MAT24_THETA_TABLE[(d ^ y) & 0x7ff] ^ theta_d ^ theta_y;
        data[i+1] = d + (s << 12) + ((assoc & 0x7ff) << 13);
    } 
    data[12] = data[0] + 0x800 + (theta_y << 13);       
    res = qstate12_set_mem(&qs, data, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_monomial_column_matrix(&qs, 12, data);
    if (res < 0) return res;

    v = ((y >> 8) ^ (y >> 10) ^ (y >> 11)) & 1;
    v ^= (y >> 8) & 2;
    return xp2co1_qs_to_elem(&qs, (uint64_t)MAPY_STD_V3[v], e1);
}




// The following table has been generated by function display_py_xi()
// in the python module  mmgroup.dev.clifford12.xs1_co1. The output 
// of that function has been copied to this place manually.
// This causes less overhead than using the code generator here.

static uint64_t elem_xi[2][12] = {
{
// Entries [0, 1, 2, 3, 10, 11, 12, 13, 14, 15, 16, 17] of element xi**1
0x000004000008ULL, 0x000000000400ULL, 0x000000800400ULL, 0x000000400c00ULL,
0x01dc00008000ULL, 0x01ba00004000ULL, 0x017600002000ULL, 0x00ee00001000ULL,
0x001c00000008ULL, 0x001a00000004ULL, 0x001600000002ULL, 0x000e00000001ULL
},
{
// Entries [0, 1, 2, 3, 10, 11, 12, 13, 14, 15, 16, 17] of element xi**2
0x000004000008ULL, 0x000000000800ULL, 0x000000800c00ULL, 0x000000400800ULL,
0x01c000008000ULL, 0x01a000004000ULL, 0x016000002000ULL, 0x00e000001000ULL,
0x01dc00000008ULL, 0x01ba00000004ULL, 0x017600000002ULL, 0x00ee00000001ULL
}
};

// %%EXPORT px
void xp2co1_elem_xi(uint64_t *e, uint32_t exp)
{
    uint_fast32_t i;
    uint64_t *p_xi;
    // Before we have generated the array ``elem_xi`` manually
    // we cannot return anythin greasonable here.
    // return ERR_GX1_TAG;
    xp2co1_unit_elem(e);
    exp %= 3;
    if (exp == 0) return;
    p_xi = elem_xi[exp - 1];
    for (i = 0; i < 4; ++i) e[i] = p_xi[i];
    for (i = 4; i < 12; ++i) e[i + 6] = p_xi[i];
}



// %%EXPORT px
int32_t xp2co1_mul_elem_atom(uint64_t *e, uint32_t v, uint32_t set_one)
// Multiply the element ``e`` of the group ``g_{{x1}}`` with the atom
// given by ``v``. Atom ``v`` is interpreted as follows:
// Bit 31:      sign of exponent
// Bit 30..28   tag
// Bit 27..0    operarand
// Tag are as follows:
//
//                bit
// Tag  word     length   operand
//  0:  1         -       unit of the group, no operand
//  1:  x_delta   12      delta in C* in 'cocode' rep
//  2:  x_pi      28      pi a permutation number  
//  3:  x_d       13      d an element of the parker loop
//  4:  y_d       13      d an element of the parker loop
//  5:  t**e      28      exponent e
//  6:  xi**e     28      exponent e
//  7   illegal                  
// 
// 
// If ``set_one`` is not zero then ``g`` is set to ``1`` before
// multiplication with atom ``v``.
{
    uint_fast32_t tag, x = 0;
    uint64_t atom[26], *p_atom = atom;
    uint8_t perm[24], perm_i[24];
    uint32_t aut[12], aut_i[12];
    int32_t res;

    if (set_one)  xp2co1_unit_elem(p_atom = e);
    tag = v >> 28;
    v &= 0xfffffff;
    switch(tag) {
        case 8:
        case 0:
           return 0;
        case 8 + 1:
        case 1:
           return elem_op_xspecial(e, v & 0xfff);
        case 8 + 2:
           mat24_m24num_to_perm(v, perm);
           mat24_perm_to_autpl(0, perm, aut);
           mat24_inv_perm(perm, perm_i);
           mat24_inv_autpl(aut, aut_i);
           res = elem_delta_pi_aut(p_atom, perm_i, aut_i);
           if (res < 0) return res;
           break;
        case 2:
           mat24_m24num_to_perm(v, perm);
           mat24_perm_to_autpl(0, perm, aut);
           res = elem_delta_pi_aut(p_atom, perm, aut);
           if (res < 0) return res;
           break;
        case 8 + 3:
           x ^= (MAT24_THETA_TABLE[v & 0x7ff] & 0x1000) << 12;
        case 3:
           x ^=  ((v & 0x1fffUL) << 12);
           x ^=  MAT24_THETA_TABLE[v & 0x7ff] & 0xfff;
           return elem_op_xspecial(e, x);
        case 8 + 4:
           x ^= (MAT24_THETA_TABLE[v & 0x7ff] & 0x1000);
        case 4:
           x ^= v & 0x1fffUL;
           res = xp2co1_elem_y(p_atom, x);
           if (res < 0) return res;
           break;
        case 8 + 5:
        case 5:
           if (v % 3 == 0) return 0;
        default:
           return ERR_GX1_TAG;
        case 8 + 6:
           v ^= 0xfffffff;
        case 6:
           v %= 3;
           if (v == 0) return 0;
           xp2co1_elem_xi(p_atom, v);
           break;
    }
    return set_one ? 0 :  xp2co1_mul_elem(e, atom, e);
}





/*************************************************************************
*** Converting a an element to a vector of the monster rep modulo 3
*************************************************************************/



static inline
uint64_t xp2co1_to_vect_mod3(uint64_t x)
{
    uint64_t y;
    x = short_3_reduce(x);
    x = (x & 0xffffffULL) + ((x & 0xffffff000000ULL) << 8);
    SHIFT_MASKED(x, y, 0x00000000FFFF0000ULL, 16);
    SHIFT_MASKED(x, y, 0x0000FF000000FF00ULL, 8);
    SHIFT_MASKED(x, y, 0x00F000F000F000F0ULL, 4);
    SHIFT_MASKED(x, y, 0x0C0C0C0C0C0C0C0CULL, 2);
    SHIFT_MASKED(x, y, 0x2222222222222222ULL, 1);
    return x;
}

// %%EXPORT px
int32_t xp2co1_elem_row_mod3(uint64_t *e1, uint32_t column, uint64_t *v)
{
    int32_t res, sign;
    qstate12_type qs1, qs2;
    uint64_t data2[MAXROWS_ELEM], x;
 
    uint64_t n_iterations, i;
    uint64_t assoc; 
    uint64_t *m, x_data[2];
    uint64_t qf = 0;
    uint64_t ncols, mask; 

    res = xp2co1_elem_to_qs(e1, &qs1);
    if (res < 0) return res;
    res = qstate12_copy_alloc(&qs1, &qs2, data2, MAXROWS_ELEM);
    if (res < 0) return res;
    res = qstate12_gate_not(&qs2, column & 0xfff);
    if (res < 0) return res;
    res = qstate12_restrict(&qs2, 0, 12);
    if (res < 0) return res;
    res = qstate12_reduce(&qs2);
    if (res < 0) return res;
    if (qs2.factor & 0x13) return ERR_REP_GX1;
    sign = ((qs2.factor >> 5) ^ (qs2.factor >> 2)) & 1;
    x = e1[0];
    if (sign) x ^= 0xffffffffffffULL;
    x_data[0] = xp2co1_to_vect_mod3(x);
    x_data[1] = xp2co1_to_vect_mod3(x ^ 0xffffffffffffULL);

    n_iterations = ONE << (qs2.nrows - 1);
    m = qs2.data;
    assoc = m[0]; 
    ncols = qs2.ncols; 
    mask = (ONE << ncols) - 1;
    for (i = 0; i < ONE << ncols; ++i) v[i] = 0;

    for (i = 1; i <= n_iterations; ++i) {
        uint64_t i1, d, d1, index;
        index = assoc & mask;
        v[index] = x_data[qf & 1];
        d1 = d = qstate12_lsbtab[(i1 = i) & 63];
        while (d1 == 6) {
            i1 >>= 6;
            d1 = qstate12_lsbtab[i1 & 63];
            d += d1;
        } 
        qf += assoc >> (ncols + d + 1);
        assoc ^= m[d+1];
    } 
    return 0;   
}




/*************************************************************************
*** Converting a short vector modulo 3 to a Leech lattice vector
*************************************************************************/




static
int32_t xp2co1_add_short_3_leech(uint64_t x, int32_t factor, int8_t *psrc, int8_t *pdest)
// Given a short Leech lattice vector ``x`` (modulo 3), and short 
// Leech latice vectors ``src`` and ``dest``, referred by ``psrc`` and 
// ``pdest``, the function computes  ``dest = src + factor * x``.
// Here ``src`` and ``dest`` are given in the standard basis, so that
// a unit vector of length ``sqrt(8)`` has one entry with absolute
// value ``8``.
{
    uint_fast32_t  gcodev, cocodev, w1, w2;
    int_fast8_t f[4], i;
    f[0] = f[3] = 0;
    x = short_3_reduce(x);
    w1 = mat24_bw24((uint32_t)x); 
    w2 = mat24_bw24((uint32_t)(x >> 24));
    switch (w1 + w2) {
        case 23:
            cocodev = ~(uint32_t)(x | (x >> 24)) & 0xffffffUL;
            if ((cocodev == 0) || (cocodev & (cocodev - 1))) 
                return ERR_LEECH_OP;
            f[0] = (int8_t)factor * ((w1 & 1) ? -3 : 3); 
            f[1] = (int8_t)factor;
            gcodev = (uint32_t)(x >> ((0-(w1 & 1)) & 24)) & 0xffffffUL;
            break;              
        case 8:
            if (w1 & 1) return ERR_LEECH_OP;
            gcodev = (x | (x >> 24)) & 0xffffffUL;
            f[1] = -2 * (int8_t)factor;
            break;
        case 2:
            gcodev = 0;
            f[1] = 4 * (int8_t)factor;
            break;
        default:
            return ERR_LEECH_OP;        
    }
    f[2] = -f[1];
    gcodev = mat24_vect_to_gcode(gcodev);
    if (gcodev & 0xfffff000UL) return ERR_LEECH_OP;
    x = xp2co1_to_vect_mod3(x);

    for (i = 0; i < 24; ++i) {
        pdest[i] =  psrc[i] + f[(x >> (i << 1)) & 3];
    }
    return 0;
}



// %%EXPORT px
int32_t xp2co1_elem_to_leech_op(uint64_t *elem, int8_t *pdest)
// Given an element ``elem`` of the group ``G_{{x_1}}``, the 
// function computes a ``24 times 24`` matrix ``L`` in the
// array ``dest`` referred by ``pdest``. The entry ``8 * L[i,j]``
// is stored in ``dest[24*i+j]``. Matrix ``L`` is unique up to 
// sign. The sign is undocumented, but computed deteministically. 
// Function ``xp2co1_elem_to_qs(elem,...)``  computes a``
// ``4096 times 4096`` matrix ``M`` for the element ``elem``
// as an object of type ``qstate12_type``.  The Kronecker
// product of ``L`` and ``M`` represents the element ``elem``
// of the group ``G_{{x_1}}`` uniquely. Let ``M.T`` be the
// transposed matrix of ``M``. Matrices ``L`` and `M.T`` act 
// on the tensor product ``24_x (x) 4096_x``, which is a  
// representation of ``G_{{x_1}}``, by right multiplication.
{
    uint64_t src3[25], dest3[25];
    int_fast32_t res, i;
    qstate12_type qs;
    
    // We let ``elem`` act on a sequence of short vectors
    // ``4*e_{{i}} -  4*e_{{i+1}}``, with ``e_i`` the ``i-``th
    // unit vector of the Leech lattice, and indices 
    // ``i = 2,...,25 `` taken modulo ``24``. We append the
    // unit vector ``4*e_{{2}} +  4*e_{{3}}`` to that sequence.
    // Adjacent vectors have nonzero scalar product modulo ``3``,
    // so we may use function ``xp2co1_chain_short_3`` to compute
    // the images of the vectors in that sequence under the group
    // element ``elem``. Form these images we may compute the
    // images of the unit vectors ``8 * e_i``, which form the
    // matrix ``8 * L``.

    for (i = 0; i <= 20; ++i) src3[i] = STD_V3 << i;
    src3[21] =  0x1800000ULL;
    src3[22] =  STD_V3 >> 2;
    src3[23] =  STD_V3 >> 1;
    src3[24] =  0xc;
    dest3[0] =  elem[0];

    res =  xp2co1_elem_to_qs(elem, &qs);
    if (res < 0) return res;
    res = xp2co1_chain_short_3(&qs, 25, src3, dest3);
    if (res < 0) return res;

    memset(pdest + 2*24, 0, 24);
    res = xp2co1_add_short_3_leech(dest3[24], 1, pdest + 2*24, pdest + 2*24);
    memcpy(pdest + 3*24, pdest + 2*24, 24);
    res |= xp2co1_add_short_3_leech(dest3[0], 1, pdest + 2*24, pdest + 2*24);
    res |= xp2co1_add_short_3_leech(dest3[0], -1, pdest + 3*24, pdest + 3*24);
    res |= xp2co1_add_short_3_leech(dest3[23], 2, pdest + 2*24, pdest + 1*24);
    res |= xp2co1_add_short_3_leech(dest3[22], 2, pdest + 1*24, pdest + 0*24);
    res |= xp2co1_add_short_3_leech(dest3[21], 2, pdest + 0*24, 
              pdest + 23*24);
    for (i = 20; i >= 2; --i) {
       res |= xp2co1_add_short_3_leech(dest3[i], 2, pdest + (i+3)*24, 
           pdest + (i+2)*24);
    }
    return res;
}



/*************************************************************************
*** Type of a Leech vector
*************************************************************************/

// %%EXPORT px
uint32_t xp2co1_leech_type(uint64_t x)
// Return ``0x10 * type(x) + subtype(x)`` for a vector ``x``
// in the Leech lattice modulo ``2``.
// The type of a vector is half the length of the shortest 
// representative of a vector in the Leech lattice.
// The subtype decsribes the double coset of the vector in
// in ``N_x \ Co_1 / N_x``, where ``Co``_1 is the automorphism 
// group of the Leech lattice modulo ``2``, and ``N_x`` is the 
// automorphism group of a vector ``(2,...,2)`` in the standard 
// basis of the Leech lattice modulo ``N_x`` has structure 
// ``2^11. Mat_24``, with ``Mat_24`` the Mathieu group operating
// on 24 elements.
//
// In :cite`:`Con85` a vector in th Leech lattice is
// denotes by ``x_d * x_delta``, where ``d`` is an element of
// the Golay code and ``delta`` is an eöment of it cocode. 
// Subtypes can be described as follows:
//
// 0: The set contains an element with ``delta = 0``
// 1: ``delta`` has weight ``1`` for all elements in the set.
// 2: ``d`` or its complement is an octad and ``delta`` is
//     even and contained in that octad.
// 3: ``delta`` has weight ``1`` for all elements in the set.  
// 4: ``d`` or its complement is an octad and ``delta`` is
//     even and not contained in that octad.
// 6: ``d`` has weight 12
// 8: The singleton containing ``(2,...,2)`` 
//
// Valid combinations of type and subtype (hex) are
//
// 00,   20, 21, 22,   31, 33, 34, 36,  
// 40, 42, 43, 44, 46, 48.
{
    static uint8_t tab_odd[4] = {
        0x21, 0x31, 0x43, 0x33
    };
    static uint8_t tab_even_scalar1[7] = {
        0xff, 0xff, 0x34, 0x36, 0x34, 0xff, 0xff
    };
    uint_fast32_t  x1, gcodev, cocodev, theta, w, cw,scalar, lsb;
    x1 = (uint_fast32_t)x;
    theta = MAT24_THETA_TABLE[(x1 >> 12) & 0x7ff]; 
    // put cw = min weight of cocode word
    cw = mat24_cocode_weight(x1 ^ theta);
    // Put scalar = scalar product (code, cocode)
    scalar = (x1 >> 12) &  x1 & 0xfff;
    scalar ^= scalar >> 6;
    scalar ^= scalar >> 3;
    scalar = (0x96 >> (scalar & 7)) & 1;
    
    // Deal with odd cocode first
    if (x1 & 0x800) return tab_odd[cw-1+scalar]; 
    
    // Put w = weight(code word gcodev) / 4
    w = 0 - ((x1 >> 23) & 1);
    w = (((theta >> 12) & 7) ^ w) + (w & 7);  

    // Deal with even cocode and scalar == 1
    if (scalar) return tab_even_scalar1[w];
   
    switch (w) {
        case 6:
            if (cw == 0) return 0x48;
        case 0: 
            return cw << 4;
        case 3:
            return 0x46;
        case 4:
            // Add 1....1 to bit vector x (in vector rep)
            x1 ^= 0x800000; 
        default:   // This must be case 2:
            // Put gcodev = codeword (in vector rep)
            gcodev = mat24_gcode_to_vect(x1 >> 12); 
            // Put coccodev = cocode word (in vector rep), such that
            // the cocode word is a suboctad of gcodev if possible
            lsb = mat24_lsbit24(gcodev);
            cocodev = mat24_cocode_syndrome(x1 ^ theta, lsb); 
            // Put cw = 0x22 if (w ^ cw) & 2 is 2, else put cw = 0x42
            cw = 0x42 - (((w ^ cw) & 2) << 4);
            // Return cw if cocodev is a suboctad of gcodev
            if ((gcodev & cocodev) == cocodev) return cw;
            // Otherwise vector is of type 4
            return 0x44;          
    }
}

// %%GEN ch
#ifdef __cplusplus
}
#endif




