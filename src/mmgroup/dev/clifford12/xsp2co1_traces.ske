/** @file xsp2co1_traces.c
  File ``xsp2co1_traces.c`` contains functions for computing
  characters of some representations of the subgroup \f$G_{x0}\f$
  (of structure \f$2^{1+24}.\mbox{Co}_1\f$) of the monster.

  Such computations can be very expensive, especially for some
  classes of involutions, or for elements that map to involutions
  in the factor group \f$\mbox{Co}_1\f$ of \f$G_{x0}\f$.

  This file contains a function ``xsp2co1_elem_involution_class``
  for the classification of elements that map to involutions
  in \f$\mbox{Co}_1\f$.

  Function ``xsp2co1_traces_fast`` uses a precomputed table for
  computing the characters of elements of \f$G_{x0}\f$. That
  table is addressed by the class information computed by
  function ``xsp2co1_elem_involution_class``. The functions in
  module ``mmgroup\tests\test_involutions.make_involution_samples.py``
  precompute that table. We simply copy and paste the table
  from the output of that python function to to this file.
  
  The precomputation of the table requires the
  function ``xsp2co1_traces_all`` in file ``xsp2co1_elem.c``. That
  function computes the same characters as
  function ``xsp2co1_traces_fast`` without using precomputed tables. 

  Function ``xsp2co1_traces_fast`` does not use a precomputed table,
  but the verification of this function requires inspection of the
  output of the module ``make_involution_samples.py`` mentioned
  above.
*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#define CLIFFORD12_INTERN
#include "clifford12.h"
/// @endcond  


// %%EXPORT_KWD CLIFFORD12_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c




/*************************************************************************
*** Compute traces of an element of G_x0
*************************************************************************/


/** 
  Compute class information for certain elements of \f$G_{x0}\f$ 

  Let \f$g \in G_{x0}\f$ be stored in the array ``elem``
  in **G_x0 representation**. If \f$g\f$ maps to an involution
  in the factor group \f$\mbox{Co}_1\f$ of \f$G_{x0}\f$ then
  the function returns a nonzero value indicating some class
  information about \f$g\f$. Otherwise the function returns 0.

  The class information in the return value is to interpreted as follows:

        bits  7 .. 0: class of element  g  in the Monster group, e.g
                      0x21 means class 2A,
                      0x41 means class 2A, 0x42 means class 4B, etc.

        bits 11 .. 8: Class of element  g  in the factor group Co_1
                      0 means class 1A in Co_1
                      1 means class 2A in Co_1
                      2 means class 2B in Co_1
                      3 means class 2C in Co_1

        bit 12:       0 if  g  and  -g  are in the same class in the Monster
                      1 otherwise

        bit 13:       1 if q g  is equal to or powers up to -1
                      0 otherwise

  All other bits in the return value are set to zero.

  Here \f$-1\f$ is the central involution \f$x_{-1}\f$ in \f$G_{x0}\f$,
  and \f$-g = x_{-1} \cdot g\f$ .

  Write \f$h(g)\f$ as an abbreviation for the result of this function
  applied to an element \f$g\f$ of \f$G_{x0}\f$. Then the following
  assertions have been checked computationally in
  files ``make_involution_samples.py``, or ``test_xp2_traces.py``,
  or can easily be checked mathematically.

  Possible values \f$h(g)\f$ (depending on the class of \f$g Q_{x0}\f$)
  in \f$\mbox{Co}_1\f$ are:

       class 1A: 0x1011, 0x3022, 0x0022, 0x0021, 0x2041
       class 2A: 0x1121, 0x1122, 0x0143, 0x2143, 0x0142, 0x0141, 0x0122
       class 2B: 0x0244, 0x2244
       class 2C: 0x0322, 0x0341, 0x0344, 0x2382, 0x0343, 0x0342
 
  The value \f$h(g)\f$ determines the characters of the
  representations \f$98280_x, 299_x, 24_x, 4096_x\f$ of \f$g\f$
  uniquely, where by construction of \f$G_{x0}\f$ the last two
  characters are determined up to sign only.

  The class of an involution \f$g\f$ is determined uniquely
  by \f$h(g)\f$.
*/
// %%EXPORT px
int32_t xsp2co1_elem_involution_class(uint64_t *elem)
{
    uint64_t invar[12];   
    int_fast32_t v, t, inv0,  n, n2;
    int32_t traces[4];
    static uint16_t v_types[] = {0x22, 0, 0x21, 0x2041};

    // Compute involution invariants; abort if this fails.
    // Let \f$A, A_1, I_1, (I_1^+)\f$, and \f$(\ker A_1^+)\f$ 
    // be as in  function ``xsp2co1_involution_invariants``.
    n = xsp2co1_involution_invariants(elem, invar);
    if (n < 0) return 0;

    switch (n) {
        case 0:
            // Co_1 class 1A: v = +- 1
            return xsp2co1_is_unit_elem(elem) ? 0x1011 : 0x3022;
        case 1:
            // Co_1 class 1A: v in Q_x0, v != +-1
            if ((v = xsp2co1_xspecial_vector(elem)) < 0) return 0;
            return v_types[gen_leech2_type(v) & 3];
        case 8:
            // Co_1 class 2A, element not fused with its negative
            if (xsp2co1_traces_small(elem, traces) < 0) return 0;
            return traces[2] > 0 ? 0x1121 : 0x1122;
        case 9:
            // Co_1 class 2A, element fused with its negative
            t =  (invar[1] >> 24) & 1;
            n2 = xsp2co1_leech2_count_type2(invar, 9);
            switch(n2) {
                case 0:
                    return t ? 0x143 : 0x2143;
                case 2:
                    return 0x142;
                case 16:
                    return t ? 0x141 : 0x122;
                default:
                    return 0;
            } 
        case 12:
            inv0 =  (invar[0] >> 24) & 3;
            t =  (invar[1] >> 24) & 1;
            if (inv0 & 2) {
                // Co_1 class 2C
                if (t) {
                    invar[1] = 0;
                    n2 = xsp2co1_leech2_count_type2(invar + 1, 11);
                    switch (n2) {
                        case 120:
                            return 0x344;
                        case 132:
                            return 0x2382;
                        case 136:
                            return 0x343;
                        case 152:
                            return 0x342;
                        default:
                            return 0;
                    }
                } else {
                    return (inv0 & 1) ?  0x322 : 0x341;
                }
            } else {
                // Co_1 class 2B
                return (inv0 & 1) ? 0x244 : 0x2244;
            }
        default:            
            return 0;
    }
}




/*************************************************************************
*** Fast table-based function for computing trace of rep 08280_x
*************************************************************************/


/// @cond DO_NOT_DOCUMENT 


// The following tables have been created automatically
// by executing file ``test_display_characters.py``
// in module ``mmgroup.tests.test_involutions``.

// Table f0r character chi_98280
#define LEN_I_CHI_98280_TABLE 20
static uint16_t KEYS_I_CHI_98280_TABLE[20] = {
 0x21, 0x22, 0x122, 0x141, 0x142, 0x143, 0x244, 0x322, 
 0x341, 0x342, 0x343, 0x344, 0x1011, 0x1121, 0x1122, 0x2041, 
 0x2143, 0x2244, 0x2382, 0x3022
};
static int32_t DATA_I_CHI_98280_TABLE[20] = {
 4072, -24, 232, 232, 8, -24, 0, 264, 
 264, 40, 8, -24, 98280, 2280, 2280, -24, 
 -24, 0, 0, 98280
};



static inline int32_t trace_98280_fast(uint64_t *elem)
// Yet to be documented!!!
{
    int32_t i, cl = xsp2co1_elem_involution_class(elem);
    if (cl > 0) {
        for (i = 0; i < LEN_I_CHI_98280_TABLE; ++i) {
            if (cl == (int32_t)KEYS_I_CHI_98280_TABLE[i]) {
                return  DATA_I_CHI_98280_TABLE[i];
            }
        }
    }
    return -0x2000000;
}


/// @endcond 




/**
  @brief Compute relevant characters of element of \f$G_{x0}\f$

  Let \f$g \in G_{x0}\f$ be stored in the array ``elem``
  in **G_x0 representation**. The function computes the
  characters of the representations
  \f$\rho_{24}, \rho_{576}, \rho_{4096}, \rho_{98280}\f$
  and stores the result in ``ptrace[0],..., ptrace[3]`` in
  that order. Here  \f$\rho_{576}\f$ is the tensor square of
  \f$\rho_{24}\f$.

  This function returns 0 in case of success and a nonzero value
  otherwise.
 
  Note that the tensor product \f$\rho_{24} \otimes \rho_{4096}\f$
  is well defined, but the factors of that product are defined
  up to sign only.
  We normalize the characters corresponding to \f$\rho_{24}\f$
  and \f$\rho_{4096}\f$ so that the first nonzero value of these
  two characters (in the order given above) is positive.
*/
// %%EXPORT px
int32_t xsp2co1_traces_fast(uint64_t *elem, int32_t *ptrace)
{
    int32_t res;
    res = xsp2co1_traces_small(elem, ptrace);
    if (res < 0) return res;
    res = xsp2co1_trace_98280(elem, trace_98280_fast); 
    if (res < -0x1000000) return res;
    ptrace[3] = res;
    return 0;    
}




//  %%GEN h
/// @endcond 
//  %%GEN c


// %%GEN ch
#ifdef __cplusplus
}
#endif
