// %%COMMENT
// For this module we refer to the section
// 'Computation in the Clifford group' in the guide, see
// https://mmgroup.readthedocs.io/en/latest/

// %%COMMENT
// Negative return values of functions in this module are error codes:
// -1: No bit with the requested propertyfound 
//     (This is usually handled internally by the calling procedure)
// -2: State is inconsistent
// -3: Qubit index error
// -4: State is too large for this module
// -5: Internal buffer overflow (Usually now enough rows available)
// -6: Bit matrix part Q is not symmetric
// -7: Bad row index for bit matrix 
// -8: Internal parameter error (Usually a bad row is requested)
// -99: Any other fatal error



/*************************************************************************
** External references 
*************************************************************************/

#include <string.h>
#define CLIFFORD12_INTERN
#include "clifford12.h"

// %%EXPORT_KWD CLIFFORD12_API

// %%GEN h


#define QSTATE12_MAXCOLS     (64)
#define QSTATE12_MAXROWS     (QSTATE12_MAXCOLS+1)


typedef struct {
    uint32_t maxrows;
    uint32_t nrows;
    uint32_t ncols;
    int32_t  factor;
    uint64_t *data;
} qstate12_type;



/*************************************************************************
*** Macros
*************************************************************************/
 
 
#ifdef CLIFFORD12_INTERN
      
// Max No of columns supporte in an object of type 
// qstate12_type. Here each column stores a bit.
#define MAXCOLS QSTATE12_MAXCOLS
  
// Max No of rows required in an object of type qstate12_type
// when  MAXCOLS bolumns are present.
#define MAXROWS QSTATE12_MAXROWS

// Use this for the number 1 as an uint64_t
#define ONE ((uint64_t)0x1ULL)


// Use this for the an uint64_t where all bits are set
#define ALL_SET ((uint64_t)0xffffffffffffffffULL)


// Mask for valid bits of factor
#define FACTOR_MASK (ALL_SET & ~8ULL)

// Adding factors
#define ADD_FACTORS(e1, e2) ((((e1) & FACTOR_MASK) + (e2)) & FACTOR_MASK)




// Check the object of type qstate12_type referred by pqs.
// Return True if that object is errorneous.
#define bad_state(pqs) \
    ((pqs)->nrows + (pqs)->ncols > MAXCOLS  \
      || (pqs)->nrows  > (pqs)->maxrows)

// Return True if i is an illegal row index for the object
// of type qstate12_type referred by pqs.
#define bad_row(pqs, i) ((i) >= (pqs)->nrows) 

// Return True if j is an illegal column index for the object
// of type qstate12_type referred by pqs.
#define bad_col(pqs, j) ((j) >= MAXCOLS) 

   
// Generate C code to check that the result of qstate12_prep_mul()
// if CHECK_qstate12_PREP_MUL is #defined. 
#define CHECK_qstate12_PREP_MUL

// The 'bad' maximum and minimum functions in C, use them with care!!
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b)) 

#endif // #ifdef CLIFFORD12_INTERN




// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



/*************************************************************************
*** Checking a state for consistency
*************************************************************************/



// %%EXPORT p
int32_t qstate12_check(qstate12_type *pqs) 
// Return 0 if ok, or an error code if there is any error in the matrix 
// data.  Q[i,0] is set to Q[0, i].  Q[0,0] is set ot 0.
// Irrelevant data bits in valid rows are zeroed. 
{
    uint_fast32_t i, j, c, err=0;
    uint64_t *m = pqs->data;
    uint64_t mask;
    if (bad_state(pqs)) return -2;
    pqs->factor &= FACTOR_MASK;
    if (pqs->nrows == 0) pqs->factor = 0;
    c = pqs->ncols;
    mask = ((ONE << c) << pqs->nrows) - 1;
    mask &= ~(ONE << c);
    m[0] &= mask;
    for (i = 1; i < pqs->nrows; ++i) {
        m[i] &= mask;
        m[i] |= (m[0] >> i) & (ONE << c);
        for (j = 0; j < i; ++j) {
            err |= (m[i] >> (c + j)) ^ (m[j] >> (c + i));   
        }
    }
    for (i = pqs->nrows; i < pqs->maxrows; ++i) m[i] = 0;
    return (err & 1) ? -6 : 0;    
} 

/*************************************************************************
*** Construction of a state
*************************************************************************/


// %%EXPORT p
int32_t qstate12_set_mem(qstate12_type *pqs, uint64_t *data, uint32_t size)
// Assign array 'data' of 'size' integers of type uint64_t[] as memory
// to the state vector *pqs. We recommend size = CLIFFORD12_MAXROWS.
{
    pqs->data = data;
    pqs->maxrows = size;
    pqs->nrows = 0;
    pqs->ncols = 0;
    pqs->factor = 0;
    return 0;
}






// %%EXPORT p
int32_t qstate12_zero(qstate12_type *pqs, uint32_t nqb) 
// Set state *pqs to zero, for nqb qubits.
{  
    pqs->nrows = 0;
    pqs->factor = 0;
    pqs->ncols = nqb;
    if (nqb <=  MAXCOLS) return 0;
    pqs->ncols = 0;
    return -4;
}






// %%EXPORT p
int32_t qstate12_vector_state(qstate12_type *pqs, uint32_t nqb, uint64_t v)
// Set state *pqs to the unit vector |v>,  for nqb qubits.
// Thus for the state qs referred by pqs we have qs(x) = 1 if x is 
// equal to v and qs(x) = 0 otherwise. 
{
    pqs->nrows = 1;
    pqs->ncols = nqb;
    pqs->factor = 0;
    pqs->data[0] = v & ((ONE << nqb) - 1);
    if (nqb + 1 <=  MAXCOLS) return 0;
    pqs->ncols = pqs->nrows = 0;
    return -4;
}


// %%EXPORT p
int32_t qstate12_set(qstate12_type *pqs, uint32_t nqb, uint32_t nrows, uint64_t *data, uint32_t mode)
// Set state *pqs as given by ``data`` for ``nqb`` qubits. Here
// the array ``data`` is a bit matrix with ``nrows`` rows.
// If ``mode == 1`` the lower triangular part ``Q`` of the
// data matrix is taken.
// If ``mode == 2`` the upper triangular part ``Q`` of the
// data matrix is taken.
// Otherwise the part ``Q`` of the data matrix must be symmetric.
{
    uint_fast32_t i, j;
    uint64_t *m = pqs->data, mask;
    
    if (nqb + nrows > MAXCOLS || nrows > pqs->maxrows) return -4;
    pqs->nrows = nrows;
    pqs->ncols = nqb;
    pqs->factor = 0;
    mask = ((ONE << nqb) << nrows) - 1;
    for (i = 0; i < nrows; ++i) m[i] = data[i] & mask;
    mask = ONE << nqb;
    if (mode == 1) {
        for (i = 0; i < nrows; ++i) {
            m[i] &= (mask << (i + 1)) - 1;
            for (j = i+1; j < nrows; ++j) 
                m[i] ^= ((m[j] >> i) & mask) << j;
        }
        return 0;
    }
    if (mode == 2) {
        for (i = 0; i < nrows; ++i) {
            m[i] &= -(mask << (i + 1));
            for (j = 0; j < i; ++j) 
                m[i] ^= ((m[j] >> i) & mask) << j;
        }
        return 0;
    }    
    return qstate12_check(pqs);
}


// %%EXPORT p
int32_t qstate12_copy(qstate12_type *pqs1, qstate12_type *pqs2) 
// Copy the state referred by pqs1 to the state referred by pqs2. 
{
    if (bad_state(pqs1)) return -2;
    if (pqs2->maxrows < pqs1->nrows) return -5;
    pqs2->nrows = pqs1->nrows;
    pqs2->factor = pqs1->factor;
    pqs2->ncols = pqs1->ncols;
    memcpy(pqs2->data, pqs1->data, pqs1->nrows * sizeof(uint64_t));
    return 0;
}








/*************************************************************************
*** Elementary operations on a state
*************************************************************************/

// %%EXPORT p
int32_t qstate12_conjugate(qstate12_type *pqs)
// Conjugate the state referred by pqs;
{
    uint_fast32_t k;
    uint64_t *m = pqs->data, c = ONE << pqs->ncols;
    if (bad_state(pqs)) return -2;
    for (k = 1; k < pqs->nrows; ++k)  m[0] ^=  m[k] & (c << k);
    pqs->factor = (((pqs->factor & FACTOR_MASK) ^ 7) + 1) & FACTOR_MASK;
    return 0;
}


// %%EXPORT p
int32_t qstate12_mul_scalar(qstate12_type *pqs, int32_t e, uint32_t phi)
// Muliply the state referred by pqs by 
// 2**(e/2) * exp(phi * pi * sqrt(-1) / 4);
{
    if (bad_state(pqs)) return -2;
    pqs->factor = ADD_FACTORS(pqs->factor, (e << 4) + (phi & 7));
    return 0;
}

/*************************************************************************
*** Checking equality of two states state
*************************************************************************/

// %%EXPORT p
int32_t qstate12_equal(qstate12_type *pqs1, qstate12_type *pqs2) 
// Return 1 if the states referred by pqs1 and pqs2 are equal,
// 0 if not, and -1 if any of these two states is erroneous.
// Both states are reduced before comparing them.
// Caution!
// We just check equality of data. States are not reduced to a
// unique form!
{
    uint64_t mask, diff = 0, *m1 = pqs1->data, *m2 = pqs2->data;
    uint_fast32_t i;
    if (bad_state(pqs1) || bad_state(pqs2)) return -2;
    if (pqs1->ncols != pqs2->ncols) return 0;
    if ((pqs1->nrows | pqs2->nrows) == 0) return 1;
    if (((pqs1->factor ^ pqs2->factor) & FACTOR_MASK) |
        (pqs1->nrows ^ pqs2->nrows)) return 0;
    mask = (((ONE << pqs1->nrows) - 1) << pqs1->ncols) - 1;
    for (i = 0; i < pqs1->nrows; ++i) diff |= (m1[i] ^ m2[i]) & mask;
    return (int32_t)(!diff);
}


/*************************************************************************
*** Low-level functions
*************************************************************************/


// %%EXPORT p
int32_t qstate12_get_col(qstate12_type *pqs, uint32_t j, uint32_t len, uint64_t *pa)
// read column j from matrix A or Q of the state referred by
// pqs upto and inlcuding line ``len``, write the result to *pa.
{
    uint_fast32_t i;
    uint64_t *m = pqs->data, a;
    a = 0;
    if (len >= pqs->nrows) len = pqs->nrows - 1;
    for (i = 0; i <= len; ++i) a |= ((m[i] >> j) & ONE) << i;
    *pa = a;
    return 0;
}


// Deprecated!!!
int32_t qstate12_get_cols(qstate12_type *pqs, uint32_t c0, uint32_t len, uint32_t *pa)
// Extract columns c0,...,c0 + len - 1 from matrix (A,Q)
// This is a workaround for a compiler problem with Cython 
{
    uint_fast32_t i;
    uint64_t *m = pqs->data, mask = (ONE << len) - 1;
    for (i = 0; i < pqs->nrows; ++i) {
        pa[i] = (uint32_t)((m[i] >> c0) & mask);
    }
    return 0;
}


// Deprecated!!!
int32_t qstate12_set_cols(qstate12_type *pqs, uint32_t c0, uint32_t len, uint32_t *pa)
// Fill columns c0,...,c0 + len - 1 of matrix (A,Q) from matrix *pa,
// columns 0,...,len-1.
// This is a workaround for a compiler problem with Cython 
{
    uint_fast32_t i;
    uint64_t *m = pqs->data, mask = (ONE << len) - 1;
    uint64_t mask_pqs = ~(mask << c0);
    for (i = 0; i < pqs->nrows; ++i) {
        m[i] &= mask_pqs;
        m[i] ^= (uint64_t)(pa[i] & mask) << c0;
    }
    return 0;
}


// %%EXPORT
int32_t qstate12_copy_row(qstate12_type *pqs, uint32_t i1, uint32_t i2)
// Copy row i1 of the state matrix M referred by *pqs to row i2. 
// Also, adjust the quadratic form Q inside M. 1 <= i1, i2 < pqs->nrows 
// must hold. This does not change the state.
{ 
    uint64_t *m = pqs->data, mask; 
    int_fast32_t k, sh;
    if (bad_state(pqs)) return -2;
    if (bad_row(pqs, i1) || bad_row(pqs, i2) || i1 == 0 || i2 == 0)  
        return -7;
    m[i2] = m[i1]; 
    mask = ONE <<  (pqs->ncols + i2);
    if (i1 < i2) {
        sh = i2 - i1;
        for (k = 0; k < pqs->nrows; ++k)  {
            m[k] = (m[k] & ~mask) | ((m[k] << sh) & mask);
        }
    } else if (i1 > i2) {
        sh = i1 - i2;
        for (k = 0; k < pqs->nrows; ++k)  {
           m[k] = (m[k] & ~mask) | ((m[k] >> sh) & mask);
        }
    }
    return 0; 
} 




// %%EXPORT
int32_t qstate12_xch_rows(qstate12_type *pqs, uint32_t i1, uint32_t i2)
// Exchange row i1 of the state matrix M referred by *pqs with row i2. 
// Also, adjust the quadratic form Q inside M. 1 <= i1, i2 < pqs->nrows 
// must hold. This does not change the state.
{ 
    uint64_t *m = pqs->data, v; 
    int_fast32_t k;
    if (bad_state(pqs)) return -2;
    if (bad_row(pqs, i1) || bad_row(pqs, i2) || i1 == 0 || i2 == 0)  
        return -7;
    v = m[i1]; m[i1] = m[i2];  m[i2] = v;
    i1 +=  pqs->ncols; i2 +=  pqs->ncols; 
    v = (ONE << i1) ^ (ONE << i2);
    if (v) for (k = 0; k < pqs->nrows; ++k) 
        m[k] ^= v & -(((m[k] >> i1) ^ (m[k] >> i2)) & ONE);
    return 0; 
} 



// %%EXPORT
int32_t qstate12_del_rows(qstate12_type *pqs, uint64_t v)
// Delete all rows i, 1 <= i < pqs->nrows, from the state matrix M 
// referred by *pqs, if bit i of vector *pv is set.  Also adjust the 
// quadratic form Q inside M. Row 0 is never deleted.
{ 
    uint64_t *m = pqs->data, mask;
    int_fast32_t i, k, sh, row_pos, shifted = 0;
    if (bad_state(pqs)) return -2;
    row_pos= 1;
    while ((v & (ONE << row_pos)) == 0 && row_pos < pqs->nrows) ++row_pos;
    for (i = row_pos; i < pqs->nrows; ++i) {
        if ((v >> i) & 1) continue;
        m[row_pos] = m[i];
        sh = i - row_pos - shifted;
        if (sh) {
            mask = ((ONE << pqs->ncols) << row_pos) - 1;
            for (k = 0; k < pqs->nrows; ++k) 
                m[k] = (m[k] & mask) | ((m[k] >> sh) & ~mask);
            shifted += sh;
        }
        ++row_pos;
    }
    pqs->nrows = row_pos;
    return 0; 
} 


// %%EXPORT
int32_t qstate12_insert_rows(qstate12_type *pqs, uint32_t i, uint32_t nrows) 
// Insert 'nrows' zero rows into state matrix M referred by *pqs, 
// starting before row i. The corresponding zero columns for the 
// quadratic form Q inside M are also inserted.  1 <= i <= nrows must 
// hold. This process multiplies the state vector by the scalar
// 2**nrows.
{ 
    int_fast32_t k; 
    uint64_t *m = pqs->data, mask; 
    if (bad_state(pqs)) return -2;
    if (pqs->ncols + pqs->nrows + nrows > MAXCOLS) return -4;
    if (pqs->nrows + nrows > MAXROWS) return -5;
    if (i == 0) return -7;
    for (k = pqs->nrows - 1; k >= i; --k)  m[k + nrows] = m[k]; 
    for (k = i + nrows - 1; k >= i; --k) m[k] = 0; 
    mask = ((ONE <<  pqs->ncols) << i) - 1; 
    for (k = 0; k < pqs->nrows + nrows; ++ k) 
        m[k] = (m[k] & mask) |  ((m[k] & ~mask) << nrows); 
    pqs->nrows += nrows;
    return 0;
}


// %%EXPORT p
int32_t qstate12_mul_Av(qstate12_type *pqs, uint64_t v, uint64_t *pw) 
// Return matrix product w = A * v^T, where A is the A part of the
// matrix  referred by pqs.
{
    uint64_t  w = 0, x, *m = pqs->data;
    uint_fast32_t i, sh; 
    if (bad_state(pqs)) return -2;
    v &= (ONE << pqs->ncols) - 1;
    // Return 0 if v == 0 
    if (v == 0) return (int32_t)(*pw = 0);
    if (v & (v-1)) {
        // The standard case: v has bit weight > 1
        for (i = 0; i < pqs->ncols; ++i) {
            // Compute x = bit_parity(m[i] & v)
            x = m[i] & v;
            x ^= x >> 32; x ^= x >> 16; x ^= x >> 8; x ^= x >> 4;
            x = (0x6996 >> (x & 0xf)) & 1;
            // set bit i of output w to x
            w += x << i;
        }
    } else {
        // Optimize the case where v has bit weight 1
        for (sh = 0; (v & 1) == 0; v >>= 1) ++sh;
        for (i = 0; i < pqs->ncols; ++i) w += ((m[i] >> sh) & 1) << i;
    }
    *pw = w;
    return 0;
}




/*************************************************************************
*** Permuting bit arguments of a state
*************************************************************************/


// %%EXPORT p
int32_t qstate12_rot_bits(qstate12_type *pqs, int32_t rot, uint32_t nrot, uint32_t n0)
// Rotate bit arguments the state qs referred by pqs. For
// n0 <= i < n0 + nrot  we map bit i to bit  n0 + (i + rot) % nrot. E.g. 
// nrot = 3, rot = 1, n0 = 0 means bits are mapped as 0->1, 1->2, 2->0.
// Let nn1 = qs->ncols. Then the function changes qs to qs' with
// qs'(x[0],...,x[n0-1],y[0],...,y[nrot-1],x[n0+nrot],...,x[nn1-1]) =
// qs(x[0],...,x[n0-1],z[0],...,z[nrot-1],z[n0+nrot],...,x[nn1-1]),
// where z[j] = y[j - rot (mod 3)].
{
    uint64_t *m = pqs->data, mask_h, mask_l, mask;
    int32_t k, sh;
    if (bad_state(pqs)) return -2;
    if (nrot + n0 > pqs->ncols) return -3;
    if (nrot < 2) return 0;
    if (rot < 0) rot += nrot * (-rot / nrot) + nrot;
    rot %= nrot;
    if (rot == 0) return 0;
    mask_l = (ONE << (nrot + n0 - rot));
    mask_h = (ONE << (nrot + n0)) -  mask_l;
    mask_l -= (ONE << n0);
    mask = ~(mask_l | mask_h);
    sh = nrot - rot;
    for (k = 0; k < pqs->nrows; ++k) {
         m[k] = (m[k] & mask) | ((m[k] & mask_l) << rot) 
                              | ((m[k] & mask_h) >> sh);
    }
    return 0;    
}



// %%EXPORT p
int32_t qstate12_xch_bits(qstate12_type *pqs, uint32_t sh, uint64_t mask)
// Exchange argument bit j with argument bit j + sh of the state qs 
// referred by pqs, if bit j of 'mask' is set. If bit j of 'mask' is 
// set then bit  j + sh of 'mask' must not be set. No 'mask' bit at 
// position >= pqs->ncols - sh may be set.
// E.g.  qstate12_xch_bits(pqs, 1, 0x11) changes qs to qs' with
// qs'(x0,x1,x2,x3,x4,x5,x6,...) = qs(x1,x0,x2,x3,x5,x4,x6,...)
{
    uint64_t *m = pqs->data, v;
    uint_fast32_t k;
    if (bad_state(pqs)) return -2;
    if (sh >= pqs->ncols ||  mask & ((mask | (-ONE << pqs->ncols)) >> sh)) 
        return -3;

    // Here we simply exchange row j1 with row j2 of matrix A
    for (k = 0; k < pqs->nrows; ++k) {
        v = (m[k] ^ (m[k] >> sh)) & mask;
        m[k] ^= v ^ (v << sh);   
    }
    return 0;
}






/*************************************************************************
*** Pivoting and reducing a state
*************************************************************************/


// %%EXPORT 
int32_t qstate12_find_pivot(qstate12_type *pqs, uint32_t j, uint64_t *pv)
// Auxiliary low-level function for qstate12_reduce().
// Let A be the A part of state matrix referred by *pqs. On input j, 
// the function returns the highest row index i such that A[i,j] = 1. 
// Also, for all i1 <= i, it writes A[i1,j] to bit i1 of the vector 
// referred by pv. The function returns -1 if all A[i1,j] are zero.
{
    uint64_t *m = pqs->data,  mask; 
    int_fast32_t i = pqs->nrows - 1, i1; 

    if (bad_state(pqs)) return -2;
    if (bad_col(pqs, j)) return -8;

    // find the  highest row index i such that m[i,j] = 1. 
    mask = ONE << j;
    while (i >= 0  && ((m[i] & mask) == 0)) -- i;
    
    *pv = 0;
    for (i1 = 0; i1 <= i; ++i1) *pv |= ((m[i1] >> j) & ONE) << i1;

    return i;
}



// %%EXPORT 
int32_t qstate12_pivot(qstate12_type *pqs, uint32_t i, uint64_t v)
// Auxiliary low-level function for qstate12_reduce().
// Pivot the state matrix M referred by *pqs. The pivoting process is
// controlled by the vector v. If k < i and bit k of v is set  then 
// row i of matrix M is xored to row k of M. The columns of the 
// form Q inside M are also adjusted. 
// 1 <= i < pqs->nrows must hold. Pivoting does not change the state. 
// The function returns 0 in case of success or an error code.
{
    uint64_t *m = pqs->data; 
    uint64_t col_mask = ONE << pqs->ncols;
    uint64_t col_update = 0;
    uint_fast32_t k, sh; 

    // Check parameters
    if (bad_state(pqs)) return -2;
    if (bad_row(pqs, i) || i == 0) return -7;

    // process rows i-1, ..., 1 
    for  (k = i - 1; k > 0; --k) if (v & (1 << k)) {
         // Flip bit Q[0,k] if Q[i,k] ^ (Q[k,k] & Q[i,i]) is 1; 
         // see guide, section 'Implementation of quadratic mappings'
         m[0] ^= ((m[k] & (m[i] >> (i-k))) ^ m[i]) & (col_mask << k);
         // Mark column Q[.,i] to be added to column Q[.,k]
         col_update |=  (col_mask << k);
         // Add row i of A and Q to row k
         m[k] ^= m[i];
    }

    // Do the column operations marked in col_update
    sh = pqs->ncols + i;
    if (col_update) {
        for (k = 0; k < pqs->nrows; ++k) {
            m[k] ^= -((m[k] >> sh) & 1) & col_update;
        } 
    }

    // Finally, process row 0
    if (v & 1) {
        // Put factor *= exp(pi/2 * sqrt(-1) * k), k = 2 * Q[0,i] + Q[i,i]
        // see guide, section 'Implementation of quadratic mappings'
        k = ((m[0] >> sh) & 1) << 1;
        k += (m[i] >> sh) & 1;
        pqs->factor = ADD_FACTORS(pqs->factor, k << 1);
        // Add row i to row 0
        m[0] ^= m[i];
    }

    return 0;
}



// %%EXPORT 
int32_t qstate12_sum_up_kernel(qstate12_type *pqs)
// Auxiliary low-level function for qstate12_reduce().
// Sum up the kernel of the transformation matrix A
// We assume that A is reduced in the sense that all nonzero rows of 
// A are linear independent and that they occur before the zero rows.
{
    uint64_t *m = pqs->data, mask = (ONE << pqs->ncols) - 1; 
    uint64_t v, del_rows = 0;
    int_fast32_t i, n, res;

    // Sum up rows where A is zero. We use the algorithm in section
    // 'Reducing the representation of a quadratic mapping' of the guide.
    // Here in each iteration we delete the last row of the kernel. We 
    // may also mark more rows deleted in the bits of variable del_rows.
    while (pqs->nrows > 1 && (m[pqs->nrows - 1] & mask) == 0) {
        n = pqs->nrows - 1;
        // Ignore all rows marked as deleted
        if (del_rows & (ONE << n)) {
             --pqs->nrows;
             continue;
        }     
        // find highest row i with Q[i,n] = 0
        i = qstate12_find_pivot(pqs, pqs->ncols + n, &v);
        if (i <= 0) {
            if (i == -1) {
                // All bits in column n of Q are cleared
                // Then double the state vector
                pqs->factor += 32;
            } else {
                // Column n of Q has exactly one bit set in row 0
                // Then the result is zero
                return pqs->factor = pqs->nrows = 0;
            }
        } else {
            // Pivot so that Q[k,n] will be 0 for k != i 
            if ((res = qstate12_pivot(pqs, i, v)) < 0) return res;
            if (i == n) {
                // Last diagonal element of Q is one
                // Multiply state vector with (1 + sqrt(-1))
                pqs->factor = ADD_FACTORS(pqs->factor, 0x11);
            } else {
                // Compute row i of Q in v
                v =  (m[i] >> pqs->ncols) & (uint64_t)(-2LL);
                v |= (m[0] >> (pqs->ncols + i)) & 1;
                // Pivot so that Q[k,i] will be 0 for k != n 
                if ((res = qstate12_pivot(pqs, n, v)) < 0) return res;
                // Mark row i to be deleted
                del_rows ^= ONE << i;
                m[i] = 0;  // We don't want to find anything in row i
                // Double the state vector
                pqs->factor += 32;
            }
        }
        --pqs->nrows;  // delete row n
    }
    // Delete marked rows
    if (del_rows) qstate12_del_rows(pqs, del_rows); 
    return 0; 
}



// %%EXPORT p
int32_t qstate12_echelon(qstate12_type *pqs)
// The state referred by pqs is converted to reduced echelon form
// as described in the guide, 
// section 'Reducing the representation of a quadratic mapping'. 
// This does not change the state.
// This functio is mainly used for testing. In a live system one 
// should call function qstate12_reduce() instead.
{
    int_fast32_t col_pos = 0, row_pos = 1; 
    uint64_t v;
    int32_t res;
    if (bad_state(pqs)) return -2;  // abort if state is bad
    if (pqs->nrows == 0) return pqs->factor = 0; // done if state is 0

    // printf("Convert submatrix A to echelon\n");
    // Convert submatrix A of M to reduced echelon form
    while (col_pos < pqs->ncols && row_pos < pqs->nrows) {
        // pivot with column col_pos, advance row_pos if success
        int_fast32_t i = qstate12_find_pivot(pqs, col_pos, &v);
        if  (v == ONE << row_pos) {
            // This case occurs when the state is already reduced.
            // So we optimize it here.
            ++row_pos;
        } else if (v > ONE << row_pos) {
            if ((res = qstate12_pivot(pqs, i, v)) < 0) return res;
            if ((res = qstate12_xch_rows(pqs, i, row_pos++)) < 0) return res;
        }
        ++col_pos;
    }
    return 0;
}



// %%EXPORT p
int32_t qstate12_reduce(qstate12_type *pqs)
// The state referred by pqs is reduced as described in the guide, 
// section 'Reducing the representation of a quadratic mapping'. 
// This does not change the state.
{
    int32_t res;
    // Convert part A of the data matrix to reduced echelon form
    if ((res == qstate12_echelon(pqs)) < 0) return res;
    return qstate12_sum_up_kernel(pqs);
}



/*************************************************************************
*** Extending and restricting a state
*************************************************************************/


// %%EXPORT p
int32_t qstate12_extend_zero(qstate12_type *pqs, uint32_t j, uint32_t nqb)
// We insert ``nqb`` zero qubits into the state ``qs`` referred 
// by  ``pqs`` starting at position j. 
//
// Let ``n = pqs->ncol`` so that the state ``qs`` referred by 
// ``pqs`` depends on ``n`` qubits. We change ``qs`` to the
// following state ``qs'`` depending on ``n + ncols`` qubits:
//
// ``qs'(x[0],...,x[j-1],y[0],...,y[nqb-1],x[j],...,x[n0-1])`` 
// is equal to ``qs(x[0],...,x[j-1],x[j],...,[n-1])`` if
// ``y[0] = ... = y[nqb-1] = 0`` and equal to zero otherwise.
// So we increment ``pqs->ncols`` by ``nqb``.
//
// If the input is reduced then the result is also reduced.
{
    int32_t k;
    uint64_t *m = pqs->data, mask;
    
    if (bad_state(pqs)) return -2;
    if (pqs->ncols + nqb > MAXCOLS) return -4;
    mask = (ONE << j) - 1;
    pqs->ncols += nqb;

    for (k = 0; k < pqs->nrows; ++k) {
         m[k] = (m[k] & mask) | ((m[k] & ~mask) << nqb);
    }
    return 0;   
}




// %%EXPORT p
int32_t qstate12_extend(qstate12_type *pqs, uint32_t j, uint32_t nqb)
// We insert ``nqb`` qubits into the state ``qs`` referred by 
// ``pqs`` starting at position j. 
//
// Let ``n = pqs->ncol`` so that the state ``qs`` referred by 
// ``pqs`` depends on ``n`` qubits. We change ``qs`` to the
// following state ``qs'`` depending on ``n + ncols`` qubits:
//
// ``qs'(x[0],...,x[j-1],y[0],...,y[nqb-1],x[j],...,x[n0-1])`` 
//   = ``qs(x[0],...,x[j-1],x[j],...,[n-1])`` .
// So we increment ``pqs->ncols`` by ``nqb``.
//
// If the input is reduced then the result is also reduced.
{

    uint64_t *m = pqs->data, mask;
    uint_fast32_t i, k;
    int32_t res;

    if ((res = qstate12_extend_zero(pqs, j, nqb)) < 0) return res;
    mask = (ONE << j) - 1;
    for (i = 1; i < pqs->nrows; ++i) if (m[i] & mask) ++i; 
    if ((res = qstate12_insert_rows(pqs, j, nqb)) < 0) return res;
    mask = ONE << j;
    for (k = 0; k < nqb; ++k) m[i+k] ^= mask << k;
    return 0;
}



// %%EXPORT p
int32_t qstate12_sum_cols(qstate12_type *pqs, uint32_t j, uint32_t nqb)
// We sum up nqb qubits of the state qs referred by pqs 
// at position j. 
//
// Let ``n = pqs->ncols`` so that the state ``qs`` referred by 
// ``pqs`` depends on ``n`` qubits. We change ``qs`` to the
// following state ``qs'`` depending on ``n - ncols`` qubits:
//
// ``qs'(x[0],...,x[j-1],x[j+nqb],...,x[n-1])`` =
//    ``sum_{{x[j],...,x[j+nqb-1]}}  qs1(x[0],...,x[nn1-1])`` .
// So we decrement ``pqs->ncols`` by ``nqb``.
//
// The output is not reduced.
{
    int32_t k;
    uint64_t *m = pqs->data, mask = (ONE << j) - 1;
    
    if (bad_state(pqs)) return -2;
    if (nqb + j > pqs->ncols) return -3;
    pqs->ncols -= nqb;
    for (k = 0; k < pqs->nrows; ++k) {
        m[k] = (m[k] & mask) | ((m[k] >> nqb) & ~mask);
    }    
    return 0;   
}



// %%EXPORT p
int32_t qstate12_restrict_zero(qstate12_type *pqs, uint32_t j, uint32_t nqb)
// Restrict ``nqb`` qubits starting at postion ``j`` to ``0``.
//
// Let ``n = pqs->ncols`` so that the state ``qs`` referred by 
// ``pqs`` depends on ``n`` qubits. We change ``qs`` to the
// following state ``qs'`` depending on ``n`` qubits:
//
// qs'(x[0],...,x[n-1]) is equal to qs(x[0],...,x[n-1]) if 
// x[j] = ... = x[j+nqb-1] = 0 and equal to zero otherwise.
// We do not change ``pqs->ncol``.
// 
// The output is reduced if the input is reduced.
{
    uint64_t *m = pqs->data, v, deleted = 0, mask = -(ONE << pqs->ncols);
    int_fast32_t i, col_pos;
    int32_t res;

    if (bad_state(pqs)) return -2;
    if (nqb + j > pqs->ncols) return -3;
    if (pqs->nrows == 0)  return 0;
    
    for (col_pos = j; col_pos < j + nqb; ++col_pos) {
        i = qstate12_find_pivot(pqs, col_pos, &v);
        if (i > 0) {
            if ((res = qstate12_pivot(pqs, i, v)) < 0) return res; 
            m[i] &= mask;
            deleted |= ONE << i;
        } else if (i == 0) {
            return  pqs->nrows = 0;  
        } 
    }
    return qstate12_del_rows(pqs, deleted);   
}



// %%EXPORT p
int32_t qstate12_restrict(qstate12_type *pqs, uint32_t j, uint32_t nqb)
// Similar to function ``qstate12_restrict_zero`` with deleting
// the restricted qubits.
//
// Let ``n = pqs->ncols`` so that the state ``qs`` referred by 
// ``pqs`` depends on ``n`` qubits.  We change ``qs`` to the
// following state ``qs'`` depending  on ``n' = n - nqb`` qubits:
// 
// qs'(x[0],...,x[n'-1]) is equal to 
// qs(x[0],...,x[j-1],0,...,0,x[j],...,x[n'-1]). 
// So we decrement ``pqs->ncols`` by ``nqb``.
//
// The output is not reduced.
{
    int32_t res;
    if ((res = qstate12_restrict_zero(pqs, j, nqb)) < 0) return res;
    return qstate12_sum_cols(pqs, j, nqb);
}



/*************************************************************************
*** 'Multiplying' states
*************************************************************************/



// %%EXPORT
int32_t qstate12_prep_mul(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb)
// Auxiliary low-level function for qstate12_product().
// Prepare the states qs1 and qs2 referred by pqs1 and pqs2 for 
// multiplication. Here the first nqb columns of qs1 and qs2 are to 
// be multiplieded. The function returns a number 'row_pos', so that, 
// after preparation, the first nqb columns of submatrices A1 and A2 
// of the matrices M1 and M2corresponding to qs1 and qs2 will be equal 
// in the following sense: 
// A1[i,j] = A2[i,j]       for i <  'row_pos', j < 'nqb' ,   (QS1)
// A1[i,j] = A2[i,j] = 0   for i >= 'row_pos', j < 'nqb' ,   (QS2)
// and matrices A1 and A2 both have rank 'row_pos' - 1, when excluding
// row 0 of the two matrices.
// Some rows of A1 or A2 may be deleted to achieve this situation.
// The result of the multiplication of the states qs1 and qs2 over 
// the first nqb columns of is not changed by this operation.
// Apart from this assertion, both states are changed, and they may
// have less rows than before. They may even be changed to zero, if the 
// result of the multiplication is zero.
//
// The algorithm used here is explained in the guide in section
// 'Multiplication of quadratic mappings'. 
// In the notation in that section the algorithm computes
// states qs1', qs2' with  (qs1' (*) qs2')_n = (qs1 (*) qs2)_n 
// where n = nqb, and (*) denotes the '\odot' operation defined in
// section 'Products and tensor products of quadratic mappings'
// of the guide.
{
    int_fast32_t i1, i2, col_pos, n_deleted = 0;
    int_fast32_t row_pos = 1, row_pos1 = 1, row_pos2 = 1;
    uint64_t v1, v2, deleted = 0;
    int32_t res;

    // check and reduce input matrices
    // printf("<prep_mul>");
    if ((res = qstate12_reduce(pqs1)) < 0) return res;
    if ((res = qstate12_reduce(pqs2)) < 0) return res;
    if (nqb > pqs1->ncols || nqb > pqs2->ncols) return -3;
    // 
    if (pqs1->nrows == 0 || pqs2->nrows == 0)  {
        return  pqs1->nrows = pqs2->nrows = 0;
    }
    // Equalize the first 'ncols' columns of m1 and m2
    for (col_pos = 0; col_pos < nqb; ++col_pos) {
        // pivot with column col_pos, advance row_pos if success
        qstate12_get_col(pqs1, col_pos, row_pos1, &v1);
        qstate12_get_col(pqs2, col_pos, row_pos2, &v2);
        i1 = (v1 >> row_pos1) & 1;
        i2 = (v2 >> row_pos2) & 1;
        if (i1) {
            qstate12_copy_row(pqs1, row_pos1++, row_pos);
            if (i2) {
                qstate12_copy_row(pqs2, row_pos2++, row_pos);
                if ((res = qstate12_pivot(pqs1, row_pos, v1)) < 0) return res;
                if ((res = qstate12_pivot(pqs2, row_pos, v2)) < 0) return res;
                ++row_pos;
            } else {          
                if ((res = qstate12_pivot(pqs1, row_pos, v1 ^ v2) < 0)) 
                    return res;
            }
        } else {
            if (i2) {
                qstate12_copy_row(pqs2, row_pos2++, row_pos);
                if ((res = qstate12_pivot(pqs2, row_pos, v1 ^ v2) < 0)) 
                    return res;
            } else {
                int32_t i = row_pos-1;
                v1 ^= v2;
                while (i >= 0 && ((ONE << i) & v1) == 0) --i;
                if (i > 0) {
                    if ((res = qstate12_pivot(pqs1, i, v1)) < 0) return res;
                    if ((res = qstate12_pivot(pqs2, i, v1)) < 0) return res;
                    deleted |= ONE << i; ++n_deleted;
                    pqs1->data[i] =  pqs2->data[i] = 0; 
                } else if (i == 0) {
                    return  pqs1->nrows = pqs2->nrows = 0;  
                }                
            }
        } 
    }

    // printf("<almost>");
    v1 = deleted + (ONE << row_pos1) - (ONE << row_pos);
    v2 = deleted + (ONE << row_pos2) - (ONE << row_pos);
    if ((res = qstate12_del_rows(pqs1, v1)) < 0) return res;
    if ((res = qstate12_del_rows(pqs2, v2)) < 0) return res;
    row_pos -= n_deleted;

  #ifdef CHECK_qstate12_PREP_MUL
    // The preparation algorithm is a bit involved. So we may check the 
    // conditions for matrices A1, A2 after preparation here.
    {
        uint64_t err = 0;
        // printf("<check>\n");
        for (i1 = 0; i1 < row_pos; ++i1) 
            err |= pqs1->data[i1] ^ pqs2->data[i1];
        for (i1 = row_pos; i1 < pqs1->nrows; ++i1) err |= pqs1->data[i1];
        for (i1 = row_pos; i1 < pqs2->nrows; ++i1) err |= pqs2->data[i1];
        if (err & ((ONE << nqb) - 1)) return -99; 
        // printf("<done, return %d>\n", row_pos);
    }
  #endif
   
    return row_pos ;
}



// %%EXPORT
int32_t qstate12_mul_elements(qstate12_type *pqs1, qstate12_type *pqs2, uint64_t mask)
// Auxiliary low-level function for qstate12_product().
// For the submatrices A1, Q1 and A2, Q2 of the matrices M1 and M2 
// corresponding to qs1 and qs2 we put A1 = A1 + A2, B1 = B1 + B2.
// The pair (A2, B2) is masked with the Mask beforit is added.
// The number of rows or columns of A2 may not be larger than the
// number of row2 or columns of A2. 
{
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data, c = ONE << pqs1->ncols;
    int32_t k;
    if (bad_state(pqs1) || bad_state(pqs2)) return -2;
    if (pqs2->nrows != pqs1->nrows || pqs2->ncols != pqs1->ncols) return -99; 
    m1[0] ^= m2[0];
    for (k = 1; k < pqs1->nrows; ++k)  {
       m1[0] ^= m1[k] & m2[k] & (c << k);
       m1[k] ^= m2[k] & mask;
    }
    pqs1->factor = ADD_FACTORS(pqs1->factor, pqs2->factor);
    return 0;
}






// %%EXPORT p
int32_t qstate12_product(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nc, uint32_t nqb)
// Compute a certain product ``qs3`` of the states ``qs1`` 
// and ``qs2`` referred by ``pqs1`` and ``pqs2``. 
// Let ``n1 = pqs1->ncols,  n2 = pqs2->ncols``.
// Put ``qs1a =  qstate12_extend(qs, n1, n2-nqb)``,
// ``qs2a =  qstate12_extend(qs, nqb, n1-nqb)``. Then ``qs1a``
// and ``qs2a`` are complex functions on ``(nn1 + nn2 - nqb)``
// bits. Let ``qs3a`` be the complex function which is the 
// product of the functions  ``qs1a`` and ``qs2a``. Then we 
// have ``qs3 = qstate12_sum_cols(qs23, 0, nc)``.
// The result ``qs3`` is computed in the state referred by 
// ``qs1``. It is reduced. ``qs2`` is destoyed. 
//
// E.g. ``qstate12_product(pqs1, pqs2, nc, nc)`` is the tensor 
// contraction over the first ``nc`` qubits of ``qs1`` and 
// ``qs2``. ``In case pqs1->ncols = pqs2->ncols = n``, the 
// function ``qstate12_product(pqs1, pqs2, 0, n)`` returns the 
// product of ``qs1`` and ``qs2`` (considered as functions); 
// and ``qstate12_product(pqs1, pqs2, n, n)`` returns the scalar
// product of ``qs1`` and ``qs2`` (considered as vectors).
//
// ``qstate12_product(pqs1, pqs2, 0, n)`` corresponds to the 
// function ``(qs1 (*) qs2)_n``  where ``(*)`` denotes the 
// ``'\odot'`` operation defined in section 
// 'Products and tensor products of quadratic mappings'
// of the guide.
{
    int32_t row_pos = qstate12_prep_mul(pqs1, pqs2, nqb);
    int32_t rows1, rows2; 
    int32_t res;

    if (row_pos < 0) return row_pos; // Then row_pos is an error code
    if (nc > nqb) return -3;

    if ((res = qstate12_sum_cols(pqs1, 0, nc)) < 0) return res; 
    if ((res = qstate12_sum_cols(pqs2, 0, nc)) < 0) return res; 
    nqb -= nc;
    
    if ((res = qstate12_extend(pqs1, pqs1->ncols, pqs2->ncols - nqb)) < 0)
        return res;
    if ((res = qstate12_extend(pqs2, nqb, pqs1->ncols - nqb)) < 0) 
        return res;

    if (pqs1->nrows == 0 || pqs2->nrows == 0)
        return pqs1->nrows = pqs1->factor = 0; 

    rows1 = pqs1->nrows - row_pos;  rows2 = pqs2->nrows;
    if ((res = qstate12_insert_rows(pqs1, pqs1->nrows, rows2)) < 0) 
        return res;  
    if ((res = qstate12_insert_rows(pqs2, row_pos, rows1)) < 0) 
        return res; 
    if ((res = qstate12_mul_elements(pqs1, pqs2, -(ONE << nqb))) < 0) 
        return res; 
    if ((res = qstate12_reduce(pqs1)) < 0) return res; 
    return 0;
}





/*************************************************************************
*** Applying 'gates' to a state
*************************************************************************/



// %%EXPORT p
int32_t qstate12_gate_not(qstate12_type *pqs, uint64_t v)
// Change the state ``qs`` referred by ``pqs`` to a state ``qs'`` 
// with ``qs'(x) = qs(x (+) v)``, where ``'(+)'`` is the bitwise 
// xor operation.
// The result is reduced if the input is reduced.
// Computing ``qstate12_gate_not(pqs, 1 << j)`` corrsponds to
// negating qubit ``j``.
{
    if (bad_state(pqs)) return -2;
    if (pqs->nrows == 0) return 0;
    pqs->data[0] ^= v & ((ONE << pqs->ncols) - 1);
    return 0;
}


// %%EXPORT p
int32_t qstate12_gate_ctrl_not(qstate12_type *pqs, uint64_t vc, uint64_t v)
// Change the state ``qs`` referred by ``pqs`` to a state ``qs'``
// with ``qs'(x) = qs(x (+) <vc,x> * v)``  where ``'(+)'`` is 
// the bitwise  xor operation, and ``<.,.>`` is the scalar 
// product of bit vectors.
// The result is not reduced.
// Computing ``qstate12_gate_ctrl_not(pqs, 1 << jc, 1 << j)``, 
// for ``jc != j``, corresponds to applying a controlled not  
// gate  to qubit ``j``  contolled by qubit ``jc``. . 
// This operation is unitary if and only if the scalar
// product of ``j`` and ``jc`` is zero.
{
    uint64_t *m = pqs->data, wc;
    uint_fast32_t i;
    int32_t res;
    v &= (ONE << pqs->ncols) - 1;
    if ((res = qstate12_mul_Av(pqs, vc, &wc)) < 0) return res;

    if (wc) for (i = 0; i < pqs->nrows; ++i) 
        m[i] ^= -((wc >> i) & ONE) & v;
    return 0;
}



// %%EXPORT p
int32_t qstate12_gate_phi(qstate12_type *pqs, uint64_t v, uint32_t phi)
// Change the state ``qs`` referred by ``pqs`` to a state ``qs'``
// with ``qs'(x) = qs(x) * sqrt(-1)**(phi * <v,x>)``, where
// ``<.,.>`` is the scalar product of bit vectors and ``'**'`` 
// denotes exponentiation.
// The result is reduced if the input is reduced.
// Computing ``qstate12_gate_ph(pqs, 1 << j, phi)`` 
// corresponds to applying a  phase ``(phi * pi/2)``  gate 
// to qubit ``j``. 
{
    uint64_t *m = pqs->data, w, wsh, c;
    uint_fast32_t i;
    int32_t res;
    if ((res = qstate12_mul_Av(pqs, v, &w)) < 0) return res;
    if (w == 0) return 0;
    wsh = w << pqs->ncols;

    if (phi & 1) {
        c = ONE << pqs->ncols;
        //TODO: yet to be dcoumented and checked!!!!
        pqs->factor = ADD_FACTORS(pqs->factor, (w & 1) << 1);
        m[0] ^= wsh & -(w & ONE);
        for (i = 1; i < pqs->nrows; ++i) {
            m[0] ^= wsh & m[i] & (c << i);
            m[i] ^= wsh & -((w >> i) & ONE);
        }
    }
    if (phi & 2) {
        pqs->factor ^= (w & 1) << 2; 
        m[0] ^= wsh;
    }
    return 0;
}



// %%EXPORT p
int32_t qstate12_gate_ctrl_phi(qstate12_type *pqs, uint64_t v1, uint64_t v2)
// Change the state ``qs`` referred by ``pqs`` to a state ``qs'``
// with ``qs'(x) = qs(x) * (-1)**(<v1,x>*<v2,x>)``, where 
// ``<.,.>``  is the scalar product of bit vectors and ``'**'``
// denotes exponentiation.
// The result is reduced if the input is reduced.
// Computing ``qstate12_gate_ctrl_phi(pqs, 1 << j1, 1 << j2)``
// corresponds to applying a  phase ``pi`` gate to 
// qubit ``j2`` controlled by qubit ``j1``. 
{
    uint64_t *m = pqs->data, w1, w2, w1sh, w2sh;
    uint_fast32_t i;
    int32_t res;
    if ((res = qstate12_mul_Av(pqs, v1, &w1)) < 0) return res;
    if ((res = qstate12_mul_Av(pqs, v2, &w2)) < 0) return res;
    w1sh = w1 << pqs->ncols;
    w2sh = w2 << pqs->ncols;
    pqs->factor ^= (w1 & w2 & 1) << 2; 
    m[0] ^= (w1sh & -(w2 & ONE)) ^ (w2sh & -(w2 & ONE))
          ^ (w1sh & w2sh);
    for (i = 1; i < pqs->nrows; ++i) {
        m[i] ^= (w1sh & -((w2 >> i) & ONE)) 
              ^ (w2sh & -((w2 >> i) & ONE));
    }
    return 0;
}



// %%EXPORT p
int32_t qstate12_gate_h(qstate12_type *pqs, uint64_t v)
// Apply a Hadamard gate to all qubits ``j`` of the state ``qs``
// (referred by pqs) with  ``v & (1 << j) == 1``.
// Aplying a Hadamard gate to gate ``j`` changes a state ``qs``
// to a state ``1/sqrt(2) * qs'``, where
// ``qs'(..,x[j-1],x_j,x[j+1],..) = qs(..,x[j-1],0,x[j+1],..)``
//   + (-1)**(x_j) * qs(..,x[j-1],1,x[j+1],..)  .
// The result is not reduced.
{
    uint64_t *m = pqs->data, w, mask1, c;
    uint_fast32_t i, j, sh, max_rows;
    uint32_t res;
    if (bad_state(pqs)) return -2;
    if (pqs->nrows == 0) return 0; // nothing do do for zero state

    max_rows = MIN(2 * pqs->maxrows + 1, pqs->maxrows);
    max_rows = MIN(max_rows, MAXCOLS - pqs->ncols);

    for (j = 0; j < pqs->ncols ; ++j) if (v & (ONE << j))  {
        // Reduce if short of space
        if (pqs->nrows >= max_rows) {
            if ((res = qstate12_reduce(pqs)) < 0) return res;
        }
        // Append one zero row and apply the algorithm in the guide in
        // section 'Applying a Hadamard gate to a quadratic mapping'.
        // Let n be the index of the row appended to part A and of the
        // row and column appended to part Q. We put
        // Q[n,k] = Q[k,n] = A[k,j],  A[k,j] = 0 for all k < n, 
        // and A[n,j] = 1.
        w = 0;
        sh = pqs->nrows + pqs->ncols;
        mask1 = (ONE << sh) - (ONE << j) - 1;
        for (i = 0; i < pqs->nrows; ++j) {
            c = (m[i] >> j) & 1;
            m[i] = (m[i] & mask1) | (c << sh);
            w |= c << j;
        } 
        m[pqs->nrows++] = (ONE << j) + (w << pqs->ncols);
        // multiply result with 1 / sqrt(2)
        pqs->factor -= 0x10; 
    }
    return 0;
}



/*************************************************************************
*** Converting a state to a complex vector
*************************************************************************/


// Suggestions for treatment of complex numbers in C and Cython see:
// https://numpy.org/devdocs/user/c-info.python-as-glue.html#complex-addition-in-cython
// https://stackoverflow.com/questions/31932781/how-to-interface-a-numpy-complex-array-with-c-function-using-ctypes
// https://stackoverflow.com/questions/6418807/how-to-work-with-complex-numbers-in-c
// https://en.cppreference.com/w/c/numeric/complex


// Although complex numbers have been invented more than 200 years
// ago and standardized in C99 about 20 years ago, it is still tooo
// annoying to deal with the peculiarites of the data type 
// 'double complex' in the variaous compilers being used.
// So we output an array of type double[] of real numbers of 
// doubled length, where an adjacent pair of entries gives the
// real and the imaginary part of a complex number. We let Python
// do the convesion from that real array to a complex array. See:
// 
// https://stackoverflow.com/questions/2598734/numpy-creating-a-complex-array-from-2-real-ones



static const int8_t  PHASES[8][2] = {
   {{1,0}}, {{1,1}}, {{0,1}}, {{-1,1}}, 
   {{-1,0}}, {{-1,-1}}, {{0,-1}}, {{1,-1}},
};  

#define SQRT2 1.414213562373095048801688724209L 

static void set_complex_factors(int32_t e, double  *p_real, double *p_imag)
{
    double f;
    int i;
    if (e >= 0) f = ONE << (e >> 5);
    else f = 1.0 / (ONE << ((0x10 - (e & ~0xfLL)) >> 5));
    if ((e & 0x10) && !(e & 1)) f *= SQRT2;
    if (!(e & 0x10) && (e & 1)) f *= (1.0L / SQRT2);
    for (i = 0; i < 4; ++i) {
        p_real[i] = f * PHASES[(2*i + e) & 7][0];       
        p_imag[i] = f * PHASES[(2*i + e) & 7][1];   
    }        
}








// qstate12_lsbtab[i] is the position of least significant bit of i | 0x40
const uint8_t qstate12_lsbtab[64] = {
    6,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    4,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    5,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0, 
    4,0,1,0,2,0,1,0, 3,0,1,0,2,0,1,0 
};

// %%EXPORT p
int32_t qstate12_complex_test(qstate12_type *pqs,  double *pc)
// Expand the f * qs where qs is the state referred by pqs to the 
// array a, and reduce all entries of array a modulo p. Depending on 
// the scalar factor in the state pqs, a number 1/2 or sqrt(2) modulo 
// p must exist. 
// Caution: The function sets 2**pqs->ncols entries in the array pc!!
{    
    uint_fast32_t qf = 0;
    uint64_t *m = pqs->data;
    uint64_t ncols = pqs->ncols; 
    uint64_t n_iterations = ONE << (pqs->nrows - 1); 
    uint64_t mask = (ONE << ncols) - 1; 
    uint64_t assoc; 
    uint64_t i;
    double freal[4], fimag[4];
    int32_t res;

    if ((res = qstate12_check(pqs)) < 0) return res;
    assoc = m[0]; 
    for (i = 0; i < 2LL << ncols; ++i) pc[i] = 0.0;
    if (pqs->nrows == 0) return 0;
    set_complex_factors(pqs->factor, freal, fimag);
   
    for (i = 1; i <= n_iterations; ++i) {
        uint64_t i1, d, diag, d1, index;
        index = (assoc & mask) << 1;
        pc[index] += freal[qf & 3];
        pc[index + 1] += fimag[qf & 3];
        d1 = d = qstate12_lsbtab[(i1 = i) & 63];
        while (d1 == 6) {
            i1 >>= 6;
            d += (d1 = qstate12_lsbtab[i1 & 63]);
        } 
        diag = (m[d+1] >> (ncols + d + 1)) & 1;
        qf += ((assoc >> (ncols + d)) & 2) + diag;
        assoc ^= m[d+1];
    } 
    return 0;       
}




// %%GEN ch
#ifdef __cplusplus
}
#endif

