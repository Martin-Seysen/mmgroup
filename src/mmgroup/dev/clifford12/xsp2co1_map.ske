/** @file xsp2co1_map.c
  File ``xsp2co1_map.c`` contains  functions for computing an
  element \f$g\f$ of the group \f$G_{x0} = 2^{1+24}.\mbox{Co}_1\f$
  from the action of  \f$g\f$ on the normal
  subgroup \f$Q_{x0} = 2^{1+24}\f$ of \f$G_{x0}\f$.

  Here the  group \f$G_{x0}\f$ is the maximal subgroup of the
  Monster used in our construction of the Monster. We store an
  element of \f$G_{x0}\f$ as word of  generators of that group as
  described in file``mmgroup_generators.h``. Internally, we also use
  the **G_x0 representation** for elements of \f$G_{x0}\f$
  as described in file ``xsp2co1.c``.

  Elements of the group \f$Q_{x0}\f$ are stored in **Leech lattice
  encoding** as described in
  section **Description of the mmgroup.generators extension**.

  Note that an element of \f$G_{x0}\f$ is determined by its action
  on \f$Q_{x0}\f$ up to sign only.

  This file is yet a stub!!!
*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#define CLIFFORD12_INTERN
#include "clifford12.h"
/// @endcond  


// %%EXPORT_KWD CLIFFORD12_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/*************************************************************************
*** Functions
*************************************************************************/



/**
   @brief Compute a certain mapping from \f$Q_{x0}\f$ to itself

   Let \f$g \in G_{x0}\f$ be such that \f$g\f$
   conjugates \f$m_{1,j}\f$ to \f$m_{2,j}\f$
   for \f$m_{i,j} \in Q_{x0}\f$, \f$i = 1,2; 0 \leq j \leq 24\f$.
   If the \f$m_{1,j}\f$ (considered as vectors
   in \f$\Lambda/2 \Lambda\f$) are linear independent then there
   is at most one such \f$g\f$, up to sign.

   Here inputs  \f$m_{1,j}, m_{2,j}\f$ are given in the
   arrays ``m1, m2`` in **Leech lattice encoding**.

   The function computes \f$g\f$ as a 
   mapping \f$m_{0,j} \mapsto m_{3,j}\f$, where \f$m_{0,j}\f$
   is the standard basis of \f$\Lambda/2 \Lambda\f$
   (with  \f$m_{0,j}\f$ = ``1 << j`` in  **Leech lattice encoding**).
   The function stores the vectors  \f$m_{3,j}\f$ in the
   array ``m_out`` of length 24 in **Leech lattice encoding**.
   
   The function returns -1 it it detects an error and 0 if it
   does not detect any error. If the function returns 0 and the
   output is a correct image of the standard basis then the
   there exists a \f$g\f$ that maps \f$m_{1,j}\f$
   to \f$m_{2,j}\f$.   
*/
// %%EXPORT px
int32_t xsp2co1_Co1_get_mapping(uint64_t *m1, uint64_t *m2, uint64_t *m_out)
{
    int_fast32_t row, col, k1, k2;
    uint64_t v, col_mask, m[24], sign;
    for (row = 0; row < 24; ++row) {
        m[row] =  ((m2[row] & 0x1ffffffULL) << 24) 
                 ^  (m1[row] & 0xffffffULL)
                ^ ((m1[row] & 0x1000000ULL) << 24);
    }

    for (col = 0; col < 24; ++col) {
        col_mask = ONE << col;
        for (k1 = 23; k1 >= col; --k1) {
            if (m[k1] &  col_mask) {
                v = m[k1];
                for (k2 = k1 - 1; k2 >= 0; --k2) {
                    if (m[k2] & col_mask) {
                        sign = v & (m[k2] >> 12);
                        sign ^= sign >> 24;
                        m[k2] ^= v ^ (sign << 48);
                    }
                }
                m[k1] = m[col]; m[col] = v;
                break;
            }
        }
        if (k1 < col) return -1; // abort if column not done
    } 

    for (row = 0; row < 24; ++row) m_out[row] = m[row]; // WTF!!
    
    for (row = 0; row < 24; ++row) {
        sign = ((m[row] >> 48) ^ (m[row] >> 54)) & 0x3f;
        sign = (0x6996966996696996ULL >> sign) & 1;
        m_out[row] = ((m[row] >> 24) & 0xffffffULL) | (sign << 24);
    } 

    // TODO: It make sense to chec the scalar products of the output!!
       
    return 0;
}







/**
   @brief Compute preimage in \f$G_{x0}\f$ of element of \f$\mbox{Co}_1\f$

   Let Matrix \f$m\f$ (given by parameter ``m``) be a 24 times 24 
   bit matrix that describes an automorphism \f$g' \in \mbox{Co}_1\f$ 
   of \f$\Lambda/2\Lambda\f$. Here \f$\Lambda/2\Lambda\f$
   is the Leech lattice modulo 2, and \f$m\f$ acts by right
   multiplcation on vectors in \f$\Lambda/2\Lambda\f$ encoded 
   in **Leech lattice encoding**.

   Then this function computes a preimage \f$g \in G_{x0}\f$ 
   of \f$g'\f$ as a word of generators of \f$G_{x0}\f$ and stores
   that word in the buffer referred by parameter ``g``.
   It returns the length of that word in case of success and
   an negative value in case of failure.
 
   The function is not yet implemented!!!
*/
// %%EXPORT px
int32_t xsp2co1_Co1_matrix_to_word(uint64_t *m, uint32_t *g)
{
    return -1;
}







//  %%GEN h
/// @endcond  
//  %%GEN c

// %%GEN ch
#ifdef __cplusplus
}
#endif

