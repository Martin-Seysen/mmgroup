r"""



The functions in file ``xsp2co1.c`` implement the group operation 
of the subgroup 
:math:`G_{x0}` (of structure :math:`2^{1+24}.\mbox{Co}_1`)
of the monster. 

In :cite:`Seysen20`, section 9.3, the generators  
:math:`x_d, x_\delta, y_\delta, x_\pi, \xi` of :math:`G_{x0}`
are also defined as generators of a group  :math:`G_{x1}` with 
:math:`|G_{x1}:G_{x0}| = 2`. Let  :math:`\mathcal{P}` be the 
Parker loop as defined in section :ref:`parker-loop-label`.
The group :math:`G_{x1}` operates on a 4096-dimensional rational 
vector space :math:`4096_x` with basis vectors 
:math:`d_1^+, d_1^-, d \in \mathcal{P}`, and  relations 
:math:`(-d)_1^\pm = -d_1^\pm`, :math:`(\Omega  d)_1^+ = d_1^+`, 
:math:`(\Omega  d)_1^- = -d_1^-`. The subgroup :math:`G_{x0}` 
of the monster does not operate on the space  :math:`4096_x`. 
But :math:`G_{x0}` operates faithfully on the tensor product  
:math:`4096_x \otimes \Lambda`,  with the operation of
:math:`G_{x1}` on the Leech lattice :math:`\Lambda` as 
described in section :ref:`op-leech-label`.

The operation of :math:`G_{x1}` on  :math:`4096_x` has a kernel 
:math:`K(4096_x)`, which is a central subgroup of :math:`G_{x1}` 
of order 2 generated by :math:`y_\Omega`. The group 
:math:`G(4096_x) = G_{x1}/K(4096_x)` is a subgroup of the real 
Clifford group :math:`\mathcal{C}_{12}` described in section
:ref:`clifford-group-label`. The representation :math:`4096_x` 
of :math:`G(4096_x)` extends to the standard representation of 
:math:`\mathcal{C}_{12}` described in that section. 

So we may represent an element :math:`x_g` of :math:`G(4096_x)`
as a **quadratic state matrix** in a structure of type 
``qstate12_type``, as defined in file ``clifford12.h``. Then
we may use the functions in file ``qmatrix12.c`` for computing
in :math:`G(4096_x)`. Also, we may use the functions in file 
``gen_leech.c`` for applying an element of the automorphism group 
:math:`\mbox{Co}_0` of  :math:`\Lambda` to a vector in
:math:`\Lambda`. Together, this gives us the capability
to compute in the subgroup :math:`G_{x0}` of the monster.
Note that :math:`x_g` determines :math:`g \in G_{x0}` up to 
sign, so it suffices to store the image of a fixed short vector 
in :math:`\Lambda` to determine the sign. Therefore it suffices 
to compute in the Leech lattice modulo 3.


The basis vectors of the standard  representation of 
:math:`\mathcal{C}_{12}` are numbered from  :math:`0` to 
:math:`2^{12}-1`. 
In section :ref:`parker-loop-label` the elements of 
:math:`\mathcal{P}` are numbered from :math:`0` to 
:math:`2^{13}-1`. For :math:`0 \leq d < 2^{11}` we identify the 
basis vectors :math:`d_1^+` and :math:`d_1^-` of  :math:`4096_x`
with the basis vectors with numbers corresponding to :math:`d` 
and to :math:`d+2^{11}` of the representation of 
:math:`\mathcal{C}_{12}`, respectively. 


We represent an element :math:`g` of :math:`G_{x0}` as a pair
:math:`(x_g, v_g)` with  
:math:`x_g \in G(4096_x) \subset \mathcal{C}_{12}`. The vector 
:math:`v_g \in \Lambda / 3 \Lambda` is the image of the short
Leech lattice vector 
:math:`v_0 = (0,0,1,-1,0,...,0) \in \Lambda` under :math:`g`.

In section :ref:`clifford-group-label` a element :math:`x_g`
of :math:`\mathcal{C}_{12}` is given as a real
:math:`2^{12} \times 2^{12}` matrix stored in a structure
of type ``qstate12_type``. In case :math:`x_g \in G(4096_x)`
that matrix has rational entries, where the denomiators are 
powers of two. A structure of type ``qstate12_type`` 
representing an  :math:`x_g \in G(4096_x)` contains 
a triple :math:`(e,A,Q)`. There :math:`e` is a signed integral  
power of two, and :math:`(A,Q)` is a pair of bit 
matrices with up to 25 rows and up to 49 colums, where the 
first 24 columns belong to matrix :math:`A`, and the remaining 
columns belong to  matrix :math:`Q`.

Changing the sign of :math:`e` corresponds to negation of a 
matrix or to  multiplication by :math:`x_{-1}`. In the group 
:math:`G_{x0}`, changing the sign of :math:`v_1` has the same 
effect as changing the sign of :math:`e`; so  :math:`e` can 
always be made positive. The absolute value of :math:`e` is 
just there for scaling the operator norm of a matrix 
:math:`x_g` to 1, and can be omitted.

So we can represent one of the values :math:`\pm x_g` as a
pair :math:`(A,Q)`  with an implied positive scalar factor 
:math:`e` as above, and negate component :math:`v_g` of the 
pair :math:`(x_g,v_g)`, if necessary. 

 
We actually represent an element of :math:`G_{x0}` in **G_x0** 
representation. This is as an array ``elem`` of 26 integers 
of type ``uint64_t``. That array contains a pair
:math:`(x_g,v_g)` with :math:`v_g` stored in the first
entry ``elem[0]``, and  :math:`x_g` stored in the remaining
25 entries of array ``elem``.

Vector :math:`v_g \in \Lambda / 3 \Lambda` is represented as 
a 48-bit integer in **Leech lattice mod 3 encoding** as 
described in the documentation of module ``gen_leech.c``.
Assuming that  :math:`v_g` is stored in a structure 
``qs`` of type ``qstate_type``, we copy all valid entries 
``qs.data[i]`` to ``elem[i+1]``. This amounts to copying the
components  :math:`(A,Q)` of the triple  :math:`(e,A,Q)`
from ``qs`` to ``elem``.  We always reduce the quadratic
state matrix in ``qs`` before copying it, as indicated in 
section :ref:`clifford-group-label`. We fill unused entries 
and bits in the array ``elem`` with zeros. Thus  the 
representation of a :math:`g \in G_{x0}` in memory is unique.
``qs`` can easily be reconstructed from ``elem``, assuming
that the scalar factor :math:`e` in the triple
:math:`(e,A,Q)` is positive, and that trailing zero 
entries in the array ``elem`` are unused.

 

We also use the vectors :math:`(d'), d \in \mathcal{P}` as basis 
vectors of :math:`4096_x` , where:

.. math::
    (d)' = \frac{1}{\sqrt2} \left( d_1^+ + d_1^- \right) \, , \quad 
    d_1^\pm = \frac{1}{\sqrt2} \left( (d)' \pm (\Omega d)' \right) \, . 

    
The reason for introducing this basis is that the operation of 
:math:`G_{x0}` on  :math:`Q_{x0}` (by conjugation) is
easy when we using this basis.
Then we obviously have :math:`(-d)' = -(d)'`. Transforming the
coordinates of a vector :math:`v` from the basis  given by
:math:`d^\pm`  to the basis given by  :math:`(d)'` can be done by 
applying the Hadamard gate to Qubit 11 (i.e. the bit valence 
:math:`2^{11}`) of the coordinates of  :math:`v` .  This 
transformation is an involution. Then the numbering of the 
4096 basis vectors :math:`(d)'` corresponds to the numbering of
the positive elemments of :math:`\mathcal{P}`. We may put
:math:`(d \oplus 2^{12})' = -(d)'`, where :math:`\oplus` means
bitwise addition modulo 2; then that correspondence
holds for all values :math:`0 \leq d < 2^{13}`. The exact
defnition of the operator :math:`\oplus`  on the Parker loop
:math:`\mathcal{P}` is given in section 
:ref:`implement-gen-mm`.

In this basis the operation of the extraspecial group 
:math:`Q_{x0}` is very simple:

    * :math:`x_e x_{\theta(e)}` maps  :math:`(d)'` to   
      :math:`(d \oplus e)'` for :math:`e \in \mathcal{P}`.
      Here :math:`\theta` is the cocycle, see section 
      :ref:`parker-loop-label`. In the language of 
      quantum computing this corresponds to a seqence
      of commuting **not** gates.
      
    * :math:`x_\epsilon` maps    :math:`(d)'` to   
      :math:`(-1)^{\langle d, \epsilon\rangle}(d)'`
      for :math:`\epsilon \in \mathcal{C}^*`. Here 
      :math:`\mathcal{C}^*` is the Golay cocode. In 
      the language of quantum computing this corresponds 
      to a seqence of commuting **phase**-:math:`\pi`
      gates.
"""
