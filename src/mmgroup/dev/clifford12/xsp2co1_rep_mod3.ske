/** @file xsp2co1_rep_mod3.c

  File ``xsp2co1__rep_mod3.c`` contains function for dealing with the
  representation \f$4096_x \otimes 24_x\f$ of the group  \f$G_{x0}\f$
  (of structure \f$2^{1+24}.\mbox{Co}_1\f$), with entries of
  the representation taken modulo 3.

  Here we may store tensors \f$q \otimes v_3\f$ in the
  space \f$4096_x \otimes 24_x\f$ (mod  3) in a compact form,
  where \f$q \in 4096_x\f$ can be expressed as a quadratic state vector,
  and \f$v_3\f$ is an arbitrary vector in the Leech lattice modulo 3. 
*/



/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#define CLIFFORD12_INTERN
#include "clifford12.h"
/// @endcond  




// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c






/*************************************************************************
*** Initialize a vector of the representation
*************************************************************************/




/**
@brief Construct vector of representation from pair ``(qs, v3)``

The function constructs a vector in the
representation \f$4096_x \otimes 24_x\f$ from a pair ``(qs, v3)``,
where ``qs`` the a quadratic state referred by ``pqs``, and ``v3`` is a
vector in the Leech Lattice mod 3 in **Leech lattice mod 3 encoding**.
The function stores the vector in the array ``rep`` of length 14
referred by ``p_rep``. The state ``qs`` must have shape (0, 12) or
(12, 0). 
*/
// %%EXPORT p
int32_t xsp2co1_rep_mod3_from_qs(qstate12_type *pqs, uint64_t v3, uint64_t *p_rep)
{
    int32_t res;
    uint32_t i;
    p_rep[0] = 0;
    if ((res = qstate12_reduce(pqs)) < 0) return res;
    if (pqs->ncols != 12 || pqs->nrows > 13)
        return ERR_QSTATE12_SHAPE_OP;
    if (pqs->shape1 != 0 && pqs->shape1 != 12)
        return ERR_QSTATE12_SHAPE_OP;
    if (pqs->nrows == 0 || ((v3 ^ (v3 >> 24)) & 0xffffffUL) == 0) {
        for (i = 1; i < 14; ++i) p_rep[i] = 0;
        return 0;
    }
    if (pqs->factor & 0x13) return ERR_QSTATE12_DOMAIN;
    uint64_t mask = ((ONE << (12 + pqs->nrows)) - 1) & 0x1ffefffULL; 
    uint64_t sign = ((pqs->factor>> 5) ^ (pqs->factor>> 2)) & 1;
    p_rep[0] = gen_leech3_reduce(v3 ^ (0 - sign));
    for (i = 0; i < pqs->nrows; ++i) 
        p_rep[i+1] = pqs->data[i] & mask;
    for (i = pqs->nrows; i < 13; ++i) p_rep[i+1] = 0;
    return 0;    
}


/**
@brief Construct vector of representation from pair \f$(x_g, v_g)\f$ 

The function constructs a vector in the
representation \f$4096_x \otimes 24_x\f$ from a pair ``(i, v3)``,
where ``i`` means the ``i``-th unit vector in the 
representation \f$4096_x\f$  and ``v3`` is a vector in the Leech
lattice mod 3 in **Leech lattice mod 3 encoding**. The function stores
the vector in the array ``rep`` of length 14 referred by ``p_rep``.

In the standard repesentation \f$\rho_3\f$ of the Monster the unit
vector at position ('Z', i, j) should be encoded with
parameters ``i = i``, ``v3 = 1 << j``; and the unit vector
at position ('Y', i, j) should be encoded with
parameters ``i = 2048 + i``, ``v3 = 1 << j``; for ``0 <= i < 2048``,
and ``0 <= j < 24``. 
*/
// %%EXPORT px
void xsp2co1_rep_mod3_unit_vector(uint32_t i, uint64_t v3, uint64_t *p_rep)
{
    uint32_t k;
    p_rep[0] = v3 = gen_leech3_reduce(v3);
    p_rep[1] = v3 ? (i & 0xfff) : 0;
    for (k = 2; k < 14; ++i) p_rep[k] = 0;
}





/*************************************************************************
*** Conversion from representation mod 3 to quadratic state
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 


/**
@brief Convert vector of representation to quadratic state

Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$ 
(mod 3) referred by ``p_rep``, as constructed by
function ``xsp2co1_rep_mod3_from_qs``. This function converts ``v``
to a pair ``(qs, v3)``, where ``qs`` is a quadratic state of
shape ``(12, 0)``, and ``v3`` is a vector in the Leech Lattice mod 3
in **Leech lattice mod 3 encoding**, such that ``v`` is the tensor
product of ``qs`` and ``v3``. The state ``qs`` is stored in the
structure referred by ``pqs``; and the vector ```v3`` is stored
in ``*p_v3``.

Caution:

The data pointer inside the structure ``qs`` points directly to the
data in the arrray referred by ``p_rep``. 
*/
static int32_t
xsp2co1_rep_mod3_as_qs(uint64_t *p_rep, qstate12_type *pqs, uint64_t *p_v3)
{
    int32_t res = qstate12_set_mem(pqs, p_rep + 1, 13); 
    if (res < 0) return res;
    pqs->maxrows = pqs->nrows = 13;
    pqs->ncols = 12;
    pqs->shape1 = 0;
    pqs->factor = 0;
    pqs->reduced = 0;
    if ((*p_v3 = gen_leech3_reduce(p_rep[0])) != 0) {
        while (pqs->nrows > 1 && pqs->data[pqs->nrows - 1] == 0) {
            --pqs->nrows;
        }
    } else pqs->nrows = 0;
    return 0;
}

/// @endcond 


/*************************************************************************
*** Multiply element of representation mod 3 by group element
*************************************************************************/



/**
@brief Multiply vector of representation with group element.

Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$
(mod 3) referred by ``p_rep``, as constructed by
function ``xsp2co1_rep_mod3_from_qs``. This function multiplies the
vector ``v`` with the element \f$g\f$ of the group \f$G_{x0}\f$ and
replaces the vector ``v`` by that product. Here the group
element \f$g\f$ is stored in the array referred by ``elem``
in **G_x0 representation**.
*/
// %%EXPORT px
int32_t xsp2co1_rep_mod3_mul_elem(uint64_t *p_rep, uint64_t *elem)
{
    int32_t res;
    int64_t res64;
    qstate12_type qs1, qs2;
    uint64_t v3, v;

    res = xsp2co1_rep_mod3_as_qs(p_rep, &qs1, &v3);
    if (res < 0) return res;
    res = xsp2co1_elem_to_qs_i(elem, &qs2);
    if (res < 0) return res;
    res = qstate12_matmul(&qs2, &qs1, &qs1);
    if (res < 0) return res;

    v = res64 = xsp2co1_map_short3(&qs2, STD_V3, elem[0], v3);
    if (res64 < 0) return (int32_t)(res64 | 0xffffffff80000000ULL);
    res = xsp2co1_rep_mod3_from_qs(&qs1, v, p_rep);
    return res;
}


/**
@brief Multiply vector of representation with word of group elements.

Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$
(mod 3) referred by ``p_rep``, as constructed by
function ``xsp2co1_rep_mod3_from_qs``. This function multiplies the
vector ``v`` with the element \f$g\f$ of the group \f$G_{x0}\f$ and
replaces the vector ``v`` by that product. Here the group
element \f$g\f$ given as a word in the generators of the
group \f$G_{x0}\f$ of length ``n``. That word  is stored in the
array ``a``, and each entry of ``a`` encodes a generator
of  \f$G_{x0}\f$ as described in file ``mmgroup_generators.h``.
*/
// %%EXPORT px
int32_t xsp2co1_rep_mod3_mul_word(uint64_t *p_rep, uint32_t *a, uint32_t n)
{
    int32_t res;
    qstate12_type qs;
    uint64_t v3;

    res = xsp2co1_rep_mod3_as_qs(p_rep, &qs, &v3);
    if (res < 0) return res;
    res = xsp2co1_mul_qs_v3_word(&qs, &v3, a, n, 0);
    if (res < 0) return res;
    if ((uint32_t)res != n) ERR_QSTATE12_GX0_TAG;
    res = xsp2co1_rep_mod3_from_qs(&qs, v3, p_rep);
    return res;
}


/*************************************************************************
*** Convert vector to representation in the mmgroup package
*************************************************************************/

/**
  @brief Store vector of representation in mm_op format

  Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$
  (mod 3) referred by ``p_rep``, as constructed by
  function ``xsp2co1_rep_mod3_from_qs``. 

  Let ``w`` be a vector in the standard repesentation \f$\rho_3\f$ of
  the Monster in the ``mm_op`` package, and let ``p_wz`` be a pointer
  to the position of the entry ('Z', 0, 0) of vector ``p_wz``. Then the
  function stores the vector ``v`` at the parts of vector ``w`` with
  tags ``Z`` and ``Y``.
  It returns 0 in case of success a negative value in case of failure.

  This works only if the data type ``uint_mmv_t`` used for storing
  vectors in \f$\rho_3\f$ is equal to ``uint64_t``.
*/
// %%EXPORT p
int32_t xsp2co1_rep_mod3_conv_mm_op(uint64_t *p_rep, uint64_t *p_wz)
{ 
    qstate12_type qs;
    uint64_t v3;
    int32_t status = xsp2co1_rep_mod3_as_qs(p_rep, &qs, &v3);
    uint32_t i, j; 
    if (status < 0) return status;
    for (i = 0; i < 4096; ++i) p_wz;
    if (v3 == 0) return 0;
    qstate12_support_type sup;
    status = qstate12_support_init(&qs, &sup);
    if (status < 0) return status;
    uint64_t w[2];
    w[0] = xsp2co1_to_vect_mod3(v3);
    w[1] = w[0] ^ 0xffffffffffffULL;

    for (i = 0; i < sup.n_batches; ++i) {
        status = qstate12_support_next(&sup);
        if (status < 0) return status;
        for (j = 0; j < sup.batchlength; ++j) {
            p_wz[sup.indices[j]] = w[sup.signs[j]];
        }
    }
    return 0;
}


/*************************************************************************
*** Scalar product
*************************************************************************/


/**
  @brief Scalar product of vector of representation with mm_op vector

  Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$
  (mod 3) referred by ``p_rep``, as constructed by
  function ``xsp2co1_rep_mod3_from_qs``. 

  Let ``w`` be a vector in the standard repesentation \f$\rho_3\f$ of
  the Monster in the ``mm_op`` package, and let ``p_wz`` be a pointer
  to the position of the entry ('Z', 0, 0) of vector ``p_wz``. Then the
  function returns the scalar product of the vectors ``v`` and ``w``.
  It returns a negative value in case of failure.

  This works only if the data type ``uint_mmv_t`` used for storing
  vectors in \f$\rho_3\f$ is equal to ``uint64_t``.
*/
// %%EXPORT p
int32_t xsp2co1_rep_mod3_scalprod_mm_op(uint64_t *p_rep, uint64_t *p_wz)
{ 
    qstate12_type qs;
    uint64_t v3;
    int32_t status = xsp2co1_rep_mod3_as_qs(p_rep, &qs, &v3);
    if (status < 0) return status;
    if (v3 == 0) return 0;
    uint64_t w = xsp2co1_to_vect_mod3(v3);
    qstate12_support_type sup;
    status = qstate12_support_init(&qs, &sup);
    if (status < 0) return status;
    uint64_t w_and;     // value to be 'and_ed' to a row of v 
    uint64_t w_xor[2];  // values to be 'xor_ed' to a row of v 
    w_and = (w ^ (w >> 1)) & 0x555555555555ULL;
    w_and ^= w_and << 1;
    w_xor[0] = w & 0xaaaaaaaaaaaaULL;
    w_xor[0] ^= w_xor[0] >> 1;
    w_xor[1] = ~w_xor[0] & 0xffffffffffffULL;
    uint64_t acc = 0;
    uint32_t i, j; 

    for (i = 0; i < sup.n_batches; ++i) {
        status = qstate12_support_next(&sup);
        if (status < 0) return status;
        for (j = 0; j < sup.batchlength; ++j) {
            acc += (p_wz[sup.indices[j]] ^ w_xor[sup.signs[j]]) & w_and;
        }
    }
    return (int32_t)(acc % 3);
}


/*************************************************************************
*** Find a nonzero entry
*************************************************************************/

/**
  @brief Find a nonzero entry of a vector

  Let ``v`` be the vector in the representation \f$4096_x \otimes 24_x\f$
  (mod 3) referred by ``p_rep``, as constructed by
  function ``xsp2co1_rep_mod3_from_qs``. 

  The function returns index ``(i, j)`` and value ``x`` of a nonzero
  entry of the vector if present. Here index ``(i, j)`` denotes the
  unit vector at position ('Z', i, j) if ``0 < i < 2048``, and the
  unit vector at position ('Y', i - 2048, j) if ``2048 < i < 4096``.
  A nonzero value ``x`` is always equal to 1 or 2.
 
  In case of success the function returns the triple ``(i, j, x)`` in
  the form:

  ``(0x6 << 25) + (i << 14) + (j << 8) + x`` ,

  which is compatible with the *sparse representation* of a vector
  in  \f$\rho_3 \f$ in the ``mmgroup.mm_op`` package.
    
  In case of failure (e.g. if ``v`` is zero) the function returns
  a negative value.

  This function is useful for determining the sign of a 
  vector ``v`` that is already known up to sign.
*/
// %%EXPORT p
int32_t xsp2co1_rep_mod3_find_nonzero(uint64_t *p_rep)
{
    uint64_t supp = (p_rep[0] ^ (p_rep[0] >> 24)) & 0xffffffUL;
    if (supp == 0) return -1;
    uint32_t j = mat24_lsbit24((uint32_t)supp);
    uint32_t i = (uint32_t)(p_rep[1] & 0xfff);
    uint32_t x = 1 + (uint32_t)((p_rep[0] >> (24 + j)) & 1);
    return (0x6 << 25) + (i << 14) + (j << 8) + x;
}





//  %%GEN h
/// @endcond  
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




