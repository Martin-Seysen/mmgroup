// %%COMMENT
// For this module we refer to the section
// 'Computation in the Clifford group' in the guide, see
// https://mmgroup.readthedocs.io/en/latest/





/*************************************************************************
** External references 
*************************************************************************/

#include <string.h>
#define CLIFFORD12_INTERN
#include "clifford12.h"

// %%EXPORT_KWD CLIFFORD12_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



/*************************************************************************
*** Construction of a state matrix
*************************************************************************/




// %%EXPORT p
int32_t qstate12_std_matrix(qstate12_type *pqs, uint32_t rows, uint32_t cols, uint32_t rk) 
// Create a standard matrix (as a C-strided array) with 'rows' rows,
// 'cols' columns, of rank 2**rk. Considering row operations as inputs 
// and column peration as outputs, we connect the first 'rk' input 
// qubits to the first 'rk' output qubits.  Note that the distinction 
// between input and output qubits is out of the scope of this module. 
// So we just connect input qubit j (corresponding to column j + cols
// of submatrix A) to output qubit j (corresponding to column j of 
// submatrix A). 0 <= rk < min(nows, cols) must hold.
{
    uint64_t mask = ((ONE << cols) + ONE) << (rk - 1);
    uint32_t i;

    pqs->nrows = rk + 1;
    pqs->ncols = rows + cols;
    pqs->shape1 =  cols;
    pqs->factor = 0;
    pqs->data[0] = 0;
    if (bad_state(pqs)) return ERR_QSTATE12_TOOLARGE;
    if (rk > rows || rk > cols ) {
        pqs->nrows = pqs->ncols = 0;
        return ERR_QSTATE12_QUBIT_INDEX;
    }
    for (i = 1; i < pqs->nrows; ++i) {
        pqs->data[i] = mask; mask >>= 1;
    } 
    return 0;  
}




// %%EXPORT p
int32_t qstate12_unit_matrix(qstate12_type *pqs, uint32_t nqb) 
//  Set the state ``qs`` referred by ``pqs`` to a 
// ``2**nqb`` times ``2**nqb`` unit matrix
{  
    return  qstate12_std_matrix(pqs, nqb, nqb, nqb);
}


// %%EXPORT p
int32_t qstate12_monomial_column_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t *pa) 
// Set the state ``qs`` referred by ``pqs`` to a real monomial 
// ``2**nqb`` times ``2**nqb`` transformation matrix ``T`` which 
// is monomial in  the sense that each column contains exactly 
// one nonzero entry ``1`` or ``-1``. So left multiplication  
// with ``T`` maps maps unit vectors to (possibly negated) unit  
// vectors. It transforms a  state ``|v>`` of ``nqb`` input bits 
// to a state ``T * |v>`` of ``nqb`` output qubits. Here
// ``|v>`` is considered as a column vector.
//
// ``pa`` refers to an array a of integers ``a[i]`` of length 
// ``nqb + 1``. Each integer ``a[i]`` is interpreted as a bit 
// field  via its binary  representation. So ``a[i,j]`` means 
// ``(a[i] >> j) & 1``. ``a[i, j1:j2]`` means the bit field  
// ``a[i,j1],...,a[i,j2-1]``.
//
// For any bit vector ``v`` of length ``nqb`` let ``|v>`` be the 
// unit vector with index ``v``. For any bit vector ``v`` of 
// length ``nqb + 1`` let ``|v>`` be the (possibly negated) unit 
// vector ``(-1)**v[nqb] * |v[0:nqb]>``.  ``|v1 ^ v2>`` and 
// ``|1 << v1>`` are defined via the corrresponding operators 
// ``<<`` and ``^`` in C.
//
// Then ``T``  maps
//
//   * ``|0>``     to  ``|a[0, 0:nqb+1]>``
//
//   * ``|1 << i>`` to  ``|a[0, 0:nqb+1] ^ a[i+1, 0:nqb+1]>``
//
// ``T`` maps unit vectors to (possibly negated) unit vectors, 
// so ``T(v)`` is well defined by ``|T(v)> = T(|v>)`` for a bit 
// field ``v`` of length ``nqb + 1``. We have
//
//   * ``|T(v1 ^ v2)> = (-1)**Q(v1,v2) * |T(v1) ^ T(v2) ^ T(0)>``,
//
// for bit fields ``v1, v2`` of length ``nqb + 1`` and an 
// alternating bilinear form ``Q`` depending on the first ``nqb`` 
// bits of ``v1`` and ``v2`` only. Thus ``T`` is  defined by the 
// above equation and ``Q``. The bilinear form ``Q`` is defined by:
//  
//   * ``Q(v1, v2) = Q(v2, v1),  Q(v1, v1) = 0``,  and
//
//   * ``Q(1 << i, 1 << j) =  m[i + 1, j + nqb + 1]``,  
//     for ``0 <= j < i < nqb``.
//
{
    uint64_t *m = pqs->data, mask1;
    uint_fast32_t i;
    int32_t factor = ((pa[0] >> nqb) & 1) << 2;
    pqs->nrows = nqb + 1;
    pqs->ncols = nqb << 1;
    if (bad_state(pqs)) return ERR_QSTATE12_TOOLARGE;
 
    mask1 = (ONE << nqb) - 1;
    m[0] = (pa[0] & mask1) << nqb;
    for (i = 1; i <= nqb; ++i) {
        mask1 += mask1 + 1;
        m[i] = ((ONE << (i - 1)) | ((pa[i] & mask1) << nqb));
    } 
    qstate12_set(pqs, 2*nqb, nqb+1, m, 1);
    pqs->shape1 =  nqb;
    pqs->factor = factor;
    return 0; 
}

// %%EXPORT p
int32_t qstate12_monomial_row_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t *pa) 
// Similar to qstate12_monomial_column_matrix; but we create a 
// matrix ``T`` which is monomial in  the sense that each row
// contains exactly  one nonzero entry ``1`` or ``-1``.
// ``qstate12_monomial_row_matrix(*pqs, nqb, *pa)`` 
// creates the transposed matrix of  
// ``qstate12_monomial_column_matrix(*pqs, nqb, *pa)`` 
{
    int32_t res = qstate12_monomial_column_matrix(pqs, nqb, pa); 
    if (res < 0) return res;
    return qstate12_rot_bits(pqs, nqb, 2*nqb, 0);
}


/*************************************************************************
*** Reshaping a quadratic state matrices
*************************************************************************/

// %%EXPORT p
int32_t qstate12_mat_reshape(qstate12_type *pqs, int32_t rows, int32_t cols)
// Reshape the matrix referred by ``pqs`` to the shape ``(rows, cols)``.
// If ``rows`` or ``cols`` is -1, the it is calculated from the old
// shape of the matrix. If both, ``rows`` and ``cols``, is -1 then
// ``rows`` is set to ``0`` and ``cols`` is calculated.
{
    if (bad_state(pqs)) return ERR_QSTATE12_INCONSISTENT;
    if (cols == -1) {
        if (rows == -1) rows = 0;
        cols = (int32_t)pqs->ncols - rows;
    } else if (rows == -1) {
        rows = (int32_t)pqs->ncols - cols;
    }
    if (rows < 0 || cols < 0 || (uint32_t)(rows + cols) !=  pqs->ncols)
        return ERR_QSTATE12_SHAPE_OP;
    pqs->shape1 = cols;
    return 0;
}

/*************************************************************************
*** Transposition of quadratic state matrices
*************************************************************************/

// %%EXPORT p
int32_t qstate12_mat_t(qstate12_type *pqs) 
// The quadratic state matrix qs of shape (pqs->ncols - nqb, nqb)
// referred by pqs is transposed in place.
// The result is not reduced.
{   
    uint32_t nqb = pqs->ncols - pqs->shape1;
    pqs->shape1 = nqb;
    return qstate12_rot_bits(pqs, nqb, pqs->ncols, 0);
}

/*************************************************************************
*** 'Multiplying' states and matrices of states
*************************************************************************/




static inline void
qstate12_copy_row(uint64_t *m, uint32_t ncols, uint32_t nrows, uint32_t i1, uint32_t i2)
// Copy row ``i1`` of the bit matrix m referred to row ``i2``. 
// ``i2 <= i1`` must hold. We interpret ``m`` as a pair ``A,Q``
// of adjacent matrices of a state so that ``A`` has ``ncols``
// columns. We also adjust the quadratic form ``Q``
{ 
    uint64_t mask; 
    uint_fast32_t k, sh;
    if (i2 < i1) {
        m[i2] = m[i1]; 
        mask = ONE <<  (ncols + i2);
        sh = i1 - i2;
        for (k = 0; k < nrows; ++k)  {
           m[k] = (m[k] & ~mask) | ((m[k] >> sh) & mask);
        }
    }
} 






// %%EXPORT p
int32_t qstate12_prep_mul(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb)
// Auxiliary low-level function for qstate12_product().
// Prepare the states qs1 and qs2 referred by pqs1 and pqs2 for 
// multiplication. Here the first nqb columns of qs1 and qs2 are to 
// be multiplieded. The function returns a number 'row_pos', so that, 
// after preparation, the first nqb columns of submatrices A1 and A2 
// of the matrices M1 and M2corresponding to qs1 and qs2 will be equal 
// in the following sense: 
// A1[i,j] = A2[i,j]       for i <  'row_pos', j < 'nqb' ,   (QS1)
// A1[i,j] = A2[i,j] = 0   for i >= 'row_pos', j < 'nqb' ,   (QS2)
// and matrices A1 and A2 both have rank 'row_pos' - 1, when excluding
// row 0 of the two matrices.
// Some rows of A1 or A2 may be deleted to achieve this situation.
// The result of the multiplication of the states qs1 and qs2 over 
// the first nqb columns of is not changed by this operation.
// Apart from this assertion, both states are changed, and they may
// have less rows than before. They may even be changed to zero, if the 
// result of the multiplication is zero.
//
// The algorithm used here is explained in the guide in section
// 'Multiplication of quadratic mappings'. 
// In the notation in that section the algorithm computes
// states qs1', qs2' with  (qs1' (*) qs2')_n = (qs1 (*) qs2)_n 
// where n = nqb, and (*) denotes the '\odot' operation defined in
// section 'Products and tensor products of quadratic mappings'
// of the guide.
//
// pqs1->shape1 and pqs2->shape1 are ignored.
{
    uint_fast32_t i1, i2, n_deleted = 0, ii;
    uint_fast32_t row_pos = 1, row_pos1 = 1, row_pos2 = 1;
    uint_fast32_t col_pos, col1, col2;
    uint64_t v, deleted = 0;
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data;
    int32_t res;

    // check and reduce input matrices
    // printf("<prep_mul>");
    if ((res = qstate12_echelonize(pqs1)) < 0) return res;
    if ((res = qstate12_echelonize(pqs2)) < 0) return res;
    if (nqb > pqs1->ncols || nqb > pqs2->ncols) 
        return ERR_QSTATE12_QUBIT_INDEX;
    // 
    if (pqs1->nrows == 0 || pqs2->nrows == 0)  {
        return  pqs1->nrows = pqs2->nrows = 0;
    }
    // Equalize the highest 'nqb' columns of m1 and m2
    for (col_pos = 1; col_pos <= nqb; ++col_pos) {
        col1 = pqs1->ncols - col_pos; col2 = pqs2->ncols - col_pos; 
        // pivot with column col1, col2, advance row_pos if success
        i1 = row_pos1 < pqs1->nrows ? (m1[row_pos1] >> col1) & 1 : 0;
        i2 = row_pos2 < pqs2->nrows ? (m2[row_pos2] >> col2) & 1 : 0;
        v = 0;
        for (ii = 0; ii < row_pos; ++ii) 
            v |= (((m1[ii] >> col1) ^ (m2[ii] >> col2)) & ONE) << ii;
        if (i1) {
            if (i2) {
                qstate12_copy_row(m1, pqs1->ncols, pqs1->nrows,
                                               row_pos1++, row_pos);
                qstate12_copy_row(m2, pqs2->ncols, pqs2->nrows,
                                               row_pos2++, row_pos);
                qstate12_pivot(pqs2, row_pos++, v);
            } else {          
                qstate12_pivot(pqs1, row_pos1++, v);
            }
        } else {
            if (i2) {
                qstate12_pivot(pqs2, row_pos2++, v);
            } else {
                int32_t i = row_pos-1;
                while (i >= 0 && ((ONE << i) & v) == 0) --i;
                if (i > 0) {
                    qstate12_pivot(pqs1, i, v);
                    qstate12_pivot(pqs2, i, v);
                    deleted |= ONE << i; ++n_deleted;
                    m1[i] = m2[i] = 0;
                } else if (i == 0) {
                    return  pqs1->nrows = pqs2->nrows = 0;  
                }                
            }
        } 
    }

    v = deleted + (ONE << row_pos1) - (ONE << row_pos);
    if ((res = qstate12_del_rows(pqs1, v)) < 0) return res;
    v = deleted + (ONE << row_pos2) - (ONE << row_pos);
    if ((res = qstate12_del_rows(pqs2, v)) < 0) return res;
    row_pos -= n_deleted;
  
    return row_pos ;
}



// %%EXPORT
int32_t qstate12_mul_elements(qstate12_type *pqs1, qstate12_type *pqs2, uint64_t mask)
// Auxiliary low-level function for qstate12_product().
// For the submatrices ``A1, Q1`` and ``A2, Q2`` of the matrices
// ``M1`` and ``M2`` the states rreferred by ``qs1`` and ``qs2``
// we put ``A1 = A1 + A2, Q1 = Q1 + Q2``.
// The pair ``(A2, Q2)`` is masked with the ``mask`` before
// it is added. A carry in the adiition of diagonal entries
// of ``Q1`` nd ``Q2`` is processed correctly.
// The number of rows and columns in both states must be equal. 
// pqs1->shape1 and pqs2->shape1 are ignored.
{
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data, c = ONE << pqs1->ncols;
    uint32_t k;
    if (bad_state(pqs1) || bad_state(pqs2)) return ERR_QSTATE12_INCONSISTENT;
    if (pqs2->nrows != pqs1->nrows || pqs2->ncols != pqs1->ncols) return -901; 
    m1[0] ^= m2[0] & mask;
    for (k = 1; k < pqs1->nrows; ++k)  {
       int64_t m2m = m2[k] & mask;
       m1[0] ^= m1[k] & m2m & (c << k);
       m1[k] ^= m2m;
    }
    if (ADD_FACTOR_OVERFLOW(pqs1->factor >> 4, pqs2->factor >> 4))
        return ERR_QSTATE12_SCALAR_OVFL;
    pqs1->factor = ADD_FACTORS(pqs1->factor, pqs2->factor);
    return 0;
}



static int32_t qs_product(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb, uint32_t nc)
// Workhorse for the exported function qstate12_product().
// Same operation as function qstate12_product(), but
// *pqs2 is destroyed.
{
    int_fast32_t row_pos, rows1, rows2, cols1, cols2, res;
    
    row_pos = qstate12_prep_mul(pqs1, pqs2, nqb);
    if (row_pos < 0) return row_pos; // Then row_pos is an error code
    if (nc > nqb) return ERR_QSTATE12_QUBIT_INDEX;

    if ((res = qstate12_sum_cols(pqs1, pqs1->ncols - nc, nc)) < 0) 
        return res; 
    if ((res = qstate12_sum_cols(pqs2, pqs2->ncols - nc, nc)) < 0) 
        return res; 
    nqb -= nc;
    
    cols1 = pqs1->ncols; cols2 = pqs2->ncols;
    res = qstate12_extend_zero(pqs1, 0, cols2 - nqb);
    if (res < 0) return res;
    res = qstate12_extend_zero(pqs2, cols2 - nqb, cols1 - nqb); 
    if (res < 0) return res;
 
    pqs1->shape1 = 0;  
    if (pqs1->nrows == 0 || pqs2->nrows == 0)
        return pqs1->nrows = pqs1->factor = 0; 

    rows1 = pqs1->nrows - row_pos;  rows2 = pqs2->nrows - row_pos;
    res = qstate12_insert_rows(pqs1, row_pos, rows2);
    if (res < 0) return res;
    res = qstate12_insert_rows(pqs2, pqs2->nrows, rows1); 
    if (res < 0) return res;
    res = qstate12_mul_elements(pqs1, pqs2, 
        ~(((ONE << nqb) - 1) << (pqs1->ncols - nqb))); 
    if (res < 0) return res;
    return qstate12_reduce(pqs1);
}


// %%EXPORT p
int32_t qstate12_product(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb, uint32_t nc)
// Compute a certain product ``qs3`` of the states ``qs1`` 
// and ``qs2`` referred by ``pqs1`` and ``pqs2``. 
// Let ``n1 = pqs1->ncols,  n2 = pqs2->ncols``.
// Put ``qs1a =  qstate12_extend(qs, n1, n2-nqb)``,
// ``qs2a =  qstate12_extend(qs, nqb, n1-nqb)``. Then ``qs1a``
// and ``qs2a`` are complex functions on ``(nn1 + nn2 - nqb)``
// bits. Let ``qs3a`` be the complex function which is the 
// product of the functions  ``qs1a`` and ``qs2a``. Then we 
// have ``qs3 = qstate12_sum_cols(qs23, 0, nc)``.
// The result ``qs3`` is computed in the state referred by 
// ``qs1``. It is reduced. ``qs2`` is not changed. 
//
// E.g. ``qstate12_product(pqs1, pqs2, nc, nc)`` is the tensor 
// contraction over the first ``nc`` qubits of ``qs1`` and 
// ``qs2``. ``In case pqs1->ncols = pqs2->ncols = n``, the 
// function ``qstate12_product(pqs1, pqs2, n, 0)`` returns the 
// product of ``qs1`` and ``qs2`` (considered as functions); 
// and ``qstate12_product(pqs1, pqs2, n, n)`` returns the scalar
// product of ``qs1`` and ``qs2`` (considered as vectors).
//
// ``qstate12_product(pqs1, pqs2, n, 0)`` corresponds to the 
// function ``(qs1 (*) qs2)_n``  where ``(*)`` denotes the 
// ``'\odot'`` operation defined in section 
// 'Products and tensor products of quadratic mappings'
// of the guide.
//
// pqs1->shape1 is set to 0. The user should  set pqs1->shape1 
// to a reasonable value. 
{
    int_fast32_t res;
    qstate12_type qs1, qs2;
    uint64_t qs1_data[MAXROWS], qs2_data[MAXROWS];
    
    // Create temporary copy of *pqs1 and *pqs2
    res = qstate12_copy_alloc(pqs1, &qs1, qs1_data, MAXROWS);
    if (res < 0) return res;
    res = qstate12_copy_alloc(pqs2, &qs2, qs2_data, MAXROWS);
    if (res < 0) return res;
    
    res =  qs_product(&qs1, &qs2, nqb, nc);
    if (res < 0) return res;
    return qstate12_copy(&qs1, pqs1);
}





/*************************************************************************
*** Matrix multiplication
*************************************************************************/


// %%EXPORT p
int32_t qstate12_matmul(qstate12_type *pqs1, qstate12_type *pqs2)
// Performs a matrix multiplication.
// Given a state ``qs_i`` with ``qs_i->ncols = m_i + n_i`` we may
// interpret ``qs_i`` as an ``2**m_i`` times ``2**n_i`` matrix, 
// where the ``2**m_i`` rows of the matrix correspond to the
// higher ``m_i`` qubits and the ``2**n_i`` columns corrspond  
// to the lower ``n_i`` qubits. The value ``n_i`` is given by
// ``qs_i->shape1``.
// Let ``qs_1, qs_2`` be the quadratic state matrices referred by 
// ``pqs1, pqs_2``.
//
// The function computes the matrix product ``m3 = m1 @ m2`` as 
// an  ``2**m_1`` times ``2**n_2`` matrix and stores matrix 
// ``m3`` in ``qs_1``.  ``qs_2`` is not changed.
{
    int32_t res;
    uint32_t nqb = pqs1->shape1, cols = pqs2->shape1; 
    qstate12_type qs1, qs2;
    uint64_t qs1_data[MAXROWS], qs2_data[MAXROWS];

    if bad_state(pqs1) return ERR_QSTATE12_INCONSISTENT;
    if (pqs2->ncols - pqs2->shape1 != nqb) return ERR_QSTATE12_SHAPE_OP;
    
    // Create temporary copy of *pqs1 and *pqs2
    res = qstate12_copy_alloc(pqs1, &qs1, qs1_data, MAXROWS);
    if (res < 0) return res;
    res = qstate12_copy_alloc(pqs2, &qs2, qs2_data, MAXROWS);
    if (res < 0) return res;

    res = qstate12_rot_bits(&qs1, -nqb, qs1.ncols, 0);
    if (res < 0) return res;
    res = qstate12_product(&qs1, &qs2, nqb, nqb);
    if (res < 0) return res;
    qs1.shape1 = cols;    
    return qstate12_copy(&qs1, pqs1);
}




/*************************************************************************
*** Creating and checking matrices in the Pauli group
*************************************************************************/

static uint64_t bit_rev(uint32_t length, uint64_t n)
// Reverse lower ``length`` bit of interger ``n``.
{
    uint32_t i;
    uint64_t v = 0;
    for (i = 0; i < length; ++i) 
        v |= ((n >> (length - i - 1)) & ONE) << i;
    return v;
}


// %%EXPORT p
int32_t qstate12_pauli_vector(qstate12_type *pqs, uint64_t *pv)
{
    int32_t res;
    uint_fast32_t i = 1, nqb;
    uint64_t *m = pqs->data, w = 0, mask;
    
    if ((res = qstate12_reduce(pqs)) < 0) return res;
    nqb = pqs->shape1;
    mask = (ONE + (ONE << nqb)) << (nqb - 1);
    if (pqs->ncols != nqb << 1 || pqs->nrows != nqb + 1) 
        return ERR_QSTATE12_PAULI_GROUP;
    if (pqs->factor & -0xf) return ERR_QSTATE12_PAULI_GROUP; 
    for (i = 0; i < nqb; ++ i) {
        w |=  (m[i+1] ^ mask);
        mask >>= 1;
    }
    mask = (((ONE << pqs->nrows) - 1) << pqs->ncols) - 1;
    if (w & mask) return ERR_QSTATE12_PAULI_GROUP;
    mask = (ONE << nqb) - 1;
    w = bit_rev(nqb, m[0] >> (pqs->ncols + 1));
    w |= m[0] & (mask << nqb);
    w |= (uint64_t)((pqs->factor >> 2) & ONE) << pqs->ncols;    
    w |= (uint64_t)((pqs->factor >> 1) & ONE) << (pqs->ncols + 1);    
    *pv = w;
    return 0;
}



// %%EXPORT p
uint64_t qstate12_pauli_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t v)
{
    int32_t res;
    uint64_t *m = pqs->data, mask = (ONE << nqb) - 1;
    if ((res = qstate12_std_matrix(pqs, nqb, nqb, nqb)) < 0) return res;
    m[0] |= bit_rev(nqb, v) << (2 * nqb + 1); 
    m[0] |= v & (mask << nqb);
    v >>= 2*nqb;
    pqs->factor |= (v & 1) << 2;    
    pqs->factor |= v & 2;    
    return 0;
}


/*************************************************************************
*** Multiplication and exponentiation in the Pauli group
*************************************************************************/

// %%EXPORT p
uint64_t qstate12_pauli_vector_mul(uint32_t nqb, uint64_t v1, uint64_t v2)
// Yet to be documented!!
{
    uint64_t s;
    if (nqb >= MAXCOLS/2) return v1 ^ v2; 
    s = (v1 & (v2 >> nqb)) & ((ONE << nqb) - 1);
    s ^= ((v1 & v2) >> (2*nqb + 1)) & 1;
    s ^= s >> 32; s ^= s >> 16; s ^= s >> 8; s ^= s >> 4;
    s = (0x6996 >> (s & 0x0f)) & 1;
    return (v1 ^ v2 ^ (s << (nqb << 1))) & (((4*ONE) << (2*nqb)) - 1);
}

// %%EXPORT p
uint64_t qstate12_pauli_vector_exp(uint32_t nqb, uint64_t v, uint32_t e)
// Yet to be documented!!
{
    uint64_t s = 0;
    if (e & 2 && nqb < MAXCOLS/2) {
       s = (v & (v >> nqb)) & ((ONE << nqb) - 1);
       s ^= (v >> (2*nqb + 1)) & 1;
       s ^= s >> 32; s ^= s >> 16; s ^= s >> 8; s ^= s >> 4;
       s = (0x6996 >> (s & 0x0f)) & 1;
       s <<= (nqb << 1);    
    } 
    s ^= (0 - (e & ONE))  & v;
    return  s & (((4*ONE) << (2*nqb)) - 1);
}



/*************************************************************************
*** Special reduction for matrices
*************************************************************************/




static inline 
int32_t qstate12_find_masked_pivot(uint64_t *m, uint32_t nrows, uint32_t j, uint64_t mask)
// Auxiliary low-level function for ``qstate12_reduce_matrix()``.
// Let ``m`` be a bit matrix with ``nrows`` rows.  On input ``j``, 
// the function returns the highest row index ``i`` such that
// ``A[i,j] = 1.`` and bit ``i`` of ``mask`` is cleared. 
//  The function returns ``-1`` if all bits ``A[i1,j]`` are zero.
{
    mask = ~mask; 
    int_fast32_t i = nrows - 1; 

    // find the  highest row index i such that m[i,j] = 1. 
    while (i >= 0  && (((m[i] >> j) & (mask >> i) & 1) == 0)) -- i;
    return i;
}



// %%EXPORT p
int32_t qstate12_reduce_matrix(qstate12_type *pqs, uint8_t *row_table)
// TODO: Yet to be documented!!
{
    int_fast32_t res, i;
    uint_fast32_t  j, fst_row, nqb;
    uint64_t kernel, *m = pqs->data, v;
    if ((res = qstate12_reduce(pqs)) < 0) return res;
    nqb = pqs->shape1; 
    if ((res = qstate12_row_table(pqs, row_table)) < 0) return res;
    if (nqb > pqs->ncols) return ERR_QSTATE12_QUBIT_INDEX;
    if (pqs->nrows == 0) return 0;
    
    fst_row = pqs->nrows;
    v = (ONE << nqb) - 1;
    for (i = pqs->nrows - 1; i > 0; --i) {
        row_table[pqs->ncols + i] = QSTATE12_UNDEF_ROW;
        if ((m[i] & v) == 0) fst_row = i;
    }    
    kernel = 0 - (ONE << fst_row);
    row_table[pqs->ncols] = (uint8_t)fst_row;
        
    for (j = nqb; j < pqs->ncols; ++j) {
        if (row_table[j] == QSTATE12_UNDEF_ROW) {
            i =  qstate12_find_masked_pivot(m, fst_row, j, kernel);
            if (i > 0) {
               kernel |= ONE << i;
               qstate12_pivot(pqs, i, qstate12_get_col(m,j, i));
               row_table[j] = (uint8_t)i;
               row_table[pqs->ncols + i] = (uint8_t)j;
            }   
        }
    }
    
    // Pivot Q part of state data
    // TODO: check it!!!!!
    for (j = pqs->nrows -1; j >= fst_row; --j) {
        i = qstate12_find_masked_pivot(m, fst_row, j+ pqs->ncols, kernel);
        // if i >= 0 then i is the higest row with Q[i,j] = 1
        if (i > 0) {
            // set v to column (or row) j of matrix Q
            v = ((m[j] >> pqs->ncols) & (0-2ULL)) +
                 ((m[0] >> (j + pqs->ncols)) & 1);
            v &= ~kernel;     
            qstate12_pivot(pqs, i, v);
            // Set v to  column (or row) i of matrix Q
            v = m[i] >> pqs->ncols;
            v &= 0 - (ONE <<  fst_row);
            qstate12_pivot(pqs, j, v);
            row_table[pqs->ncols + j] = (uint8_t)i;
        }
    }    
    return 0;
    
}

/*************************************************************************
*** Computing the rank of a matrix
*************************************************************************/

// %%EXPORT p
int32_t qstate12_mat_lb_rank(qstate12_type *pqs) 
// Let qs be the quadratic state matrix of shape (pqs->ncols - nqb, nqb)
// referred by pqs. The function returns the binary logarithm of
// the rank of the matrix. It returns -1 if qs is the zero matrix.
// Matrix qs is reduced with function qstate12_reduce_matrix().
{
    uint8_t row_table[MAXCOLS+4];
    int32_t res, rk = 0;
    uint_fast32_t i, fst_row, nqb; 
    res = qstate12_reduce_matrix(pqs, row_table);
    nqb = pqs->shape1; 
    if (res < 0) return res;
    if (pqs->nrows == 0) return -1;
    fst_row = row_table[pqs->ncols];
    for (i = nqb; i < pqs->ncols; ++i)  
        rk += row_table[i] < fst_row;
    for (i = pqs->ncols + fst_row; i < pqs->ncols + pqs->nrows; ++i)
        rk += row_table[i] != QSTATE12_UNDEF_ROW;
    return rk;
}


/*************************************************************************
*** Matrix inversion
*************************************************************************/

// %%EXPORT p
int32_t qstate12_mat_inv(qstate12_type *pqs) 
// Let qs be the quadratic state matrix of shape (pqs->ncols - nqb, nqb)
// referred by pqs. The function inverts the matrix qs in place,
// It returns -11 if qs is not invertible.
// The result is reduced with function qstate12_reduce_matrix().
{
    int32_t rk = 0, f;
    uint_fast32_t nqb = pqs->shape1; 
    qstate12_mat_t(pqs);
    qstate12_conjugate(pqs);
    rk =  qstate12_mat_lb_rank(pqs); 
    if (rk < -1) return rk;
    if (2 * nqb != pqs->ncols || rk != (int32_t)nqb) 
        return ERR_QSTATE12_MATRIX_INV;
    f = (pqs->factor & -((int32_t)16L)) >> 4;
    f += pqs->nrows - 1;
    f -= pqs->ncols - nqb;
    return qstate12_mul_scalar(pqs, -2*f, 0);
}


/*************************************************************************
*** Bit matrix transposition
*************************************************************************/


// %%EXPORT p
int32_t qstate12_bit_matrix_t(uint64_t *m1, uint32_t i, uint32_t j, uint64_t *m2)
// Here ``m1`` is an ``i`` times ``j`` bit matrix. The function
// write the transposed matrix of ``m1`` to ``m2``.
{
    uint64_t v;
    uint32_t i1, j1;
    if (i > 64 || j > 64) return -5;
    for (j1 = 0; j1 < j; ++j1) {
        v = 0;
        for (i1 = 0; i1 < i; ++i1) v |= ((m1[i1] >> j1) & 1) << i1;
        m2[j1] = v;
    }
    return 0;
}


/*************************************************************************
*** Conjugation of Pauli vector with a  matrix
*************************************************************************/


// %%EXPORT p
int32_t qstate12_pauli_conjugate(qstate12_type *pqs, uint32_t n, uint64_t *pv)
// TODO: Yet to be documented!!
{
    int_fast32_t res, js;
    uint_fast32_t i, j, rank = 0, fst_row, sh, j0, j1, nqb;
    uint8_t row_table[MAXCOLS];
    uint64_t *m = pqs->data, m0, v, w, f,  mask;
    uint64_t v_out, a_t[MAXCOLS/3+1]; 
    
    res = qstate12_reduce_matrix(pqs, row_table);
    nqb = pqs->shape1;
    if (res < 0) return res;
    
    // Check that rank of matrix is equal to nqb
    fst_row = row_table[pqs->ncols];
    for (j = nqb; j <= nqb << 1; ++j) rank += row_table[j] < fst_row;
    for (j = pqs->ncols + fst_row; j < pqs->ncols + pqs->nrows; ++j) 
        rank +=  row_table[j] != QSTATE12_UNDEF_ROW;
    if (rank != nqb) return -102;
    if (nqb == 0) return 0;
    res = qstate12_bit_matrix_t(m, nqb + 1, nqb, a_t);
    if (res < 0) return res;
    for (j = 0; j < nqb; ++j) a_t[j] <<= pqs->ncols;
    
    j0 = pqs->ncols + fst_row; j1 = pqs->ncols + pqs->nrows;
    mask = (ONE << j1) - (ONE << j0) + (ONE << pqs->ncols) - (ONE << nqb);
    if  (m[0] & mask) return -90; // internal error
   
    while (n--) {
        v = *pv;
        mask = (ONE << nqb) - 1;
        m0 = m[0];
        f = 0x3120 >> (((v >> (pqs->ncols)) & 3) << 2);
        if ((res = qstate12_mul_Av(pqs, (v & mask) << nqb, &w)) < 0) 
            return res; 
        f += w << 1;
        m0 ^= w << pqs->ncols;
        m0 ^= v & (mask << nqb);
        
        for (j = nqb; j < pqs->ncols; ++j) if ((m0 >> j) & 1) {
            i = row_table[j];
            sh = pqs->ncols + i;
            // factor *= exp(pi/2 * sqrt(-1) * k), k = 2 * Q[0,i] + Q[i,i]
            // see guide, section 'Implementation of quadratic mappings'
            f += ((m0 >> sh) & 1) << 1;
            f += (m[i] >> sh) & 1;
            // Add row i to row 0
            if (((m[i] >> j) & 1) == 0) return -91; // internal error
            m0 ^= m[i];
        }
        j0 = pqs->ncols + fst_row; j1 = pqs->ncols + pqs->nrows;
        for (j = j0; j < j1; ++j) if ((m0 >> j) & 1) {
            i = row_table[j];
            sh = pqs->ncols + i;
            // factor *= exp(pi/2 * sqrt(-1) * k), k = 2 * Q[0,i] + Q[i,i]
            // see guide, section 'Implementation of quadratic mappings'
            f += ((m0 >> sh) & 1) << 1;
            f += (m[i] >> sh) & 1;
            // Add row i to row 0
            if (((m[i] >> j) & 1) == 0) return -92; // internal error
            m0 ^= m[i];
        }
        mask = (ONE << j1) - (ONE << j0) + (ONE << pqs->ncols) - (ONE << nqb);
        if  (m0 & mask) return -93; // internal error
    
        v_out = 0;
        
        // adjust z part of output Pauli matrix v_out
        mask = (2*ONE) << pqs->ncols;
        m0 &= ~(ONE << pqs->ncols);
        for (js = nqb - 1; js >= 0; --js) {
            if (((m[0] ^ m0) >> js) & mask) {
                v_out ^= ONE << js;
                if (((a_t[js] >> js) & mask) == 0) return -94; // internal error
                f += (m0 >> js) << 1; 
                m0 ^= a_t[js];
            }
        }
        
        mask = ((ONE << nqb) - 1) << (pqs->ncols + 1);
        if ((m[0] ^ m0) & mask)  return -95; // internal error
        
        // adjust x part of output Pauli matrix
        v_out ^= ((m0 ^ m[0]) & ((ONE << nqb) - 1)) << nqb;
      
        // adjust Factor of output Pauli matrix
        f = (0x3120 >> ((f & 3) << 2)) & 3;
        v_out ^= f << pqs->ncols;
        *pv++ = v_out;
    }
    return 0;
}






// %%GEN ch
#ifdef __cplusplus
}
#endif




