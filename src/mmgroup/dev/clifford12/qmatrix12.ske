// %%COMMENT
// For this module we refer to the section
// 'Computation in the Clifford group' in the guide, see
// https://mmgroup.readthedocs.io/en/latest/


// %%COMMENT
// Negative return values of functions in this module are error codes.
// Their meaning is the same as in module qstate12.c


// %%COMMENT
// Negative return values of functions in this module are error codes:
// These error codes are extenstion of those in mudule qstate12.c 
// -11: Matrix is not invertible,
// -12: Matrix is not in the Pauli group,


/*************************************************************************
** External references 
*************************************************************************/

#include <string.h>
#define CLIFFORD12_INTERN
#include "clifford12.h"

// %%EXPORT_KWD CLIFFORD12_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c



/*************************************************************************
*** Construction of a state matrix
*************************************************************************/




// %%EXPORT p
int32_t qstate12_std_matrix(qstate12_type *pqs, uint32_t rows, uint32_t cols, uint32_t rk) 
// Create a standard matrix (as a C-strided array) with 'rows' rows,
// 'cols' columns, of rank 2**rk. Considering row operations as inputs 
// and column peration as outputs, we connect the first 'rk' input 
// qubits to the first 'rk' output qubits.  Note that the distinction 
// between input and output qubits is out of the scope of this module. 
// So we just connect input qubit j (corresponding to column j + cols
// of submatrix A) to output qubit j (corresponding to column j of 
// submatrix A). 0 <= rk < min(nows, cols) must hold.
{
    uint64_t mask = (ONE << cols) + ONE;
    uint32_t i;

    pqs->nrows = rk + 1;
    pqs->ncols = rows + cols;
    pqs->factor = 0;
    pqs->data[0] = 0;
    if (bad_state(pqs)) return -4;
    if (rk > rows || rk > cols ) {
        pqs->nrows = pqs->ncols = 0;
        return -3;
    }
    for (i = 1; i < pqs->nrows; ++i) {
        pqs->data[i] = mask; mask <<= 1;
    } 
    return 0;  
}




// %%EXPORT p
int32_t qstate12_unit_matrix(qstate12_type *pqs, uint32_t nqb) 
//  Set the state ``qs`` referred by ``pqs`` to a 
// ``2**nqb`` times ``2**nqb`` unit matrix
{  
    return  qstate12_std_matrix(pqs, nqb, nqb, nqb);
}


// %%EXPORT p
int32_t qstate12_monomial_column_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t *pa) 
// Set the state ``qs`` referred by ``pqs`` to a real monomial 
// ``2**nqb`` times ``2**nqb`` transformation matrix ``T`` which 
// is monomial in  the sense that each column contains exactly 
// one nonzero entry ``1`` or ``-1``. So left multiplication  
// with ``T`` maps maps unit vectors to (possibly negated) unit  
// vectors. It transforms a  state ``|v>`` of ``nqb`` input bits 
// to a state ``T * |v>`` of ``nqb`` output qubits. Here
// ``|v>`` is considered as a column vector.
//
// ``pa`` refers to an array a of integers ``a[i]`` of length 
// ``nqb + 1``. Each integer ``a[i]`` is interpreted as a bit 
// field  via its binary  representation. So ``a[i,j]`` means 
// ``(a[i] >> j) & 1``. ``a[i, j1:j2]`` means the bit field  
// ``a[i,j1],...,a[i,j2-1]``.
//
// For any bit vector ``v`` of length ``nqb`` let ``|v>`` be the 
// unit vector with index ``v``. For any bit vector ``v`` of 
// length ``nqb + 1`` let ``|v>`` be the (possibly negated) unit 
// vector ``(-1)**v[nqb] * |v[0:nqb]>``.  ``|v1 ^ v2>`` and 
// ``|1 << v1>`` are defined via the corrresponding operators 
// ``<<`` and ``^`` in C.
//
// Then ``T``  maps
//
//   * ``|0>``     to  ``|a[0, 0:nqb+1]>``
//
//   * ``|1 << i>`` to  ``|a[0, 0:nqb+1] ^ a[i+1, 0:nqb+1]>``
//
// ``T`` maps unit vectors to (possibly negated) unit vectors, 
// so ``T(v)`` is well defined by ``|T(v)> = T(|v>)`` for a bit 
// field ``v`` of length ``nqb + 1``. We have
//
//   * ``|T(v1 ^ v2)> = (-1)**Q(v1,v2) * |T(v1) ^ T(v2) ^ T(0)>``,
//
// for bit fields ``v1, v2`` of length ``nqb + 1`` and an 
// alternating bilinear form ``Q`` depending on the first ``nqb`` 
// bits of ``v1`` and ``v2`` only. Thus ``T`` is  defined by the 
// above equation and ``Q``. The bilinear form ``Q`` is defined by:
//  
//   * ``Q(v1, v2) = Q(v2, v1),  Q(v1, v1) = 0``,  and
//
//   * ``Q(1 << i, 1 << j) =  m[i + 1, j + nqb + 1]``,  
//     for ``0 <= j < i < nqb``.
//
{
    uint64_t *m = pqs->data, mask1;
    uint_fast32_t i;
    int32_t factor = ((pa[0] >> nqb) & 1) << 2;
    pqs->nrows = nqb + 1;
    pqs->ncols = nqb << 1;
    if (bad_state(pqs)) return -4;
 
    mask1 = (ONE << nqb) - 1;
    m[0] = (pa[0] & mask1) << nqb;
    for (i = 1; i <= nqb; ++i) {
        mask1 += mask1 + 1;
        m[i] = ((ONE << (i - 1)) | ((pa[i] & mask1) << nqb));
    } 
    qstate12_set(pqs, 2*nqb, nqb+1, m, 1);
    pqs->factor = factor;
    return 0; 
}

// %%EXPORT p
int32_t qstate12_monomial_row_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t *pa) 
// Similar to qstate12_monomial_column_matrix; but we create a 
// matrix ``T`` which is monomial in  the sense that each row
// contains exactly  one nonzero entry ``1`` or ``-1``.
// ``qstate12_monomial_row_matrix(*pqs, nqb, *pa)`` 
// creates the transposed matrix of  
// ``qstate12_monomial_column_matrix(*pqs, nqb, *pa)`` 
{
    int32_t res = qstate12_monomial_column_matrix(pqs, nqb, pa); 
    if (res < 0) return res;
    return qstate12_rot_bits(pqs, nqb, 2*nqb, 0);
}


/*************************************************************************
*** 'Multiplying' states and matrices of states
*************************************************************************/




static inline void
qstate12_copy_row(uint64_t *m, uint32_t ncols, uint32_t nrows, uint32_t i1, uint32_t i2)
// Copy row ``i1`` of the bit matrix m referred to row ``i2``. 
// ``i2 <= i1`` must hold. We interpret ``m`` as a pair ``A,Q``
// of adjacent matrices of a state so that ``A`` has ``ncols``
// columns. We also adjust the quadratic form ``Q``
{ 
    uint64_t mask; 
    int_fast32_t k, sh;
    if (i2 < i1) {
        m[i2] = m[i1]; 
        mask = ONE <<  (ncols + i2);
        sh = i1 - i2;
        for (k = 0; k < nrows; ++k)  {
           m[k] = (m[k] & ~mask) | ((m[k] >> sh) & mask);
        }
    }
} 



static inline 
uint64_t qstate12_xor_col(uint64_t *m1, uint64_t *m2, uint32_t j, uint32_t len)
// Return XOR sum of columns ``j`` of the bit matrices ``m1``
// and ``m2`` upto and exlcuding line ``len``.
{
    uint_fast32_t i;
    uint64_t a = 0;
    for (i = 0; i < len; ++i) a |= (((m1[i] ^ m2[i]) >> j) & ONE) << i;
    return a;
}


// %%EXPORT p
int32_t qstate12_prep_mul(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb)
// Auxiliary low-level function for qstate12_product().
// Prepare the states qs1 and qs2 referred by pqs1 and pqs2 for 
// multiplication. Here the first nqb columns of qs1 and qs2 are to 
// be multiplieded. The function returns a number 'row_pos', so that, 
// after preparation, the first nqb columns of submatrices A1 and A2 
// of the matrices M1 and M2corresponding to qs1 and qs2 will be equal 
// in the following sense: 
// A1[i,j] = A2[i,j]       for i <  'row_pos', j < 'nqb' ,   (QS1)
// A1[i,j] = A2[i,j] = 0   for i >= 'row_pos', j < 'nqb' ,   (QS2)
// and matrices A1 and A2 both have rank 'row_pos' - 1, when excluding
// row 0 of the two matrices.
// Some rows of A1 or A2 may be deleted to achieve this situation.
// The result of the multiplication of the states qs1 and qs2 over 
// the first nqb columns of is not changed by this operation.
// Apart from this assertion, both states are changed, and they may
// have less rows than before. They may even be changed to zero, if the 
// result of the multiplication is zero.
//
// The algorithm used here is explained in the guide in section
// 'Multiplication of quadratic mappings'. 
// In the notation in that section the algorithm computes
// states qs1', qs2' with  (qs1' (*) qs2')_n = (qs1 (*) qs2)_n 
// where n = nqb, and (*) denotes the '\odot' operation defined in
// section 'Products and tensor products of quadratic mappings'
// of the guide.
{
    int_fast32_t i1, i2, col_pos, n_deleted = 0;
    int_fast32_t row_pos = 1, row_pos1 = 1, row_pos2 = 1;
    uint64_t v, deleted = 0;
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data;
    int32_t res;

    // check and reduce input matrices
    // printf("<prep_mul>");
    if ((res = qstate12_echelonize(pqs1)) < 0) return res;
    if ((res = qstate12_echelonize(pqs2)) < 0) return res;
    if (nqb > pqs1->ncols || nqb > pqs2->ncols) return -3;
    // 
    if (pqs1->nrows == 0 || pqs2->nrows == 0)  {
        return  pqs1->nrows = pqs2->nrows = 0;
    }
    // Equalize the first 'ncols' columns of m1 and m2
    for (col_pos = 0; col_pos < nqb; ++col_pos) {
        // pivot with column col_pos, advance row_pos if success
        i1 = row_pos1 < pqs1->nrows ? (m1[row_pos1] >> col_pos) & 1 : 0;
        i2 = row_pos2 < pqs2->nrows ? (m2[row_pos2] >> col_pos) & 1 : 0;
        v = qstate12_xor_col(m1, m2, col_pos, row_pos);
        if (i1) {
            if (i2) {
                qstate12_copy_row(m1, pqs1->ncols, pqs1->nrows,
                                               row_pos1++, row_pos);
                qstate12_copy_row(m2, pqs2->ncols, pqs2->nrows,
                                               row_pos2++, row_pos);
                qstate12_pivot(pqs2, row_pos++, v);
            } else {          
                qstate12_pivot(pqs1, row_pos1++, v);
            }
        } else {
            if (i2) {
                qstate12_pivot(pqs2, row_pos2++, v);
            } else {
                int32_t i = row_pos-1;
                while (i >= 0 && ((ONE << i) & v) == 0) --i;
                if (i > 0) {
                    qstate12_pivot(pqs1, i, v);
                    qstate12_pivot(pqs2, i, v);
                    deleted |= ONE << i; ++n_deleted;
                    m1[i] = m2[i] = 0;
                } else if (i == 0) {
                    return  pqs1->nrows = pqs2->nrows = 0;  
                }                
            }
        } 
    }

    v = deleted + (ONE << row_pos1) - (ONE << row_pos);
    if ((res = qstate12_del_rows(pqs1, v)) < 0) return res;
    v = deleted + (ONE << row_pos2) - (ONE << row_pos);
    if ((res = qstate12_del_rows(pqs2, v)) < 0) return res;
    row_pos -= n_deleted;
  
    return row_pos ;
}



// %%EXPORT
int32_t qstate12_mul_elements(qstate12_type *pqs1, qstate12_type *pqs2, uint64_t mask)
// Auxiliary low-level function for qstate12_product().
// For the submatrices ``A1, Q1`` and ``A2, Q2`` of the matrices
// ``M1`` and ``M2`` the states rreferred by ``qs1`` and ``qs2``
// we put ``A1 = A1 + A2, Q1 = Q1 + Q2``.
// The pair ``(A2, Q2)`` is masked with the ``mask`` befor
// it is added. A carry in the adiition of diagonal entries
// of ``Q1`` nd ``Q2`` is processed correctly.
// The number of rows and columns in both states must be equal. 
{
    uint64_t *m1 = pqs1->data, *m2 = pqs2->data, c = ONE << pqs1->ncols;
    int32_t k;
    if (bad_state(pqs1) || bad_state(pqs2)) return -2;
    if (pqs2->nrows != pqs1->nrows || pqs2->ncols != pqs1->ncols) return -99; 
    m1[0] ^= m2[0] & mask;
    for (k = 1; k < pqs1->nrows; ++k)  {
       int64_t m2m = m2[k] & mask;
       m1[0] ^= m1[k] & m2m & (c << k);
       m1[k] ^= m2m;
    }
    if (ADD_FACTOR_OVERFLOW(pqs1->factor >> 4, pqs2->factor >> 4))
        return -9;
    pqs1->factor = ADD_FACTORS(pqs1->factor, pqs2->factor);
    return 0;
}






// %%EXPORT p
int32_t qstate12_product(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb, uint32_t nc)
// Compute a certain product ``qs3`` of the states ``qs1`` 
// and ``qs2`` referred by ``pqs1`` and ``pqs2``. 
// Let ``n1 = pqs1->ncols,  n2 = pqs2->ncols``.
// Put ``qs1a =  qstate12_extend(qs, n1, n2-nqb)``,
// ``qs2a =  qstate12_extend(qs, nqb, n1-nqb)``. Then ``qs1a``
// and ``qs2a`` are complex functions on ``(nn1 + nn2 - nqb)``
// bits. Let ``qs3a`` be the complex function which is the 
// product of the functions  ``qs1a`` and ``qs2a``. Then we 
// have ``qs3 = qstate12_sum_cols(qs23, 0, nc)``.
// The result ``qs3`` is computed in the state referred by 
// ``qs1``. It is reduced. ``qs2`` is destoyed. 
//
// E.g. ``qstate12_product(pqs1, pqs2, nc, nc)`` is the tensor 
// contraction over the first ``nc`` qubits of ``qs1`` and 
// ``qs2``. ``In case pqs1->ncols = pqs2->ncols = n``, the 
// function ``qstate12_product(pqs1, pqs2, n, 0)`` returns the 
// product of ``qs1`` and ``qs2`` (considered as functions); 
// and ``qstate12_product(pqs1, pqs2, n, n)`` returns the scalar
// product of ``qs1`` and ``qs2`` (considered as vectors).
//
// ``qstate12_product(pqs1, pqs2, n, 0)`` corresponds to the 
// function ``(qs1 (*) qs2)_n``  where ``(*)`` denotes the 
// ``'\odot'`` operation defined in section 
// 'Products and tensor products of quadratic mappings'
// of the guide.
{
    int32_t row_pos = qstate12_prep_mul(pqs1, pqs2, nqb);
    int32_t rows1, rows2, cols1, cols2; 
    int32_t res;

    if (row_pos < 0) return row_pos; // Then row_pos is an error code
    if (nc > nqb) return -3;

    if ((res = qstate12_sum_cols(pqs1, 0, nc)) < 0) return res; 
    if ((res = qstate12_sum_cols(pqs2, 0, nc)) < 0) return res; 
    nqb -= nc;
    
    cols1 = pqs1->ncols; cols2 = pqs2->ncols;
    res = qstate12_extend_zero(pqs1, nqb, cols2 - nqb);
    if (res < 0) return res;
    res = qstate12_extend_zero(pqs2, cols2, cols1 - nqb); 
    if (res < 0) return res;
 
    if (pqs1->nrows == 0 || pqs2->nrows == 0)
        return pqs1->nrows = pqs1->factor = 0; 

    rows1 = pqs1->nrows - row_pos;  rows2 = pqs2->nrows - row_pos;
    res = qstate12_insert_rows(pqs1, row_pos, rows2);
    if (res < 0) return res;
    res = qstate12_insert_rows(pqs2, pqs2->nrows, rows1); 
    if (res < 0) return res;
    res = qstate12_mul_elements(pqs1, pqs2, -(ONE << nqb)); 
    if (res < 0) return res;
    return qstate12_reduce(pqs1);
}




/*************************************************************************
*** Matrix multiplication
*************************************************************************/


// %%EXPORT p
int32_t qstate12_matmul(qstate12_type *pqs1, qstate12_type *pqs2, uint32_t nqb)
// Performs a matrix multiplication.
// Given a state ``qs`` with ``qs->ncols = m + n`` we
// may interpret ``qs`` as an ``2**m`` times ``2**n`` matrix, 
// where the ``2**m`` rows of the matrix correspond to the
// higher ``m`` qubits and the ``2**n`` columns corrspond to 
// the lower ``n`` qubits.
// Then we consider the state ``qs1`` referred by ``pqs1``
// as a ``qs1->ncols - nqb`` times ``nqb`` matrix ``m1``and 
// the state ``qs2`` referred by ``pqs2`` as a  ``nqb`` times 
// ``qs2->ncols - nqb`` matrix m2.
//
// We compute the matrix product ``m3 = m1 @ m2``  as a 
// ``qs1->ncols - nqb`` times ``qs2->ncols - nqb`` matrix
// and we store the state corresponding to matrix ``m3``
// in ``qs1``.  The state ``qs2`` is destroyed.
{
    int32_t res;
    res = qstate12_rot_bits(pqs2, nqb, pqs2->ncols, 0);
    if (res < 0) return res;
    return qstate12_product(pqs1, pqs2, nqb, nqb);
}


/*************************************************************************
*** Creating and checking matrices in the Pauli group
*************************************************************************/

// %%EXPORT p
uint64_t qstate12_pauli_vector(qstate12_type *pqs, uint32_t nqb, uint64_t *pv)
{
    int32_t res, i = 1;
    uint64_t *m = pqs->data, w, mask = ONE + (ONE << nqb);
    
    if ((res = qstate12_reduce(pqs)) < 0) return res;
    if (pqs->ncols != nqb << 1 || pqs->nrows != nqb + 1) return -12;
    if (pqs->factor & -0xf) return -12; 
    for (i = 0; i < nqb; ++ i) {
        w |=  (m[i+1] ^ mask);
        mask <<= 1;
    }
    mask = (((ONE << pqs->nrows) - 1) << pqs->ncols) - 1;
    if (w & mask) return -12;
    mask = (ONE << nqb) - 1;
    w = (m[0] >> (pqs->ncols + 1)) & mask;
    w |= m[0] & (mask << nqb);
    w |= (uint64_t)((pqs->factor >> 2) & ONE) << pqs->ncols;    
    w |= (uint64_t)((pqs->factor >> 1) & ONE) << (pqs->ncols + 1);    
    *pv = w;
    return 0;
}



// %%EXPORT p
uint64_t qstate12_pauli_matrix(qstate12_type *pqs, uint32_t nqb, uint64_t v)
{
    int32_t res;
    uint64_t *m = pqs->data, mask = (ONE << nqb) - 1;
    if ((res = qstate12_std_matrix(pqs, nqb, nqb, nqb)) < 0) return res;
    m[0] |= (v & mask) << (2 * nqb + 1); 
    m[0] |= v & (mask << nqb);
    v >>= 2*nqb;
    pqs->factor |= (v & 1) << 2;    
    pqs->factor |= v & 2;    
    return 0;
}


/*************************************************************************
*** Multiplication and exponentiation in the Pauli group
*************************************************************************/

// %%EXPORT p
uint64_t qstate12_pauli_vector_mul(uint32_t nqb, uint64_t v1, uint64_t v2)
// Yet to be documented!!
{
    uint64_t s;
    if (nqb >= MAXCOLS/2) return v1 ^ v2; 
    s = (v1 & (v2 >> nqb)) & ((ONE << nqb) - 1);
    s ^= ((v1 & v2) >> (2*nqb + 1)) & 1;
    s ^= s >> 32; s ^= s >> 16; s ^= s >> 8; s ^= s >> 4;
    s = (0x6996 >> (s & 0x0f)) & 1;
    return (v1 ^ v2 ^ (s << (nqb << 1))) & (((4*ONE) << (2*nqb)) - 1);
}

// %%EXPORT p
uint64_t qstate12_pauli_vector_exp(uint32_t nqb, uint64_t v, uint32_t e)
// Yet to be documented!!
{
    uint64_t s = 0;
    if (e & 2 && nqb < MAXCOLS/2) {
       s = (v & (v >> nqb)) & ((ONE << nqb) - 1);
       s ^= (v >> (2*nqb + 1)) & 1;
       s ^= s >> 32; s ^= s >> 16; s ^= s >> 8; s ^= s >> 4;
       s = (0x6996 >> (s & 0x0f)) & 1;
       s <<= (nqb << 1);    
    } 
    s ^= -(e & ONE)  & v;
    return  s & (((4*ONE) << (2*nqb)) - 1);
}



/*************************************************************************
*** Special reduction for matrices
*************************************************************************/




static inline 
int32_t qstate12_find_masked_pivot(uint64_t *m, uint32_t nrows, uint32_t j, uint32_t mask)
// Auxiliary low-level function for ``qstate12_reduce_matrix()``.
// Let ``m`` be a bit matrix with ``nrows`` rows.  On input ``j``, 
// the function returns the highest row index ``i`` such that
// ``A[i,j] = 1.`` and bit ``i`` of ``mask`` is cleared. 
//  The function returns ``-1`` if all bits ``A[i1,j]`` are zero.
{
    mask = ~mask; 
    int_fast32_t i = nrows - 1; 

    // find the  highest row index i such that m[i,j] = 1. 
    while (i >= 0  && (((m[i] >> j) & (mask >> i) & 1) == 0)) -- i;
    return i;
}



// %%EXPORT p
int32_t qstate12_reduce_matrix(qstate12_type *pqs, uint32_t nqb, uint8_t *row_table)
// TODO: Yet to be documented!!
{
    int_fast32_t res, i, j, fst_row;
    uint64_t kernel, *m = pqs->data, v;
    if ((res = qstate12_reduce(pqs)) < 0) return res;
    if ((res = qstate12_row_table(pqs, row_table)) < 0) return res;
    if (nqb > pqs->ncols) return -3;
    if (pqs->nrows == 0) return 0;
    
    fst_row = pqs->nrows;
    v = (ONE << nqb) - 1;
    for (i = pqs->nrows - 1; i > 0; --i) {
        row_table[pqs->ncols + i] = QSTATE12_UNDEF_ROW;
        if ((m[i] & v) == 0) fst_row = i;
    }    
    kernel = -(ONE << fst_row);
    row_table[pqs->ncols] = fst_row;
        
    for (j = nqb; j < pqs->ncols; ++j) {
        if (row_table[j] == QSTATE12_UNDEF_ROW) {
            i =  qstate12_find_masked_pivot(m, fst_row, j, kernel);
            if (i > 0) {
               kernel |= ONE << i;
               qstate12_pivot(pqs, i, qstate12_get_col(m,j, i));
               row_table[j] = i;
               row_table[pqs->ncols + i] = j;
            }   
        }
    }
    
    // Pivot Q part of state data
    // TODO: check it!!!!!
    for (j = pqs->nrows -1; j >= fst_row; --j) {
        i = qstate12_find_masked_pivot(m, fst_row, j + pqs->ncols, kernel);
        // if i >= 0 then i is the higest row with Q[i,j] = 1
        if (i > 0) {
            // set v to column (or row) j of matrix Q
            v = ((m[j] >> pqs->ncols) & (-2ULL)) +
                 ((m[0] >> (j + pqs->ncols)) & 1);
            v &= ~kernel;     
            qstate12_pivot(pqs, i, v);
            // Set v to  column (or row) i of matrix Q
            v = m[i] >> pqs->ncols;
            v &= -(ONE <<  fst_row);
            qstate12_pivot(pqs, j, v);
            row_table[pqs->ncols + j] = i;
        }
    }    
    return 0;
    
}


/*************************************************************************
*** Matrix transposition
*************************************************************************/


// %%EXPORT p
int32_t qstate12_bit_matrix_t(uint64_t *m1, uint32_t i, uint32_t j, uint64_t *m2)
// Here ``m1`` is an ``i`` times ``j`` bit matrix. The function
// write the transposed matrix of ``m1`` to ``m2``.
{
    uint64_t v;
    uint32_t i1, j1;
    if (i > 64 || j > 64) return -5;
    for (j1 = 0; j1 < j; ++j1) {
        v = 0;
        for (i1 = 0; i1 < i; ++i1) v |= ((m1[i1] >> j1) & 1) << i1;
        m2[j1] = v;
    }
    return 0;
}


/*************************************************************************
*** Conjugation of Pauli vector with a  matrix
*************************************************************************/


// %%EXPORT p
int32_t qstate12_pauli_conjugate(qstate12_type *pqs, uint32_t nqb, uint32_t n, uint64_t *pv)
// TODO: Yet to be implemented!!
{
    int_fast32_t res, i, j, rank = 0, fst_row, sh, j0, j1;
    uint8_t row_table[MAXCOLS];
    uint64_t *m = pqs->data, m0, v, w, f,  mask;
    uint64_t v_out, a_t[MAXCOLS/3+1]; 
    
    res = qstate12_reduce_matrix(pqs, nqb, row_table);
    if (res < 0) return res;
    
    // Check that rank of matrix is equak to nqb
    fst_row = row_table[pqs->ncols];
    for (j = nqb; j <= nqb << 1; ++j) rank += row_table[j] < fst_row;
    for (j = pqs->ncols + fst_row; j < pqs->ncols + pqs->nrows; ++j) 
        rank +=  row_table[j] != QSTATE12_UNDEF_ROW;
    if (rank != nqb) return -11;
    if (nqb == 0) return 0;
    res = qstate12_bit_matrix_t(m, nqb + 1, nqb, a_t);
    if (res < 0) return res;
    for (j = 0; j < nqb; ++j) a_t[j] <<= pqs->ncols;
    
    mask = (ONE << j1) - (ONE << j0) + (ONE << pqs->ncols) - (ONE << nqb);
    if  (m0 & mask) return -90; // internal error
   
    while (n--) {
        v = *pv;
        mask = (ONE << nqb) - 1;
        m0 = m[0];
        f = 0x3120 >> (((v >> (pqs->ncols)) & 3) << 2);
        if ((res = qstate12_mul_Av(pqs, (v & mask) << nqb, &w)) < 0) 
            return res; 
        f += w << 1;
        m0 ^= w << pqs->ncols;
        m0 ^= v & (mask << nqb);
        
        for (j = nqb; j < pqs->ncols; ++j) if ((m0 >> j) & 1) {
            i = row_table[j];
            sh = pqs->ncols + i;
            // factor *= exp(pi/2 * sqrt(-1) * k), k = 2 * Q[0,i] + Q[i,i]
            // see guide, section 'Implementation of quadratic mappings'
            f += ((m0 >> sh) & 1) << 1;
            f += (m[i] >> sh) & 1;
            // Add row i to row 0
            if (((m[i] >> j) & 1) == 0) return -91; // internal error
            m0 ^= m[i];
        }
        j0 = pqs->ncols + fst_row; j1 = pqs->ncols + pqs->nrows;
        for (j = j0; j < j1; ++j) if ((m0 >> j) & 1) {
            i = row_table[j];
            sh = pqs->ncols + i;
            // factor *= exp(pi/2 * sqrt(-1) * k), k = 2 * Q[0,i] + Q[i,i]
            // see guide, section 'Implementation of quadratic mappings'
            f += ((m0 >> sh) & 1) << 1;
            f += (m[i] >> sh) & 1;
            // Add row i to row 0
            if (((m[i] >> j) & 1) == 0) return -92; // internal error
            m0 ^= m[i];
        }
        mask = (ONE << j1) - (ONE << j0) + (ONE << pqs->ncols) - (ONE << nqb);
        if  (m0 & mask) return -93; // internal error
    
        v_out = 0;
        
        // adjust z part of output Pauli matrix v_out
        mask = (2*ONE) << pqs->ncols;
        m0 &= ~(ONE << pqs->ncols);
        for (j = nqb - 1; j >= 0; --j) {
            if (((m[0] ^ m0) >> j) & mask) {
                v_out ^= ONE << j;
                if (((a_t[j] >> j) & mask) == 0) return -94; // internal error
                f += (m0 >> j) << 1; 
                m0 ^= a_t[j];
            }
        }
        
        mask = ((ONE << nqb) - 1) << (pqs->ncols + 1);
        if ((m[0] ^ m0) & mask)  return -95; // internal error
        
        // adjust x part of output Pauli matrix
        v_out ^= ((m0 ^ m[0]) & ((ONE << nqb) - 1)) << nqb;
      
        // adjust Factor of output Pauli matrix
        f = (0x3120 >> ((f & 3) << 2)) & 3;
        v_out ^= f << pqs->ncols;
        *pv++ = v_out;
    }
    return 0;
}






// %%GEN ch
#ifdef __cplusplus
}
#endif




