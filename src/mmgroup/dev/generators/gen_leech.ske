// %%COMMENT
// For this module we refer to the section
// 'Computation in the Clifford group' in the guide, see
// https://mmgroup.readthedocs.io/en/latest/



/*************************************************************************
** External references 
*************************************************************************/

#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"




// %%EXPORT_KWD MAT24_API


// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


// %%GEN h
#ifdef MMGROUP_GENERATORS_INTERN

static inline uint64_t short_3_reduce(uint64_t x)
{
    uint64_t a = (x & (x >> 24)) & 0xffffffUL;
    x ^=  a | (a << 24);
    return x  & 0xffffffffffffULL;
}


static inline
uint64_t gen_leech3_op_pi(uint64_t v3, uint8_t perm[24])
{
    uint64_t w3 = 0;
    uint_fast32_t i;
    for (i = 0; i < 24; ++i) {
        w3 |= ((v3 >> i) & 0x1000001ULL) << perm[i];
    }
    return w3; 
}

static inline
uint64_t gen_leech3_op_y(uint64_t v3, uint32_t y)
{
    uint64_t v = mat24_gcode_to_vect(y);
    return v3 ^  (v | (v << 24)); 
}

static inline uint32_t short_3_scalprod(uint64_t x1, uint64_t x2)
{
    uint64_t zero, res;
    
    // Set all bits i in ``zero`` to 0 where x1[i] * x2[i] is 0
    zero = ((x1 ^ (x1 >> 24)) & (x2 ^ (x2 >> 24))) & 0xffffffUL;
    // Store scalar products of entries of x1 and x2 in res
    // Each scalar product is >= 0 and <= 2.
    res = (x1 ^ x2) & 0xffffff000000ULL;
    res = (res & (zero << 24)) | (zero & ~(res >> 24));
    // Sum up entries of res, counting the high 24 bits twice
    res = (res & 0x555555555555ULL) + ((res >> 1) & 0x555555555555ULL);
    res = (res & 0x333333333333ULL) + ((res >> 2) & 0x333333333333ULL);
    res = (res & 0x0f0f0f0f0f0fULL) + ((res >> 4) & 0x0f0f0f0f0f0fULL);
    res = (res & 0xffffffULL) + ((res >> 23) & 0x1fffffeULL);
    res = ((res >> 16) + (res >> 8) + res) & 0xff;
    // Reduce res modulo 3; we have 0 <= res <= 48
    res = (res & 3) + (res >> 2) + 1; // res <= 19; res is one too big
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 7
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 4
    res =  (res & 3) + (res >> 2);    // 1 <= res <= 3
    return (uint32_t)res - 1;
}

#endif // 
// %%GEN c



/*************************************************************************
*** Type of a Leech vector
*************************************************************************/

// %%EXPORT px
uint32_t gen_leech2_type(uint64_t x)
// Return ``0x10 * type(x) + subtype(x)`` for a vector ``x``
// in the Leech lattice modulo ``2``.
// The type of a vector is half the length of the shortest 
// representative of a vector in the Leech lattice.
// The subtype decsribes the double coset of the vector in
// in ``N_x \ Co_1 / N_x``, where ``Co``_1 is the automorphism 
// group of the Leech lattice modulo ``2``, and ``N_x`` is the 
// automorphism group of a vector ``(2,...,2)`` in the standard 
// basis of the Leech lattice modulo ``N_x`` has structure 
// ``2^11. Mat_24``, with ``Mat_24`` the Mathieu group operating
// on 24 elements.
//
// In :cite`:`Con85` a vector in th Leech lattice is
// denotes by ``x_d * x_delta``, where ``d`` is an element of
// the Golay code and ``delta`` is an eÃ¶ment of it cocode. 
// Subtypes can be described as follows:
//
// 0: The set contains an element with ``delta = 0``
// 1: ``delta`` has weight ``1`` for all elements in the set.
// 2: ``d`` or its complement is an octad and ``delta`` is
//     even and contained in that octad.
// 3: ``delta`` has weight ``1`` for all elements in the set.  
// 4: ``d`` or its complement is an octad and ``delta`` is
//     even and not contained in that octad.
// 6: ``d`` has weight 12
// 8: The singleton containing ``(2,...,2)`` 
//
// Valid combinations of type and subtype (hex) are
//
// 00,   20, 21, 22,   31, 33, 34, 36,  
// 40, 42, 43, 44, 46, 48.
{
    static uint8_t tab_odd[4] = {
        0x21, 0x31, 0x43, 0x33
    };
    static uint8_t tab_even_scalar1[7] = {
        0xff, 0xff, 0x34, 0x36, 0x34, 0xff, 0xff
    };
    uint_fast32_t  x1, gcodev, cocodev, theta, w, cw,scalar, lsb;
    x1 = (uint_fast32_t)x;
    theta = MAT24_THETA_TABLE[(x1 >> 12) & 0x7ff]; 
    // put cw = min weight of cocode word
    cw = mat24_cocode_weight(x1 ^ theta);
    // Put scalar = scalar product (code, cocode)
    scalar = (x1 >> 12) &  x1 & 0xfff;
    scalar ^= scalar >> 6;
    scalar ^= scalar >> 3;
    scalar = (0x96 >> (scalar & 7)) & 1;
    
    // Deal with odd cocode first
    if (x1 & 0x800) return tab_odd[cw-1+scalar]; 
    
    // Put w = weight(code word gcodev) / 4
    w = 0 - ((x1 >> 23) & 1);
    w = (((theta >> 12) & 7) ^ w) + (w & 7);  

    // Deal with even cocode and scalar == 1
    if (scalar) return tab_even_scalar1[w];
   
    switch (w) {
        case 6:
            if (cw == 0) return 0x48;
        case 0: 
            return cw << 4;
        case 3:
            return 0x46;
        case 4:
            // Add 1....1 to bit vector x (in vector rep)
            x1 ^= 0x800000; 
        default:   // This must be case 2:
            // Put gcodev = codeword (in vector rep)
            gcodev = mat24_gcode_to_vect(x1 >> 12); 
            // Put coccodev = cocode word (in vector rep), such that
            // the cocode word is a suboctad of gcodev if possible
            lsb = mat24_lsbit24(gcodev);
            cocodev = mat24_cocode_syndrome(x1 ^ theta, lsb); 
            // Put cw = 0x22 if (w ^ cw) & 2 is 2, else put cw = 0x42
            cw = 0x42 - (((w ^ cw) & 2) << 4);
            // Return cw if cocodev is a suboctad of gcodev
            if ((gcodev & cocodev) == cocodev) return cw;
            // Otherwise vector is of type 4
            return 0x44;          
    }
}


//  %%GEN h
/// @endcond  
//  %%GEN c



/************************************************************************
*************************************************************************
*** Leech lattice mod 2
*************************************************************************
*************************************************************************/


/*************************************************************************
*** Operation of monomial generators on the extraspecial group 2^{{1+24}}
*************************************************************************/



static inline
uint32_t op_x_delta(uint32_t x1, uint32_t x, uint32_t delta)
{
    uint32_t s;
    delta ^= MAT24_THETA_TABLE[x & 0x7ff];
    s = ((x1 >> 12) & delta) ^ (x1 & x);
    s ^= s >> 6; s ^= s >> 3;
    s = (0x96 >> (s & 7)) & 1;
    return x1 ^ (s << 24);
}


static inline
uint32_t op_delta_pi(uint32_t x1, uint32_t delta, uint32_t pi)
{
    uint32_t xd, xdelta;
    uint8_t perm[24];
    uint32_t autpl[12];
    
    xd = (x1 >> 12) & 0x1fff;
    xdelta =  (x1 ^ MAT24_THETA_TABLE[(x1 >> 12) & 0x7ff]) & 0xfff;
    if (pi == 0 || mat24_m24num_to_perm(pi, perm)) {
        xd ^=  mat24_scalar_prod(xd, delta) << 12;
    } else {
        mat24_perm_to_autpl(delta, perm, autpl);
        xd = mat24_op_ploop_autpl(xd, autpl);
        xdelta =  mat24_op_cocode_perm(xdelta, perm);
    }
    return (xd << 12) ^ xdelta ^ (MAT24_THETA_TABLE[xd & 0x7ff] & 0xfff);
}


static inline
uint32_t op_delta_pi_inv(uint32_t x1, uint32_t delta, uint32_t pi)
{
    uint32_t xd, xdelta;
    uint8_t perm[24], inv_perm[24];
    uint32_t inv_autpl[12];
    
    xd = (x1 >> 12) & 0x1fff;
    xdelta =  (x1 ^ MAT24_THETA_TABLE[(x1 >> 12) & 0x7ff]) & 0xfff;
    if (pi == 0 || mat24_m24num_to_perm(pi, perm)) {
        xd ^=  mat24_scalar_prod(xd, delta) << 12;
    } else {
        mat24_perm_to_iautpl(delta, perm, inv_perm, inv_autpl);
        xd = mat24_op_ploop_autpl(xd, inv_autpl);
        xdelta =  mat24_op_cocode_perm(xdelta, inv_perm);
    }
    return (xd << 12) ^ xdelta ^ (MAT24_THETA_TABLE[xd & 0x7ff] & 0xfff);
}


static inline
uint32_t op_y(uint32_t x1, uint32_t y)
{
    // We use the formula for conjugation of 
    // :math:`\tilde{{x}}_d x_\delta` with :math:`y_e` 
    // in the **guide**, section 
    // **Implementing generators of the Monster group**.
    uint32_t s, o, theta_x1, theta_y, odd, eps;
    odd = 0 - ((x1 >> 11) & 1);
    theta_x1 = MAT24_THETA_TABLE[(x1 >> 12) & 0x7ff];
    theta_y = MAT24_THETA_TABLE[y & 0x7ff];
    s =  (theta_x1 & y) ^ (~odd &  x1 & y); 
    s ^= s >> 6; s ^= s >> 3;
    s = (0x96 >> (s & 7)) & 1;
    o = (theta_y & (x1 >> 12)) ^ (x1 & y);
    o ^= (theta_y >> 12) & 1 & odd;
    o ^= o >> 6; o ^= o >> 3;
    o = (0x96 >> (o & 7)) & 1;
    eps = theta_x1 ^ (theta_y & ~odd) 
           ^  MAT24_THETA_TABLE[((x1 >> 12) ^ y) & 0x7ff]; 
    x1 ^= (eps & 0xfff) ^ ((y << 12) & 0x1fff000 & odd);
    x1 ^= (s << 24) ^ (o << 23);
    return x1;
}



/*************************************************************************
*** Conjugating a vector in the extraspecial group 2^{{1+24}}
*************************************************************************/


// %%EXPORT px
uint32_t gen_leech2_conj_word(uint32_t x1, uint32_t *pa, uint32_t n)
// Conjugate the element ``x1`` of the Pauli group with element 
// ``e`` of the group ``g_{{x1}}`` with the atom
// given by ``v``. Atom ``v`` is interpreted as follows:
// Bit 31:      sign of exponent
// Bit 30..28   tag
// Bit 27..0    operarand
// Tag are as follows:
//
//                bit
// Tag  word     length   operand
//  0:  1         -       unit of the group, no operand
//  1:  x_delta   12      delta in C* in 'cocode' rep
//  2:  x_pi      28      pi a permutation number  
//  3:  x_d       13      d an element of the parker loop
//  4:  y_d       13      d an element of the parker loop
//  5:  t**e      28      exponent e, illegal here
//  6:  xi**e     28      exponent e
//  7   illegal                  
// 
// 
{
    uint_fast32_t tag, i, v, y;
 
    x1 &= 0x1ffffff;
    for (i = 0; i < n; ++i) {
        v = pa[i];
        tag = v >> 28;
        v  &= 0xfffffff;
        y = 0;
        switch(tag) {
            case 8:
            case 0:
               break;
            case 8 + 1:
            case 1:
               x1 = op_x_delta(x1, 0, v & 0xfff);
               break;
            case 8 + 2:
               x1 = op_delta_pi_inv(x1, 0, v);
               break;
            case 2:
               x1 = op_delta_pi(x1, 0, v);
               break;
            case 8 + 3:
            case 3:
               x1 = op_x_delta(x1, v & 0xfff, 0);
               break;
            case 8 + 4:
               y ^= (MAT24_THETA_TABLE[v & 0x7ff] & 0x1000);
            case 4:
               y ^= v & 0x1fffUL;
               x1 = op_y(x1, y & 0x1fff);
               break;
            case 8 + 5:
            case 5:
               if (v % 3) return (uint32_t)(0-1UL);
               break;
            case 8 + 6:
               v ^= 0xfffffff;
            case 6:
               x1 = gen_xi_op_xi(x1, v % 3);
               break;
            default:
               return (uint32_t)(0-1UL);
        }
    }
    return x1;
}



// %%EXPORT px
uint32_t gen_leech2_conj_atom(uint32_t x1, uint32_t v)
{
    return  gen_leech2_conj_word(x1, &v, 1);
}





/*************************************************************************
*** Reduce type-4 vector  mod 2
*************************************************************************/

#define RED_STD_OCTAD 0x80fUL

static uint8_t RED_STD_HEPTAD[7] =  {{0,1,2,3,4,5,8}};
static uint8_t RED_IMG_CASE_44[7] =  {{0,1,2,3,8,9,4}};
static uint8_t RED_STD_DODECAD[12] = {{0,1,2,3,8,9,14,15,18,19}};

static inline 
uint32_t apply_perm(uint32_t v, uint8_t *p, uint32_t *p_res)
{
    uint32_t m[12], xd, xdelta;
    uint8_t pi[24];
    xd = (v >> 12) & 0xfff;
    xdelta = (v ^ mat24_ploop_theta(xd)) & 0xfff;
    mat24_perm_to_matrix(p, m);
    xd = mat24_op_gcode_matrix(xd, m);
    xdelta = mat24_op_cocode_perm(xdelta, p);
    mat24_inv_perm(p, pi);
    *p_res = 0xA0000000 + mat24_perm_to_m24num(pi);
    return (xd << 12) ^ xdelta ^ mat24_ploop_theta(xd);
}

static inline 
uint32_t apply_perm_heptad(uint32_t v, uint8_t *p_src, uint8_t *p_dest, uint32_t *p_res)
{
    uint8_t p[24];
    mat24_perm_from_heptads(p_src, p_dest, p);
    return apply_perm(v, p, p_res);
}


static inline 
// Find exponent of ``xi`` mapping Leech vector ``v`` a subspace
int32_t map_to_standard12_xi_exp(uint32_t v)
{
    uint_fast32_t parity;
    if ((v & 0x7ff800) == 0) return 0;
    if ((v & 0x7f080f) == 0) return 1;
    parity = 0 - ((0x6996 >> (v & 0xf)) & 1);
    v ^= ((v >> 12) ^ parity) & 0xf;
    if ((v & 0x7f080f) == 0) return 2;
    return -1; // no exponent found
}
     




// %%EXPORT px
int32_t gen_leech2_reduce_type4_vector(uint32_t v, uint32_t *result)
{
    uint32_t *p_res = result, i, gc, coc, vtype;
    int32_t exp;
    for (i = 5; i; --i ) {
        gc = mat24_gcode_to_vect(v >> 12);
        coc = (v ^  mat24_ploop_theta(v >> 12)) & 0xfff;
        vtype = gen_leech2_type(v);
        switch (vtype) {
            case 0x48:
                return (int32_t)(p_res - result);
            case 0x40:
                {
                    uint8_t sextet[24];
                    if (v & 0x7ffbff) {
                        if (mat24_cocode_to_sextet(coc, sextet) < 0) 
                             return -0x10000 + 0x100 * vtype + 1;
                        sextet[6] = sextet[8];
                        v = apply_perm_heptad(v,
                            sextet, RED_STD_HEPTAD, p_res++);
                    }
                    exp = 2 - ((v >> 23) & 1);
                }
                break;
            case 0x42:
                if ((exp = map_to_standard12_xi_exp(v)) < 0) {
                    uint8_t src[24], *psrc = src;
                    uint32_t w;
                    w = mat24_vect_to_bit_list(gc, src); // w is 8 or 16
                    psrc = src + (w & 16);
                    psrc[6] = src[(w & 16) ? 0 : 8];
                    v = apply_perm_heptad(v, psrc, RED_STD_HEPTAD, p_res++);
                    exp = map_to_standard12_xi_exp(v);
                    if (exp < 0) return -0x10000 + 0x100 * vtype + 1;
                }
                break;
            case 0x44:
                if ((exp = map_to_standard12_xi_exp(v)) < 0) {
                    uint8_t oct[24], syn_list[24], a2_list[24], *poct = oct;
                    uint32_t w, syn, a = 0, a1, a2, j, special;
                    w = mat24_vect_to_bit_list(gc, oct); // w is 8 or 16
                    poct = oct + (w & 16);
                    gc ^= (w & 16) ? 0xffffff : 0;
                    syn =  mat24_cocode_syndrome(coc, poct[0]) & ~gc;
                    w = mat24_vect_to_bit_list(syn, syn_list);
                    if (w != 2) return -0x10000 + 0x100 * vtype + 1;
                    for (j = 0; j < 5; ++j) a += 1L << poct[j];
                    a1 = a ^ (1 << syn_list[0]) ^ (1 << syn_list[1]);
                    special = mat24_syndrome(a1, 24);
                    a2 = a & ~special;
                    w = mat24_vect_to_bit_list(a2, a2_list);
                    if (w != 4) return -0x10000 + 0x100 * vtype + 2;
                    a2_list[4] = syn_list[0]; a2_list[5] = syn_list[1];
                    a2_list[6] = (uint8_t)(mat24_lsbit24(a & special));
                    v = apply_perm_heptad(v, 
                        a2_list, RED_IMG_CASE_44, p_res++);
                    exp = map_to_standard12_xi_exp(v);
                    if (exp < 0) return -0x10000 + 0x100 * vtype + 3;
                }
                break;
            case 0x46:
                {
                    uint8_t dodecad[24], perm[24];
                    uint32_t w, scalar;
                    w = mat24_vect_to_bit_list(gc, dodecad); // w is 12
                    mat24_perm_from_dodecads(dodecad, RED_STD_DODECAD, perm); 
                    v = apply_perm(v, perm, p_res++); 
                    coc = mat24_ploop_theta(v >> 12) ^ v;
                    scalar = mat24_scalar_prod(RED_STD_OCTAD, coc);
                    exp = 2 - scalar;
                }
                break;
            case 0x43:
                {
                    uint8_t cv_list[24], octad_list[24], rem_list[24];
                    uint32_t cv, w, j, oct, syn;
                    cv = mat24_cocode_syndrome(coc, 24);
                    w = mat24_vect_to_bit_list(cv, cv_list);
                    if (w != 3) return -0x10000 + 0x100 * vtype + 1;
                    oct = 0;
                    for (j = 0; j < 5; ++j) oct += 1 << cv_list[j];
                    syn =  mat24_syndrome(oct, 24);
                    oct ^= syn;
                    w =  mat24_vect_to_bit_list(oct, octad_list);
                    if (w != 8) return -0x10000 + 0x100 * vtype + 2;
                    w = mat24_vect_to_bit_list(oct & ~cv, rem_list);
                    if (w != 5) return -0x10000 + 0x100 * vtype + 3;
                    cv_list[3] = rem_list[0]; cv_list[4] = rem_list[1];
                    cv_list[5] = rem_list[2]; cv_list[6] = octad_list[8];
                    v = apply_perm_heptad(v, 
                        cv_list, RED_STD_HEPTAD, p_res++);
                    exp = 2 - ((v >> 22) & 1);
                }
                break;
            default:
                return -1L;
        }
        if (exp) {
            exp += 0x60000000;
            v = gen_leech2_conj_atom(v, exp);
            if (v & 0xfe000000) return -1L;
            *p_res++ = exp;
        }
    } 
    return -1L;
}

 


/************************************************************************
*************************************************************************
*** Leech lattice mod 3
*************************************************************************
*************************************************************************/

/*************************************************************************
*** Functions for supporting the Leech lattice mod 3
*************************************************************************/

#define ONE ((uint64_t)(1ULL))

// %%EXPORT px
uint64_t gen_leech2_short_to3(uint64_t x)
{
    uint64_t  gcodev, cocodev, theta, w, result;
    // Put gcodev = codeword (in vector rep)
    gcodev = mat24_gcode_to_vect((uint32_t)x >> 12); 
    theta = MAT24_THETA_TABLE[((uint32_t)x >> 12) & 0x7ff]; 
    // Put w = weight(code word gcodev) / 4
    w = 0 - ((x >> 23) & 1);
    w = (((theta >> 12) & 7) ^ w) + (w & 7);  

    if (x & 0x800) {  // case odd cocode
        uint_fast32_t scalar; 
        // Put cocodev = cocode word (in vector rep)
        cocodev = mat24_cocode_syndrome((uint32_t)(x ^ theta), 0);    
        if (cocodev & (cocodev - 1)) return 0;
        // Put scalar = scalar product (code, cocode)
        scalar = (x >> 12) &  x & 0xfff;
        scalar ^= scalar >> 6;
        scalar ^= scalar >> 3;
        scalar = (0x96 >> (scalar & 7));
        if (scalar & 1) return 0;
        result = (gcodev ^ ((gcodev ^ 0xffffff) << 24))
               & ~(cocodev | (cocodev << 24));
        return result;        
    } else { 
        uint_fast32_t  c_w;
        uint8_t c_list[4];
        // Put x[11...0] = cocode word (in cocode rep)
        x ^= theta; 
        switch (w) {
            case 4:
                gcodev ^= 0xffffff;
            case 2:
                // Put cocodev = cocode word (in vector rep)
                cocodev = mat24_cocode_syndrome((uint32_t)x, 
                    mat24_lsbit24((uint32_t)gcodev));
                // Put c_w = min weight of cocode word
                c_w = mat24_bw24((uint32_t)cocodev);
                if ( ((cocodev & gcodev) != cocodev)
                    ||  (c_w ^ 2 ^ w) & 3 ) return 0;
                result = (gcodev & ~cocodev) | (cocodev << 24);
                return result;
            case 3:
                return 0;
            default:  // can be case 0 or 6 only
                // Put c_w = min weight of cocode word
                // and store cocode bits in c_list.
                c_w = mat24_cocode_to_bit_list((uint32_t)x, 0, c_list);
                if (c_w != 2) return 0;
                result = (ONE <<  c_list[0]) + (ONE <<  (c_list[1] + 24 - 4 * w));
                return result;
        }
    } 
}









// %%EXPORT px
uint64_t gen_leech3_short_to2(uint64_t x)
{
    uint_fast32_t  gcodev, cocodev, theta, w1, w2;
    x = short_3_reduce(x);
    w1 = mat24_bw24((uint32_t)x); 
    w2 = mat24_bw24((uint32_t)(x >> 24));
    switch (w1 + w2) {
        case 23:
            cocodev = ~(uint32_t)(x | (x >> 24)) & 0xffffffUL;
            if ((cocodev == 0) || (cocodev & (cocodev - 1))) return 0; 
            gcodev = (uint32_t)(x >> ((0-(w1 & 1)) & 24)) & 0xffffffUL;
            if ((w1 + 1) & 4)  gcodev ^= 0xffffffUL;
            break;              
        case 8:
            if (w1 & 1) return 0;
            gcodev = (x | (x >> 24)) & 0xffffffUL;
            cocodev = x & 0xffffffUL;
            if (w1 & 2) gcodev ^= 0xffffffUL;
            break;
        case 2:
            cocodev = (x |  (x >> 24)) & 0xffffffUL;
            gcodev = (w1 & 1) ? 0 : 0xffffffUL;
            break;
        default:
            return 0;        
    }
    gcodev = mat24_vect_to_gcode(gcodev);
    if (gcodev & 0xfffff000UL) return 0;
    theta = MAT24_THETA_TABLE[gcodev & 0x7ff] & 0xfff;
    cocodev = mat24_vect_to_cocode(cocodev);
    return (gcodev << 12) ^ theta ^ cocodev;
}



/*************************************************************************
*** Convert type-4 vector mod 3 to type-4 vector mod 2
*************************************************************************/





static inline uint32_t parity12(uint64_t x)
{
    x ^= x >> 6; x ^= x >> 3;
    return (0x96 >> (x & 7)) & 1;
}



static inline uint32_t parity24(uint64_t x)
{
    x ^= x >> 12; x ^= x >> 6; x ^= x >> 3;
    return (0x96 >> (x & 7)) & 1;
}


// %%EXPORT px
uint64_t gen_leech3_type4_to2(uint64_t x)
{
    uint_fast32_t  gcodev, cocodev, h, w, w1, x1, syn, t, omega, res;
    x = short_3_reduce(x);
    // Let h be the support of x, i.e. the bit vector of nonzero
    // coordinates of the vector x (modulo 3)
    h = ((x >> 24) | x) & 0xffffff;
    // Let w1 and w2 be the number of indices with coordinate 1 and 2
    w = mat24_bw24((uint32_t)h);
    // Compute ``gcode`` and ``cocode`` for vector x. Return 0 if we 
    // detect that is not of type 4. If ``omega`` is odd then ``gcode`` 
    // has to be corrected by a term 0xffffff. At the end of the
    // switch statemnt, ``gcode`` might not correspond to a Golay
    // code vector; this means that x is not of type 4.
    switch (w) {
        case 22:
            // type (5**1, 3**2, 1**21)
            syn = mat24_syndrome((uint32_t)x, 0);
            gcodev = (x ^ syn) & 0xffffff;
            t = h & syn;
            cocodev = t | (0xffffff & ~h);
            if ((t == 0) || (t & (t-1))) return 0;
            omega = 0;
            break;              
        case 19:
            // type (3**5, 1**19)
            w1 = mat24_bw24((uint32_t)x);
            x1 = ((w1 & 1) ? x : (x >> 24)) & 0xffffff;
            syn = mat24_syndrome(x1, 0);
            cocodev = ~h & 0xffffff;
            if (syn & h) syn = cocodev;            
            gcodev = (x1 ^ syn) & 0xffffff;
            omega = 0;
            break;
        case 16:
            // type (2**16, 0**8)
            w1 = mat24_bw24((uint32_t)x);
            if (w1 & 1) return 0;
            gcodev = h;
            omega = w1 >> 1;
            cocodev = x & 0xfffffff;
            break;
        case 13:
            // type (4**1, 2**12, 0**11)
        case 10:
            // type (4**2, 2**10, 0**14)
            syn = mat24_syndrome(h & 0xffffff, 0);
            if ((h & syn) != syn) return 0;                  
            gcodev = h ^ syn;
            cocodev = syn | (x & ~syn & 0xffffff);
            w1 = mat24_bw24(cocodev);
            if (w1 & 1)  return 0;
            omega = (w1 >> 1) + parity24(syn & x) + w;
            break; 
        case 7:
            // type (6**1, 2**7, 0**16)
            syn = mat24_syndrome(h, 0);
            if (syn & (syn - 1)) return 0;
            gcodev = h ^ syn;
            cocodev = (x & 0xffffff);
            w1 = mat24_bw24(cocodev);
            cocodev |=  (0 - (w1 & 1)) & syn;
            omega = ((w1 + 1) >> 1) + 1;
            break; 
        case 4:
            gcodev = 0;
            cocodev = h;
            omega = parity24(x);
            break;
        case 1:
            gcodev = cocodev = 0;
            omega = 1;
            break;    
        default:
            return 0;        
    }
    gcodev = mat24_vect_to_gcode(gcodev); 
    if (gcodev & 0xfffff000UL) return 0;
    cocodev = mat24_vect_to_cocode(cocodev);
    cocodev ^= MAT24_THETA_TABLE[gcodev & 0x7ff] & 0xfff;
    // correct ``gcodev`` by term ``Omega`` if omega is odd
    gcodev ^= (omega & 1) << 11;         
    res = (gcodev << 12) ^ cocodev;
    // Correct an odd result
    if (w >= 19 && parity12(res & (res >> 12))) res ^= 0x800000;
    return res;
}



/*************************************************************************
*** Multiply vector mod 3 by an atom group element
*************************************************************************/




// %%EXPORT px
uint64_t gen_leech3_op_xi(uint64_t v, uint32_t e)
{
    uint64_t a, b, t, ee1;
    e %= 3;
    if (e == 0) return v;

    ee1 = 0ULL - (uint64_t)((e - 1) & 1ULL);
    v ^= 0x111111111111ULL & ~ee1;
    // multiply x with matrix  (++++),    where '+' means 1
    //                         (++--)     and   '-' means -1
    //                         (+-+-)
    //                         (+--+)
    // reorder bits of a, 7 ops
    a = ((v & 0xaaaaaa555555ULL) ^ ((v >> 23) & 0xaaaaaaULL)
         ^ ((v & 0xaaaaaaULL) << 23));
    // special step
    a ^= 0xcccccc000000ULL;
    // split a
    b = (a >> 2) & 0x333333333333ULL;
    a &= 0x333333333333ULL;
    // 1st Hadamard step.11 ops
    t = a + b;
    b = a + (b ^ 0x333333333333ULL);
    a = t & 0x444444444444ULL;
    a = t - a + (a >> 2);
    t = b & 0x444444444444ULL;
    b = b - t + (t >> 2);
    // exchange high and low part of b
    b = ((b >> 24) & 0xffffffULL) + ((b & 0xffffffULL) << 24);
    // 2nd Hadamard step, 11 ops
    t = a + b;
    b = a + (b ^ 0x333333333333ULL);
    a = t & 0x444444444444ULL;
    a = t - a + (a >> 2);
    t = b & 0x444444444444ULL;
    b = b - t + (t >> 2);
    // unite a and b
    a = a ^ (b << 2);
    // special step
    a ^= 0xcccccc000000ULL;
    // reorder bits of a, 7 ops
    a = ((a & 0xaaaaaa555555ULL) ^ ((a >> 23) & 0xaaaaaaULL)
         ^ ((a & 0xaaaaaaULL) << 23));
    // matrix multipliction done
    a ^= 0x111111111111ULL & ee1; 
    return a;
}




static inline
uint64_t mul_vector3(uint64_t v3, uint32_t *pa, uint32_t n)
{
    uint_fast32_t tag, i, v;
    uint8_t perm[24], perm_i[24];

    for (i = 0; i < n; ++i) {
        v = pa[i];
        tag = v >> 28;
        v  &= 0xfffffff;
        switch(tag) {
            case 8:
            case 0:
            case 8 + 1:
            case 1:
            case 8 + 3:
            case 3:
               break;
            case 8 + 2:
               mat24_m24num_to_perm(v, perm);
               mat24_inv_perm(perm, perm_i);
               v3 = gen_leech3_op_pi(v3, perm_i);
               break;
            case 2:
               mat24_m24num_to_perm(v, perm);
               v3 = gen_leech3_op_pi(v3, perm);
               break;
            case 8 + 4:
            case 4:
               v3 = gen_leech3_op_y(v3, v & 0x1fffUL);
               break;
            case 8 + 5:
            case 5:
               v = v % 3;
               if (v) return 0xffff000000000000ULL;
               break;
            case 8 + 6:
               v ^= 0xfffffff;
            case 6:
               if (v)  v3 = gen_leech3_op_xi(v3, v);
               break;
            default:
               return 0xffff000000000000ULL;
        }
    }       
    return short_3_reduce(v3);
}



// %%EXPORT px
uint64_t gen_leech3_op_vector_word(uint64_t v3, uint32_t *pa, uint32_t n)
{
    return mul_vector3(v3, pa, n);
}

// %%EXPORT px
uint64_t gen_leech3_op_vector_atom(uint64_t v3, uint32_t v)
{
    return mul_vector3(v3, &v, 1);
}


// %%GEN ch
#ifdef __cplusplus
}
#endif




