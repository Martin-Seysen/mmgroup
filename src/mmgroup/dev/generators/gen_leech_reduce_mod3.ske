/** @file gen_leech_reduce_od3.c

This is yet a stub!!!
*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
/// @endcond 






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c






/// @cond DO_NOT_DOCUMENT 




static const uint32_t TABLE_SIGN_OCTADS[10] = {
  // %%TABLE Leech3SignOctads, uint32
};


static const uint8_t TABLE_POSITIONS[10][8] = {
  // %%TABLE Leech3BitPositions, uint8
};


static const uint8_t TABLE_UMBRAL9[9] = {
  0, 4, 8, 13,14,15, 17,18,19
};




/// @endcond



/*******************************************************************
*** Subroutines for finding a good tetrad for reduction
*******************************************************************/


/// @cond DO_NOT_DOCUMENT

static inline
uint32_t augment_bitvector(uint32_t v, uint32_t source, uint32_t weight)
{
    /* Add bits taken from ``source`` to bit vector ``v``

    The function removes bit from bit vector ``source`` and adds them
    to bit vector ``v`` until ``source`` is zero or ``v`` has bit
    weight ``weight``. It returns the augmented bit vector ``v``.
    */
    uint32_t w, b0;
    source &= 0xffffff & ~v;
    w =  mat24_bw24(v);
    while (w < weight && source) {
        b0 = source & (0 - source);
        v |= b0;
        source &= ~b0;
        w += 1;
    }
    return v;
}


static inline
uint32_t neg_points_hexadecad(uint32_t gc, uint32_t neg, uint32_t sub)
{
    /* Deal with subset of 'negative points' in a hexadecad

    Let ``gc`` be a bit vector that is a hexadecad (i.e. has weight 16)
    and that is in the Golay gode.  Let ``neg`` be a subset of bits
    of ``gc`` that are considered as 'negative'. We assume that we may
    change the signs of the bits in ``gc`` by flipping the signs of all
    bits of a Golay code word.
    Here we ignore the signs of the bits outside of ``gc``. Then it can
    be shown that we can reduce the bit weight  of ``neg`` to 2 by a
    sequence of such sign flips (ignoring the bits outside ``gc``).

    Let ``sub`` be a subset of ``gc`` such that the sigs of the bits
    in  ``sub`` can also be ignored. If sub is nonzero, we may further
    reduce bit weight of ``neg`` to 1 by sign flips as above, provided
    that we also ignore the signs of the bits in ``sub``.

    The function returns a modified subset ``neg`` of ``gc & ~sub``
    (obtained from input ``neg``  by sign flips as described above)
    such that the bit weight out the output ``neg`` is minimal.
    */
    uint32_t o, w, pool;
    sub &= gc;
    o = ~gc & 0xffffff;
    neg = mat24_syndrome(neg, mat24_lsbit24(o)) & gc & ~sub;
    w = mat24_bw24(neg);
    if (w < 2 || (w == 2 && sub == 0)) return neg;
    pool = augment_bitvector(neg, sub, 3);
    return mat24_intersect_octad_tetrad(o, pool) & gc & ~pool &~sub;
}


static inline
uint32_t cohexad(uint32_t dodecad, uint32_t duad, uint32_t included)
{
    /* Compute hexad from dodecad an duad.

    If ``dodecad`` is a dodecad and ``duad`` is a duad (i.e. a set
    of weight 2) disjoint to the dodecad then the complement of the
    dodecad contains precisely to (disjoint) hexads that complete
    the duad to a octad. The function returns one of these hexads.
    If  ``include`` is a subset of the complement of the dodecad of
    weight 1 then then hexad containing that subset is returned.
    */
    uint32_t hexad = mat24_cocode_as_subdodecad(
        mat24_vect_to_cocode(duad & 0xffffff),
        mat24_vect_to_gcode(dodecad & 0xffffff),
        0);
    if ((included & hexad) == 0)  hexad ^= dodecad;
    return hexad;
}


typedef struct {
    uint32_t v;        // bit vector v for which to compute the syndrome
    uint32_t w_v;      // weight of bit vector v
    uint32_t w_syn;    // common bit weigt of all syndromes
    uint32_t len ;      // number of syndromes of minimal weight
    uint32_t syn[6];   // list of syndromes, 0 < index < len_syn
    uint32_t w_add[6]; // x.w_add[i] is weight of (x.v & x.syn[i])
} syndrome_type;


static inline
syndrome_type bitvector_syndromes(uint32_t v)
{
    /* Compute Golay code syndromes of a vector and their weights

    Given a bit vector vector ``v``, the function returns a triple
    ``(w_v, w_syn, syn_list)``. Here ``w_v`` is the bit weight of
    vector ``v``, and ``w_syn`` is the common bit weight of all
    Golay code syndromes computed. ``syn_list`` is a list of pairs
    ``(w_add, syn)``. Any such pair denotes a Golay code syndrome
    ``syn``, such that ``syn & v`` has bit weight ``w_add``.

    Note that ``gc = v ^ syn`` is a Golay code word. If ``gc`` is
    a docecad (i.e. has bit weight 12), and there is another
    syndrome ``syn1`` such that ``v ^ syn1`` is not a dodecad,   
    then we make sure that ``v ^ syn_list[0][1]`` is not a doceacd.
    */
    syndrome_type sy;
    uint32_t i, w_gc, tmp;
    sy.v = v;
    sy.w_v = mat24_bw24(v);
    sy.len = mat24_all_syndromes(v, sy.syn);
    sy.w_syn = mat24_bw24(sy.syn[0]);
    for (i = 0; i < sy.len; ++i) {
        sy.w_add[i] = mat24_bw24(sy.syn[i] & v);
    }
    w_gc = sy.w_v + sy.w_syn - 2 * sy.w_add[0];
    if (w_gc == 12) {
         for (i = 0; i < sy.len; ++i ) {
             if (sy.w_add[i] != sy.w_add[0]) {
                  tmp = sy.w_add[0];
                  sy.w_add[0] = sy.w_add[i];
                  sy.w_add[i] = tmp;
                  tmp = sy.syn[0];
                  sy.syn[0] = sy.syn[i];
                  sy.syn[i] = tmp;
                  break;
             }
         }
    }
    return sy;
}


static inline
uint32_t reduce_even(syndrome_type sy)
{
    /* Do vector in Leech lattice mod3 with Hamming distance 0 or 4

    Let ``sy`` be as obtained from applying function
    ``bitvector_syndromes`` to the bit vector ``v``. If ``w_syn`` is
    0 or 4 then the function returns a tetrad suitable for reducing
    vector ``v`` as described in function ``find_tetrad_leech_mod3``.
    Otherwise the function returns 0 meaning that not tetrad has
    been found.
    */
    if (sy.w_syn == 4) {
        uint32_t w = 0, i, tet = 0;
        for (i = 0; i < sy.len; ++i) {
        // for w0, syn in syn_list:
            if (sy.w_add[i] == 4) return sy.syn[i];
            if (w < 4) {
                tet |= sy.syn[i] & sy.v;
                w += sy.w_add[i];
            }
        }
        return (w == 4) ? tet : 0;
    }
    if (sy.w_syn == 0)  return augment_bitvector(0, sy.v, 4);
    return 0;
}



static inline
uint32_t find_tetrad_16_large(uint32_t gc, uint32_t sub)
{
    /* Do vector in Leech lattice mod3 with support close to a hexadecad

    Let ``gc`` be a bit vector that is a hexadecad (i.e. has weight 16)
    and that is in the Golay gode. The 16 bits of ``gc`` have a natural
    structure as an affine 4-dimensional svace ofer ``GF(2)`` Let
    ``sub`` be a subset of ``gc`` of weight at most 4. If ``sub`` can
    be completed to an affine plane in ``gc`` then the function
    returns the four points of that affine plane as a tetrad. Otherwise
    the function returns a tetrad corrsponding to an affine plane in
    ``gc`` such that each plane in ``gc`` parallel to that tetrad
    intersects with ``sub`` in 0 or 2 points.
    */
    uint32_t tet, p0, p1, plane, remain, point, line;
    if (mat24_bw24(sub) == 3) {
        tet = mat24_intersect_octad_tetrad(gc, sub) & gc;
        return tet;
    }
    p0 = sub & (0 - sub);
    remain = sub & ~p0;
    plane = mat24_intersect_octad_tetrad(gc, remain) & gc;
    if (sub == plane) return plane;
    p1 = plane & ~remain;
    // assert mat24_bw24(p1) == 1;
    line = p0 | p1;
    while (remain) {
        point = remain & (0 - remain);
        remain &= ~point;
        tet = mat24_intersect_octad_tetrad(gc, point | line) & gc;
        if (mat24_bw24(tet & sub) == 2) return tet;
    }
    return 0;
}


/// @endcond

/*******************************************************************
*** Find a good tetrad for reduction
*******************************************************************/


/**
    @brief Find tetrad suitable for reduction in Leech lattice mod 3

    Let ``a`` be a vector in the Leech lattice mod 3 given in
    Leech lattice mod 3 encoding. Let the ``v`` be the support
    of ``a``, i.e. the bit vector containing the the nonzero
    entries of ``a``.

    The function returns a tetrad ``t`` that may be used by
    function ``reduce_tetrad_leech_mod3`` to find an
    element ``g`` of the group \f$\mbox{Co}_1\f$ such that
    the support of ``a * g`` has bit weight less than the weight
    of ``v``. The function returns 0 if no such tetrad can be found.

    This procedure reduces the bit weight of ``v`` by

    - at least 12 if ``v`` has bit weight 20, 22, 23, or 24

    - at least 6 if ``v`` has bit weight 19 or more

    - at least 3 except in the following cases:

      - ``v`` has bit weight 5 or less than 4

      - ``v`` is an umbral hexad, heptad, nonad or undecad

      - ``v`` is a transversal octad

      - ``v`` is a special nonad and the unique octad contained
              in ``v`` contains an odd number of entries -1.

    For characterizing the bit vector ``v`` we use the termminology
    in [CS99], Ch. 10.2.6.

    The function returns 0 if the bit weight of ``v`` cannot be
    reduced and a negative value in case of failure.
*/
// %%EXPORT px
int32_t gen_leech3_find_tetrad_leech_mod3(uint64_t a)
{
    syndrome_type sy;
    uint32_t v, neg, w_add, syn, gc, w_gc, add, sub, w_sub, tet;
    v = (uint32_t)((a ^ (a >> 24)) & 0xffffff); // non-zero entries of a
    neg =  (uint32_t)(a & v);                   // 'negative' entries of a
    sy = bitvector_syndromes(v);
    if (sy.w_v >= 20) {
        uint32_t outside, outside_bit;
        outside = (0xffffff & ~v);
        outside_bit = mat24_lsbit24(outside | 0x800000);
        neg = mat24_syndrome(neg, outside_bit);
        tet = augment_bitvector(outside, neg, 4);
        return augment_bitvector(tet, 0xffffff, 4);
    }
    if (sy.w_v <= 5) {
        return sy.w_v == 4 ? v : 0;
    }
    w_add = sy.w_add[0];
    syn = sy.syn[0];
    gc = v ^ syn;                         // gc is a Golay code word
    w_gc = sy.w_v + sy.w_syn - 2 * w_add; // bit weight of gc
    add = syn & v;                        // v = (gc | add) & ~sub,
    sub = syn & ~v;                       // syn = gc ^ v = add | sub
    w_sub = sy.w_syn - w_add;             // bit weight of sub

    if (w_gc == 16 && w_sub < 4) {
        // The case w_add = 4 (i.e. w = 20) has been done above
        neg = neg_points_hexadecad(gc, neg, sub);
        if (w_sub >= 3) {
            sub = augment_bitvector(sub, neg, 4);
            return find_tetrad_16_large(gc, sub) ;
        }
        tet = gc & mat24_intersect_octad_tetrad(gc, sub | add);
        return tet ? tet : -1;
    }

    if (w_gc == 8) {
        if (w_add == 1 && (w_sub | (mat24_bw24(gc & neg) & 1)))
            return 0;
        tet = gc & mat24_intersect_octad_tetrad(gc, sub | add);
        if (tet) return tet;
    }

    if ((w_sub & 1) == 0 && (sy.w_syn & 3) == 0) {
        return reduce_even(sy);
    }

    if (w_gc == 12) {
        uint32_t hexad;
        // The cases w_sub + w_add == 4 and w_sub == w_add == 0 (mod 2)
        // have been done above.
        if (w_add == 3) {
            return augment_bitvector(add, ~gc, 4);
        }
        if (w_sub == 2 && w_add == 0) {
            hexad = cohexad(~gc, sub, add);
            return augment_bitvector(0, hexad, 4);
        }
        // Here (w_sub, w_add) is (0, 1), (1, 0), (1, 1), (1, 2),
        // (2, 1), or (3, 0).
        if (w_add == 2) {
            hexad = cohexad(gc, add, sub);
            sub =  augment_bitvector(sub, hexad, 2);
            return hexad & ~sub;
        }
        if (w_add == 1) {
            sub = augment_bitvector(sub, gc, 2);
            hexad = cohexad(~gc, sub, add);
            if (w_sub < 2) {
                return augment_bitvector(add | sub, hexad, 4);
            } else {
                hexad = (hexad ^ ~gc) & 0xffffff;
                return augment_bitvector(sub, hexad, 4);
            }
        }
        // Here (w_sub, w_add) is (1, 0) or (3, 0). We cannot reduce
        // the case (3, 0). There may be a trick for reducing the case
        // (1, 0), i.e. an umbral undecad. Here we essentially have to
        // 'move' duads inside a tetrad. This is not implemented here.
        return 0;
    }

    return -1;
}


/*******************************************************************
*** Multiply vector in Leech lattice mod 3 with group element
*******************************************************************/

/// @cond DO_NOT_DOCUMENT

#define MAX_LEECH3_G 12

typedef struct {
    uint64_t a;                // vector in Lecch lattice mod 3 encoding
    uint32_t g[MAX_LEECH3_G];  // Element of subgroup G_x0 of the Monster
    uint32_t len_g;            // length of word in component g
    int32_t status;            // Any nonzero value indicates an error
} leech3_record_type;
 

static inline 
void leech3_record_load(leech3_record_type *r, uint64_t a)
{
    r->a = a; r->len_g = r->status = 0; 
}


static inline 
void leech3_record_mul_atom(leech3_record_type *r, uint32_t atom)
{
    if (r->status) return;
    if (r->len_g >= MAX_LEECH3_G) {
        r->status = -1;
        return;
    }
    r->g[r->len_g++] =
        gen_leech3_op_vector_word(r->g[r->len_g], &atom, 1);
}


static inline 
void leech3_record_mul_perm_map(
   leech3_record_type *r,
   uint8_t *source,
   uint8_t *dest,
   int32_t length
)
// Multiply vector stored in ``r`` with a permutation in the Mathieu
// group that maps the first ``length`` entries of ``source`` to the
// first `length`` entries of ``dest``.
{
    uint32_t res, atom;
    uint8_t pi[32];
    if (mat24_perm_from_map(source, dest, length, pi) <= 0) {
        r->status = -1;
        return;
    }
    atom = 0x20000000 + mat24_perm_to_m24num(pi);
    leech3_record_mul_atom(r, atom);
}


static inline 
void leech3_record_mul_perm_tet(
   leech3_record_type *r,
   uint32_t tet
)
// Multiply vector stored in ``r`` with a permutation in the Mathieu
// group that maps the tetrad ``tet`` (in vector representation)
// to the standard tetrad 
{
    uint8_t tet_bits[32];
    static uint8_t STD_TET[4] = {0, 1, 2, 3};
    if (mat24_vect_to_bit_list(tet, tet_bits) != 4) {
        r->status = -1;
        return;
    }
    leech3_record_mul_perm_map(r, tet_bits, STD_TET, 4);
}


static inline 
void leech3_record_mul_perm_y(
   leech3_record_type *r,
   uint32_t v
)
// Multiply vector stored in ``r`` with a generator ``y_v`` in the
// group G_y0 that negates exactly the bits in GF(2^24) that sre set
// in the bit vector ``v``. Here ``v`` must be a Golay code word.
{
    uint32_t gc = mat24_vect_to_gcode(v);
    if (v & 0xfffff000) {
        r->status = -1;
        return;
    }
    leech3_record_mul_atom(r, 0x40000000 + gc);
}







/// @endcond DO_NOT_DOCUMENT


/*******************************************************************
*** Special reduction for an umbral undecad
*******************************************************************/

/// @cond DO_NOT_DOCUMENT


static inline
uint32_t neg_dodecad(uint32_t v, uint32_t syn, uint32_t neg)
{
    /* Adjust signs of a weight-11 vector in Leech lattice mod 3

    Let ``v`` be the support of a vector ``w`` in the Leech lattice
    mod 3, i.e. the bit vector containing the  nonzero entries 
    of ``w``. Here ``v``must be a umbral undecad, and the (disjoint)
    union of ``v`` and the singleton ``syn`` must be a umbral 
    dodecad. Let ``neg`` be the bit vector containing the bits
    where ``w`` has an entry -1.
    
    We may change the signs of a vector in ``w`` by flipping the
    signs of all entries corresponding to the bits of a Golay code
    word. The function returns a suitable Golay code wort ``gc`` (as
    a bit vector) such that flipping the signs in ``w`` corresponding
    to the bits in ``gc`` makes all entries of ``w`` nonegative. 
    */  
    uint32_t neg1 = mat24_cocode_as_subdodecad(
        mat24_vect_to_cocode(neg = neg &= v),
        mat24_vect_to_gcode(0xffffff & ~(v | syn)),
        mat24_lsbit24(syn)
    );
    return neg | neg1;
}

    




/// @endcond DO_NOT_DOCUMENT



//  %%GEN h
/// @endcond 
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




