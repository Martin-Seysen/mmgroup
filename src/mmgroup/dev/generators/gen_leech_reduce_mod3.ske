/** @file gen_leech_reduce_mod3.c

The orbits of the automorphism group \f$2.\mbox{Co}_{1}\f$ of the Leech
lattice \f$\Lambda\f$ on the vectors of norm up to 22 are described in
[CS99], Ch. 10.3.3.
There the *type* of a vector is its halved norm; and a more specific
type (e.g. type \f$9_{33}\f$) is is assigned to each orbit of type 11
or smaller.

Let \f$\Lambda / 3\Lambda\f$ be the Leech lattice mod 3. The
automorphism group of \f$\Lambda / 3\Lambda\f$
is also \f$2.\mbox{Co}_{1}\f$.
A vector \f$v\f$ in \f$\Lambda / 3\Lambda\f$ has a preimage
in \f$\Lambda\f$ of type at most 9; and all shortest preimages
of \f$v\f$ in \f$\Lambda\f$ are in the same \f$2.\mbox{Co}_{1}\f$
orbit. So the \f$2.\mbox{Co}_{1}\f$ orbit of a vector
in \f$\Lambda / 3\Lambda\f$ may be described by the type
of the orbit of its shortest preimage in \f$\Lambda\f$.

Then main function ``gen_leech3_reduce_leech_mod3`` in this module
maps a vector in the Leech lattice modulo 3 to a representative
of its \f$2.\mbox{Co}_{1}\f$ orbit.


In the following table the first three columns describe the
orbits of \f$2.\mbox{Co}_{1}\f$ on  \f$\Lambda / 3\Lambda\f$.


 * Column 1 is the name of the orbit, using the terminoloy in [CS99],
   Ch. 10.3.3.

 * Column 2 describes the automorphism group of the orbit.

 * Column 3 contains the number of shortest vectors
   of \f$\Lambda\f$  in the orbit.

A vector \f$v\f$ in \f$\Lambda / 3\Lambda\f$ is described by the
entries (modulo 3) of any preimage of \f$v\f$ in \f$\Lambda\f$,
using the natural co-ordinate frame of  \f$\Lambda\f$. The *support*
of vector \f$v\f$ is the set of the nonzero co-ordiantes of \f$v\f$.
The support of \f$v\f$ has a natural interpretation as a bit vector in
the underlying space \f$\mbox{GF}_2^{24}\f$ of the Golay code used in
the construction of \f$\Lambda\f$. The orbits of the automorphism
group \f$\mbox{M}_{24}\f$ of the Golay code on \f$\mbox{GF}_2^{24}\f$
are described in [CS99], Ch. 10.2.6.
In all but one case all coordinates of our chosen representative of an
orbit of  \f$\Lambda / 3\Lambda\f$ are 0 or 1.


The last three columns of the table describe our chosen
representative \f$v\f$ of an orbit of \f$2.\mbox{Co}_{1}\f$
on  \f$\Lambda / 3\Lambda\f$.

 * Column 4 contains the name of the orbit of the support of \f$v\f$
   under the action of \f$\mbox{M}_{24}\f$, as described in [CS99],
   Ch. 10.2.6.

 * Column 5 contains the suport of \f$v\f$ as a bit vector. Here we use
   the basis of the natural co-ordinate frame of \f$\Lambda\f$. This
   basis corresponds to the basis of \f$\mbox{GF}_2^{24}\f$ described
   in the *mmgroup API reference*,
   section *The basis of the Golay code and of its cocode*.  We adopt
   the hexadecimal notation for bit vectors in \f$\mbox{GF}_2^{24}\f$
   from that section.

 * Column 6 contains the list of the indices of the coordinates
   of  \f$v\f$ that are equal to -1 (if any).




<table>
<caption id="multi_row">Types of vectors in Leech lattice mod 3 </caption>
<tr><th colspan="3"> Type in Leech lattice mod 3 <th colspan="3"> Representative
<tr><th> Leech type   <th>  Aut                           <th> n
                      <th> \f$\mbox{M}_{24}\f$ set        <th> support      <th> neg
<tr><td> \f$0\f$      <td> \f$2.\mbox{Co}_{1}\f$          <td> 1
                      <td> \f$(0)\f$                      <td> ``0x000000`` <td>
<tr><td> \f$2\f$      <td> \f$\mbox{Co}_2\f$              <td> 1
                      <td> \f$S_2\f$                      <td> ``0x00000c`` <td>
<tr><td> \f$3\f$      <td> \f$\mbox{Co}_3\f$              <td> 1
                      <td> \f$S_9\f$                      <td> ``0x0001ff`` <td> ``[0]``
<tr><td> \f$4\f$      <td> \f$2^{11}.\mbox{M}_{23}\f$     <td> 1
                      <td> \f$S_1\f$                      <td> ``0x000001`` <td>
<tr><td> \f$5\f$      <td> \f$\mbox{McL}\f$               <td> 1
                      <td> \f$T_8\f$                      <td> ``0x0001fe`` <td>
<tr><td> \f$6_{23}\f$ <td> \f$\mbox{M}_{24}\f$            <td> 1
                      <td> \f$U_6\f$                      <td> ``0x111111`` <td>
<tr><td> \f$6_{22}\f$ <td> \f$\mbox{PSU}_6(2):S_3\f$      <td> 3
                      <td> \f$S_3\f$                      <td> ``0x00000e`` <td>
<tr><td> \f$7\f$      <td> \f$\mbox{HS}:{2}\f$            <td> 2
                      <td> \f$U_7\f$                      <td> ``0x0001f3`` <td>
<tr><td> \f$8_{42}\f$ <td> \f$2^{1+8}.\mbox{A}_{9}\f$     <td> 9
                      <td> \f$S_5\f$                      <td> ``0x0000f1`` <td>
<tr><td> \f$9_{33}\f$ <td> \f$3^6:2.\mbox{M}_{12}\f$      <td> 36
                      <td> \f$U_9\f$                      <td> ``0xeee000`` <td>
</table>




*/




/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
/// @endcond 






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c






/// @cond DO_NOT_DOCUMENT 




static uint32_t TABLE_SIGN_OCTADS[10] = {
  // %%TABLE Leech3SignOctads, uint32
};


static uint8_t TABLE_POSITIONS[10][8] = {
  // %%TABLE Leech3BitPositions, uint8
};


static uint8_t TABLE_UMBRAL9[9] = {
  0, 4, 8, 13, 14, 15, 17, 18, 19
};




/// @endcond



/*******************************************************************
*** Subroutines for finding a good tetrad for reduction
*******************************************************************/


/// @cond DO_NOT_DOCUMENT

static inline
uint32_t augment_bitvector(uint32_t v, uint32_t source, uint32_t weight)
{
    /* Add bits taken from ``source`` to bit vector ``v``

    The function removes bit from bit vector ``source`` and adds them
    to bit vector ``v`` until ``source`` is zero or ``v`` has bit
    weight ``weight``. It returns the augmented bit vector ``v``.
    */
    uint32_t w, b0;
    source &= 0xffffff & ~v;
    w =  mat24_bw24(v);
    while (w < weight && source) {
        b0 = source & (0 - source);
        v |= b0;
        source &= ~b0;
        w += 1;
    }
    return v;
}


static inline
uint32_t neg_points_hexadecad(uint32_t gc, uint32_t neg, uint32_t sub)
{
    /* Deal with subset of 'negative points' in a hexadecad

    Let ``gc`` be a bit vector that is a hexadecad (i.e. has weight 16)
    and that is in the Golay gode.  Let ``neg`` be a subset of bits
    of ``gc`` that are considered as 'negative'. We assume that we may
    change the signs of the bits in ``gc`` by flipping the signs of all
    bits of a Golay code word.
    Here we ignore the signs of the bits outside of ``gc``. Then it can
    be shown that we can reduce the bit weight  of ``neg`` to 2 by a
    sequence of such sign flips (ignoring the bits outside ``gc``).

    Let ``sub`` be a subset of ``gc`` such that the sigs of the bits
    in  ``sub`` can also be ignored. If sub is nonzero, we may further
    reduce bit weight of ``neg`` to 1 by sign flips as above, provided
    that we also ignore the signs of the bits in ``sub``.

    The function returns a modified subset ``neg`` of ``gc & ~sub``
    (obtained from input ``neg``  by sign flips as described above)
    such that the bit weight out the output ``neg`` is minimal.
    */
    uint32_t o, w, pool;
    sub &= gc;
    o = ~gc & 0xffffff;
    neg = mat24_syndrome(neg, mat24_lsbit24(o)) & gc & ~sub;
    w = mat24_bw24(neg);
    if (w < 2 || (w == 2 && sub == 0)) return neg;
    pool = augment_bitvector(neg, sub, 3);
    return mat24_intersect_octad_tetrad(o, pool) & gc & ~pool &~sub;
}


static inline
uint32_t cohexad(uint32_t dodecad, uint32_t duad, uint32_t included)
{
    /* Compute hexad from dodecad an duad.

    If ``dodecad`` is a dodecad and ``duad`` is a duad (i.e. a set
    of weight 2) disjoint to the dodecad then the complement of the
    dodecad contains precisely to (disjoint) hexads that complete
    the duad to a octad. The function returns one of these hexads.
    If  ``include`` is a subset of the complement of the dodecad of
    weight 1 then then hexad containing that subset is returned.
    */
    uint32_t hexad = mat24_cocode_as_subdodecad(
        mat24_vect_to_cocode(duad & 0xffffff),
        mat24_vect_to_gcode(dodecad & 0xffffff),
        0);
    if ((included & hexad) == 0)  hexad ^= dodecad;
    return hexad;
}


typedef struct {
    uint32_t v;        // bit vector v for which to compute the syndrome
    uint32_t w_v;      // weight of bit vector v
    uint32_t w_syn;    // common bit weigt of all syndromes
    uint32_t len ;      // number of syndromes of minimal weight
    uint32_t syn[6];   // list of syndromes, 0 < index < len_syn
    uint32_t w_add[6]; // x.w_add[i] is weight of (x.v & x.syn[i])
} syndrome_type;


static inline
syndrome_type bitvector_syndromes(uint32_t v)
{
    /* Compute Golay code syndromes of a vector and their weights

    Given a bit vector vector ``v``, the function returns a triple
    ``(w_v, w_syn, syn_list)``. Here ``w_v`` is the bit weight of
    vector ``v``, and ``w_syn`` is the common bit weight of all
    Golay code syndromes computed. ``syn_list`` is a list of pairs
    ``(w_add, syn)``. Any such pair denotes a Golay code syndrome
    ``syn``, such that ``syn & v`` has bit weight ``w_add``.

    Note that ``gc = v ^ syn`` is a Golay code word. If ``gc`` is
    a docecad (i.e. has bit weight 12), and there is another
    syndrome ``syn1`` such that ``v ^ syn1`` is not a dodecad,   
    then we make sure that ``v ^ syn_list[0][1]`` is not a doceacd.
    */
    syndrome_type sy;
    uint32_t i, w_gc, tmp;
    sy.v = v;
    sy.w_v = mat24_bw24(v);
    sy.len = mat24_all_syndromes(v, sy.syn);
    sy.w_syn = mat24_bw24(sy.syn[0]);
    for (i = 0; i < sy.len; ++i) {
        sy.w_add[i] = mat24_bw24(sy.syn[i] & v);
    }
    w_gc = sy.w_v + sy.w_syn - 2 * sy.w_add[0];
    if (w_gc == 12) {
         for (i = 0; i < sy.len; ++i ) {
             if (sy.w_add[i] != sy.w_add[0]) {
                  tmp = sy.w_add[0];
                  sy.w_add[0] = sy.w_add[i];
                  sy.w_add[i] = tmp;
                  tmp = sy.syn[0];
                  sy.syn[0] = sy.syn[i];
                  sy.syn[i] = tmp;
                  break;
             }
         }
    }
    return sy;
}


static inline
uint32_t reduce_even(syndrome_type sy)
{
    /* Do vector in Leech lattice mod3 with Hamming distance 0 or 4

    Let ``sy`` be as obtained from applying function
    ``bitvector_syndromes`` to the bit vector ``v``. If ``w_syn`` is
    0 or 4 then the function returns a tetrad suitable for reducing
    vector ``v`` as described in function ``find_tetrad_leech_mod3``.
    Otherwise the function returns 0 meaning that not tetrad has
    been found.
    */
    if (sy.w_syn == 4) {
        uint32_t w = 0, i, tet = 0;
        for (i = 0; i < sy.len; ++i) {
        // for w0, syn in syn_list:
            if (sy.w_add[i] == 4) return sy.syn[i];
            if (w < 4) {
                tet |= sy.syn[i] & sy.v;
                w += sy.w_add[i];
            }
        }
        return (w == 4) ? tet : 0;
    }
    if (sy.w_syn == 0)  return augment_bitvector(0, sy.v, 4);
    return 0;
}



static inline
uint32_t find_tetrad_16_large(uint32_t gc, uint32_t sub)
{
    /* Do vector in Leech lattice mod3 with support close to a hexadecad

    Let ``gc`` be a bit vector that is a hexadecad (i.e. has weight 16)
    and that is in the Golay gode. The 16 bits of ``gc`` have a natural
    structure as an affine 4-dimensional svace ofer ``GF(2)`` Let
    ``sub`` be a subset of ``gc`` of weight at most 4. If ``sub`` can
    be completed to an affine plane in ``gc`` then the function
    returns the four points of that affine plane as a tetrad. Otherwise
    the function returns a tetrad corrsponding to an affine plane in
    ``gc`` such that each plane in ``gc`` parallel to that tetrad
    intersects with ``sub`` in 0 or 2 points.
    */
    uint32_t tet, p0, p1, plane, remain, point, line;
    if (mat24_bw24(sub) == 3) {
        tet = mat24_intersect_octad_tetrad(gc, sub) & gc;
        return tet;
    }
    p0 = sub & (0 - sub);
    remain = sub & ~p0;
    plane = mat24_intersect_octad_tetrad(gc, remain) & gc;
    if (sub == plane) return plane;
    p1 = plane & ~remain;
    // assert mat24_bw24(p1) == 1;
    line = p0 | p1;
    while (remain) {
        point = remain & (0 - remain);
        remain &= ~point;
        tet = mat24_intersect_octad_tetrad(gc, point | line) & gc;
        if (mat24_bw24(tet & sub) == 2) return tet;
    }
    return 0;
}


/// @endcond

/*******************************************************************
*** Find a good tetrad for reduction
*******************************************************************/


/**
    @brief Auxiliary function for function ``gen_leech3_reduce_leech_mod3``

    This function is not for public use!

    The function tries to find tetrad suitable for reducing a
    vector in the Leech lattice mod 3

    Let ``a`` be a vector in the Leech lattice mod 3 given in
    Leech lattice mod 3 encoding. Let the ``v`` be the support
    of ``a``, i.e. the bit vector containing the the nonzero
    entries of ``a``.

    The function returns a tetrad ``t`` that may be used by
    function ``reduce_tetrad_leech_mod3`` to find an
    element ``g`` of the group \f$\mbox{Co}_1\f$ such that
    the support of ``a * g`` has bit weight less than the weight
    of ``v``. The function returns 0 if no such tetrad can be found.

    This procedure reduces the bit weight of ``v`` by

    - at least 12 if ``v`` has bit weight 20, 22, 23, or 24

    - at least 6 if ``v`` has bit weight 19 or more

    - at least 3 except in the following cases:

      - ``v`` has bit weight 5 or less than 4

      - ``v`` is an umbral hexad, heptad, nonad or undecad

      - ``v`` is a transversal octad

      - ``v`` is a special nonad and the unique octad contained
              in ``v`` contains an odd number of entries -1.

    For characterizing the bit vector ``v`` we use the termminology
    in [CS99], Ch. 10.2.6.

    The function returns 0 if the bit weight of ``v`` cannot be
    reduced and a negative value in case of failure.
*/
// %%EXPORT px
int32_t gen_leech3_find_tetrad_leech_mod3(uint64_t a)
{
    syndrome_type sy;
    uint32_t v, neg, w_add, syn, gc, w_gc, add, sub, w_sub, tet;
    a = short_3_reduce(a); 
    v = (uint32_t)((a | (a >> 24)) & 0xffffff); // non-zero entries of a
    neg =  (uint32_t)(a & v);                   // 'negative' entries of a
    sy = bitvector_syndromes(v);
    if (sy.w_v >= 20) {
        uint32_t outside, outside_bit;
        outside = (0xffffff & ~v);
        outside_bit = mat24_lsbit24(outside | 0x800000);
        neg = mat24_syndrome(neg, outside_bit);
        tet = augment_bitvector(outside, neg, 4);
        return augment_bitvector(tet, 0xffffff, 4);
    }
    if (sy.w_v <= 5) {
        return sy.w_v == 4 ? v : 0;
    }
    w_add = sy.w_add[0];
    syn = sy.syn[0];
    gc = v ^ syn;                         // gc is a Golay code word
    w_gc = sy.w_v + sy.w_syn - 2 * w_add; // bit weight of gc
    add = syn & v;                        // v = (gc | add) & ~sub,
    sub = syn & ~v;                       // syn = gc ^ v = add | sub
    w_sub = sy.w_syn - w_add;             // bit weight of sub

    if (w_gc == 16 && w_sub < 4) {
        // The case w_add = 4 (i.e. w = 20) has been done above
        neg = neg_points_hexadecad(gc, neg, sub);
        if (w_sub >= 3) {
            sub = augment_bitvector(sub, neg, 4);
            return find_tetrad_16_large(gc, sub) ;
        }
        tet = gc & mat24_intersect_octad_tetrad(gc, sub | add);
        return tet ? tet : -1;
    }

    if (w_gc == 8) {
        if (w_add == 1 && (w_sub | (mat24_bw24(gc & neg) & 1)))
            return 0;
        tet = gc & mat24_intersect_octad_tetrad(gc, sub | add);
        if (tet) return tet;
    }

    if ((w_sub & 1) == 0 && (sy.w_syn & 3) == 0) {
        return reduce_even(sy);
    }

    if (w_gc == 12) {
        uint32_t hexad;
        // The cases w_sub + w_add == 4 and w_sub == w_add == 0 (mod 2)
        // have been done above.
        if (w_add == 3) {
            return augment_bitvector(add, ~gc, 4);
        }
        if (w_sub == 2 && w_add == 0) {
            hexad = cohexad(~gc, sub, add);
            return augment_bitvector(0, hexad, 4);
        }
        // Here (w_sub, w_add) is (0, 1), (1, 0), (1, 1), (1, 2),
        // (2, 1), or (3, 0).
        if (w_add == 2) {
            hexad = cohexad(gc, add, sub);
            sub =  augment_bitvector(sub, hexad, 2);
            return hexad & ~sub;
        }
        if (w_add == 1) {
            sub = augment_bitvector(sub, gc, 2);
            hexad = cohexad(~gc, sub, add);
            if (w_sub < 2) {
                return augment_bitvector(add | sub, hexad, 4);
            } else {
                hexad = (hexad ^ ~gc) & 0xffffff;
                return augment_bitvector(sub, hexad, 4);
            }
        }
        // Here (w_sub, w_add) is (1, 0) or (3, 0).
        if (w_sub == 1) {
            // Case (1, 0), i.e. support is an umbral undecad.
            return 0x1000000 + augment_bitvector(sub, v, 4);
        } 
        return 0;
    }

    return -1;
}


/*******************************************************************
*** Multiply vector in Leech lattice mod 3 with group element
*******************************************************************/

/// @cond DO_NOT_DOCUMENT

#define MAX_LEECH3_G 12

typedef struct {
    uint64_t a;               // vector in Lecch lattice mod 3 encoding
    uint64_t status;          // Any nonzero value indicates an error
    uint32_t g[MAX_LEECH3_G]; // Element of subgroup G_x0 of the Monster
    uint32_t len_g;           // length of word in component g
} leech3_record_type;
 
static inline 
void leech3_record_load(leech3_record_type *r, uint64_t a)
{
    r->a = a; r->len_g = 0; r->status = 0; 
}

static
void leech3_record_error(leech3_record_type *r, uint64_t error)
{
    if (r->status == 0) r->status = error & 0x3fffffffffffffffULL; 
}

static inline 
uint32_t leech3_record_support(leech3_record_type *r)
{
    r->a = short_3_reduce(r->a);
    return (uint32_t)((r->a | (r->a >> 24)) & 0xffffff);
}

static inline 
uint32_t leech3_record_neg(leech3_record_type *r)
{
    r->a = short_3_reduce(r->a);
    return (uint32_t)((r->a >> 24) & 0xffffff);
}

static inline 
void leech3_record_mul_gen(leech3_record_type *r, uint32_t gen)
{
    if (r->status || r->len_g >= MAX_LEECH3_G) {
        leech3_record_error(r, 1);
    } else {
        r->g[r->len_g++] = gen;
        r->a = gen_leech3_op_vector_atom(r->a, gen);
    }
}

static inline 
void leech3_record_mul_perm(leech3_record_type *r, uint8_t *pi)
{
    leech3_record_mul_gen(r, 0x20000000 + mat24_perm_to_m24num(pi));
}

static inline 
void leech3_record_mul_perm_map(
   leech3_record_type *r,
   uint8_t *source,
   uint8_t *dest,
   int32_t length
)
{
    uint8_t pi[32];
    if (mat24_perm_from_map(source, dest, length, pi) > 0) {
        leech3_record_mul_perm(r, pi);
    } else {
        leech3_record_error(r, 2);
    }
}

static inline 
void leech3_record_mul_perm_tetrad(
   leech3_record_type *r,
   uint32_t tet
)
{
    uint8_t tet_bits[32];
    static uint8_t STD_TET[4] = {0, 1, 2, 3};
    if (mat24_vect_to_bit_list(tet, tet_bits) == 4) {
        leech3_record_mul_perm_map(r, tet_bits, STD_TET, 4);
    } else {
        leech3_record_error(r, 3);
   }    
}

static inline 
void leech3_record_mul_neg_y(
   leech3_record_type *r,
   uint32_t v
)
{
    uint32_t gc = mat24_vect_to_gcode(v);
    if ((gc >> 12) == 0) leech3_record_mul_gen(r, 0x40000000 + gc);
    else leech3_record_error(r, 4);
}

static inline 
void leech3_record_mul_xi_exp(
   leech3_record_type *r,
   uint32_t e
)
{
    leech3_record_mul_gen(r, 0x60000000 + (e & 3));
}

/// @endcond

/*******************************************************************
*** Reduce an element of the Leech lattice mod 3
*******************************************************************/

/// @cond DO_NOT_DOCUMENT

static inline 
void reduce_tetrad_leech_mod3(leech3_record_type *r)
{
    /* Reduce weight of a vector in the Leech lattice mod 3

    Let ``r`` be an object of class ``Leech3VectorRecord``
    encoding a vector ``a`` in the Leech lattice mod 3. Let ``t``
    be  a tetrad given as a bit vector. The weight of  ``a`` is
    be the number of nonzero bits in ``a``.

    The function tries to reduce the weight of ``a`` by modifying
    object ``r`` as follows. It first applies a permmutation in the
    Mathieu group :math:`M_{24}` that  maps ``t`` to the standard
    tetrad (0,1,2,3). Then it applies a power :math:`\xi^e, e = \pm1`
    of the generator :math:`\xi`  of :math:`\mbox{Co}_1`.
    
    For each tetrad ``t'`` of the standard sextet the function
    computes a score for exponenets :math:`e = \pm 1`  as follows:

    The score for :math:`e = 1` is +1 if ``t'`` has weight 4 and
    an odd number of entries -1. The score for :math:`e = -1` is +1
    if ``t'`` has weight 4 and an even number of entries -1.
    The score for any :math:`e` is -1 if if ``t'`` has weight 1.
    In all other cases the score is 0.

    The function succeeds with exponent :math:`e` if the sum of the
    scores of all tetrads is strictly positive for that exponent.
    Otherwise it fails and raises an exception.

    We remark that in case of success the weight of (the support of)
    ``a`` is reduced by a multiple of 3.
    */
    uint32_t supp, neg, n_plus, n_minus, n_bad, i, e, n;
    supp = leech3_record_support(r);
    neg = leech3_record_neg(r);
    #define SCORE  0x2000000100010110ULL   
    n_plus = n_minus = n_bad = 0;
    for (i = 0; i < 24; i += 4) {
        uint32_t tet = (supp >> i) & 15, score_tet, neg1, wn;
        score_tet = (uint32_t)(((uint64_t)SCORE >> (4 * tet)) & 15);
        if (score_tet == 2) {
            neg1 = (neg >> i) & tet;
            wn = (0x6996 >> neg1) & 1;
            n_plus += wn;
            n_minus += 1 - wn;
        } else {
            n_bad += score_tet;
        }
    }
    if (n_plus >= n_minus) {
        e = 1; n = n_plus;
    } else {
        e = 2; n = n_minus;
    }
    if (n <= n_bad) leech3_record_error(r, 10); 
    leech3_record_mul_xi_exp(r, e);
}



/// @endcond

/*******************************************************************
*** Special reduction for an umbral undecad
*******************************************************************/




/// @cond DO_NOT_DOCUMENT


static inline
uint32_t neg_dodecad(uint32_t v, uint32_t syn, uint32_t neg)
{
    /* Adjust signs of a weight-11 vector in Leech lattice mod 3

    Let ``v`` be the support of a vector ``w`` in the Leech lattice
    mod 3, i.e. the bit vector containing the  nonzero entries 
    of ``w``. Here ``v``must be a umbral undecad, and the (disjoint)
    union of ``v`` and the singleton ``syn`` must be a umbral 
    dodecad. Let ``neg`` be the bit vector containing the bits
    where ``w`` has an entry -1.
    
    We may change the signs of a vector in ``w`` by flipping the
    signs of all entries corresponding to the bits of a Golay code
    word. The function returns a suitable Golay code wort ``gc`` (as
    a bit vector) such that flipping the signs in ``w`` corresponding
    to the bits in ``gc`` makes all entries of ``w`` nonegative. 
    */  
    uint32_t neg1 = mat24_cocode_as_subdodecad(
        mat24_vect_to_cocode(neg = neg &= v),
        mat24_vect_to_gcode(0xffffff & ~(v | syn)),
        mat24_lsbit24(syn)
    );
    return neg | neg1;
}

    
static inline
void reduce_umbral_undecad(leech3_record_type *r)
{
    uint32_t v, neg, syn, y, n_swapped, gc_opp, i;
    v = leech3_record_support(r);
    neg = leech3_record_neg(r);
    syn = mat24_syndrome(v, 0); 
    y = neg_dodecad(v, syn, neg);
    n_swapped = 0;
    gc_opp = 0xffffff ^ v ^ syn;
    for (i = 4; i < 24; i += 4) {
        uint32_t t = v & (15 << i), duad;
        if (t && n_swapped < 3) {
            duad = syn ^ (t & (0 - t));
            y ^= cohexad(gc_opp, duad, 0) ^ duad;
            n_swapped += 1;
        }
    }
    leech3_record_mul_neg_y(r, y); 
    leech3_record_mul_xi_exp(r, 1);
}



/// @endcond


/*******************************************************************
*** The final permutation
*******************************************************************/

/// @cond DO_NOT_DOCUMENT



static inline
void reduce_signs(leech3_record_type *r)
{
    uint32_t v, neg, sign_vector = 0, i;
    v = leech3_record_support(r);
    neg = leech3_record_neg(r);
    if (v == 0x111111UL) {
        for (i = 0; i < 24; i += 4) {
            if (neg & (1 << i)) sign_vector ^= 0xeeeeeeUL ^ (15UL << i);
        }
    } else {
        for (i = 1; i < 9; ++i) {
            if ((neg >> i) & 1) sign_vector ^= TABLE_SIGN_OCTADS[i];
        }
        if ((neg ^ sign_vector) & 1 && (v & 8) == 0) {
            sign_vector ^= TABLE_SIGN_OCTADS[0];
        }
    }
    leech3_record_mul_neg_y(r, sign_vector);
}


static inline
void reduce_final_perm(leech3_record_type *r)
{
    uint32_t v, neg, w_v, syn, w_sub, w_core, w_add, neg1;
    int32_t res;
    uint8_t v_bits[64], pi[32];
    v = leech3_record_support(r);
    neg = leech3_record_neg(r);
    w_v = mat24_bw24(v);
    if (w_v == 0) return;
    if (w_v <= 6) {
        mat24_vect_to_bit_list(v, v_bits);
        leech3_record_mul_perm_map(r, v_bits, TABLE_POSITIONS[w_v], w_v);
        reduce_signs(r);
        return;
    }
    syn = mat24_syndrome(v, 0); 
    w_sub =  mat24_vect_to_bit_list(syn & ~v, v_bits);
    w_core =  mat24_vect_to_bit_list(v & ~syn, v_bits + w_sub);
    if (w_v == 9 && w_core == 9) {
        // Then v is a (signed) umbral nonad
        res = mat24_perm_from_dodecads(v_bits, TABLE_UMBRAL9, pi);
        if (res) leech3_record_error(r, 0x30);
        leech3_record_mul_perm(r, pi);
        v = leech3_record_support(r);
        neg = leech3_record_neg(r);
        if (v != 0xEEE000UL) leech3_record_error(r, 0x31);
        neg1 = neg_dodecad(0xEEE111UL, 1, neg);
        leech3_record_mul_neg_y(r, neg | neg1);
        return;
    }  
    w_add = mat24_vect_to_bit_list(syn & v, v_bits + 6);
    if (w_add == 1 &&  w_v + w_sub == 9) {
        leech3_record_mul_perm_map(r, v_bits, TABLE_POSITIONS[w_v], 7);
        reduce_signs(r);
    }
}

/// @endcond

/*******************************************************************
*** The final reduction functionThe final permutation
*******************************************************************/


/// @cond DO_NOT_DOCUMENT

uint32_t GOOD_RESULTS[10] = { 
   0x000000UL, 0x000001UL, 0x00000cUL, 0x00000eUL,  0x0000f1UL,
   0x0001f3UL, 0x0001feUL, 0x111111UL, 0xeee000UL, 0x10001feUL
};

static inline
void check_result(leech3_record_type *r)
{
    uint32_t i;
    for (i = 0; i < 10; ++i)
        if (r->a == (uint64_t)(GOOD_RESULTS[i])) return;
    leech3_record_error(r, r->a + (1ULL << 48));
}

/// @endcond



/**
   @brief Map a vector in \f$\Lambda / 3\Lambda\f$ to a representative of its orbit 

   This function is yet to be documented!!!

   Buffer ``g`` must have size at least 12.
*/
// %%EXPORT px
int64_t gen_leech3_reduce_leech_mod3(uint64_t v3, uint32_t *g)
{
    leech3_record_type r;
    uint32_t i = 6, tetrad;
    leech3_record_load(&r, v3);
    do {
        tetrad = gen_leech3_find_tetrad_leech_mod3(r.a);
        if (mat24_bw24(tetrad) != 4) {
            if (tetrad) leech3_record_error(&r, 0x21);
            if (!r.status) reduce_final_perm(&r);
            check_result(&r);
            goto done;
        }
        leech3_record_mul_perm_tetrad(&r, tetrad & 0xffffff);
        if (tetrad & 0x1000000) reduce_umbral_undecad(&r);
        else reduce_tetrad_leech_mod3(&r);
   } while (--i && !r.status);
   leech3_record_error(&r, 0x20);

done:
   if (r.status) return 0ULL - r.status;
   memcpy(g, r.g, r.len_g * sizeof(uint32_t));
   return short_3_reduce(r.a) + ((uint64_t)r.len_g << 48);
}


//  %%GEN h
/// @endcond 
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




