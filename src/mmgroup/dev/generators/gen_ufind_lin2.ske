/** @file gen_ufind_lin2.c
The functions in file ``gen_ufind_lin2.c`` deal with the operation of
a group \f$G\f$ as a permutation group on the vector
space \f$V = \mbox{GF}_2^n\f$ for \f$n \leq 24\f$. Such a group is
generated by a set  of  \f$n \times n\f$ bit matrices acting on \f$V\f$
by right multiplication. The functions in this module can compute
orbits on \f$V\f$ under the action of \f$G\f$, and representatives and
sizes of these orbits. They can also compute Schreier vectors for these
orbits, so that we can find an element of \f$G\f$ mapping a vector
in an orbit to any other vector in the same orbit.

Function ``gen_ufind_lin2_init`` creates an (opaque) array ``a``
that will be used for storing information about the action of a group
on a vector space  \f$V = \mbox{GF}_2^n\f$. Such an array will be
called an *orbit array*. If a function uses an orbit array, this will
always be the first parameter of the function; and that parameter
will have the name ``a``. The user may add generators of the
group \f$G\f$ to orbit array ``a`` by calling
function ``gen_ufind_lin2_add``.

Once all generators have been added, users may e.g. call
function ``gen_ufind_lin2_rep_v`` for finding the chosen
representative \f$w\f$ of the orbit of a vector \f$v \in V\f$. Then
they may then function  ``gen_ufind_lin2_map_v`` for finding
a \f$g \in G\f$ with \f$v g = w\f$.

The functions in this module may be used e.g. for computing the orbits
of the Leech lattice mod 2 under the action of (a subgroup of) the
Conway group \f$\mbox{Co}_1\f$.

The internal structure of the opaque array ``a`` is not described in
the public documentation. For details we refer to the explanations in
file ``gen_ufind_lin2_aux.h``.
*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT
#include <stdlib.h> 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#include "clifford12.h"
// The following file contains the stuctures for internal use by
// the functions in file(s) gen_ufind_lin2*.c  
#include "gen_ufind_lin2_aux.h"
/// @endcond 






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c





//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c

/************************************************************************
*************************************************************************
* Auxiliary functions
*************************************************************************
************************************************************************/



/** Transform a vector with an affine transformation

Let \f$V = GF_2^n\f$. We store an affine mapping \f$V \rightarrow V\f$
given by \f$v \mapsto v \cdot A + b, v, b \in V\f$, \f$A\f$
an \f$n \times n\f$ bit matrix, in an array ``m`` of \f$n + 1\f$
unsigned 32-bit integers as follows.
Row ``i``, ``0 <= i < n`` of matrix \f$A\f$ is stored in ``m[i]`` as
a bit vector; bit vector ``b`` is stored in  ``m[n]``.

The function returns the bit vector \f$v \cdot A + b\f$.
*/
// %%EXPORT px
uint32_t gen_ufind_lin2_mul_affine(uint32_t v, uint32_t *m, uint32_t n)
{
    return vmatmul_aff(v, m, n);
}



/************************************************************************
*************************************************************************
*** Creating an orbit array and obtaining information from it
*************************************************************************
************************************************************************/



/************************************************************************
* Initialization of an orbit array 
************************************************************************/



/**  Size of a structure for finding orbits in ``GF(2)^n``.

For details we refer to function ``gen_ufind_lin2_init``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_size(uint32_t n, uint32_t k)
{
    if (n == 0 || n > LIN2_MAX_N) return ERR_GEN_UFIND_LIN2_DIM;
    if(k > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    return LIN2_LEN_HEADER + (2UL << n) +
         lin2_generator_size(n, k) + 2;
}






/**  @brief Initialize orbit array for a group acting on ``GF(2)^n``

Let \f$G\f$ be a group acting on a vector
space \f$V = \mbox{GF}_2^n\f$. That group is generated by
generators \f$g_i, 0 \leq i < k\f$. We store the group (given by
its generators) in an opaque *orbit array* ``a``.
This module provides functions for computing orbits on \f$V\f$
under the action of the group \f$G\f$ from the information stored
in the orbit array ``a``. It also provides a function for finding an
element of \f$G\f$ that maps a vector in \f$V\f$ to a (chosen)
representative of its orbit.

You may use function ``gen_ufind_lin2_add`` to add
generators  ``g_i, 0 <= i < k`` to the arrray ``a``. These generators
are sored as ``n`` times ``n`` bit matrices acting on \f$V\f$ by right
multiplication. The maximum number of generators allowd is given by
parameter ``n_g``.

The required length of the orbit array ``a`` may be computed by calling
function ``gen_ufind_lin2_size(n, n_g)``. At present the length of
of ``a`` is approximately ``2 << n`` plus the space for storing
the generators of the group and their inverses. Limitations
are ``n <= 24`` and ``n_g <= 127``.

Note that \f$G\f$ acts on row vectors in \f$\mbox{GF}_2^n\f$. Such
a row vector is encoded in the same way as a row of a matrix ``g_i``.

The function returns 0 in case of success and a negative value
in case of error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_init(uint32_t *a, uint32_t l_a, uint32_t n, uint32_t n_g)
{
    int32_t l_a_expected, status;
    lin2_type s;

    status = l_a_expected = gen_ufind_lin2_size(n, n_g);
    if (status < 0) goto done;
    status = check_out_buf32(a, l_a, l_a_expected);
    if (status < 0)  goto done;
    s.status = 0;
    s.n = n;
    s.n_max_g = n_g;
    s.n_g = 0;
    s.n_orbits = 0;
    s.n_vectors = 1UL << n;

    if (status < 0) goto done;
    store_lin2_info(&s, a);
    status = load_lin2_info(a, &s);

done:
    return lin2_error(a, status);
}



/************************************************************************
* Obtaining information from an orbit array
************************************************************************/



/** @brief Given a group acting on ``GF(2)^n`` the function returns ``n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the dimension of the vector space.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_dim(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n;
}


/** @brief Return number of generators of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the number of generators of the group.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_gen(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n_g;
}


/** @brief Return max number of generators of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the maximum number of generators of the group that can be
stored in array ``a``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_max_gen(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n_max_g;
}


/** @brief Increase max number of generators of a group acting on ``GF(2)^n``

The function tries to pad an orbit array ``a``  as described in
function ``gen_ufind_lin2_init``. Here ``len_a`` is the allocated
laength of the orbit array ``a``, and ``n_max_g`` is the requested
number of generators group generators to be stored in ``a``.

The function returns the new maximum allowed number of generators of
the group. It returns a negative value in case of a error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_pad(uint32_t *a, uint32_t len_a, uint32_t n_max_g)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    if (status < 0) return status;
    if (status >= 2) return ERR_GEN_UFIND_STATE;
    if (n_max_g > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    n_max_g = n_max_g < s.n_max_g ? s.n_max_g : n_max_g;
    if ((status = gen_ufind_lin2_size(s.n, n_max_g)) < 0) return status;
    if (len_a < (uint32_t)(status)) return ERR_GEN_UFIND_OUT_SHORT;
    s.n_max_g = n_max_g;
    store_lin2_info(&s, a);
    return  n_max_g;
}


/** @brief Return a generator of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
reads a (possibly inverted) generator of the group from ``a``
and writes it into the array ``g`` of length ``l_g``. On
input ``i = 2 * k`` it stores generator ``k``; and on
input ``i = 2 * k + 1`` it stores the inverted generator ``k``.
Here ``0 <= k < gen_ufind_lin2_n_gen(a)`` must hold.

The generator is returned as an integer array of length ``n``,
with ``n = gen_ufind_lin2_dim(a)``, encoded as an ``n`` times ``n``
bit matrix as \f$A\f$ specified in function ``gen_ufind_lin2_init``.
That function also supports generators \f$v \mapsto v \cdot A + b\f$.
In case \f$b \neq 0\f$ we require ``l_g > n`` and store \f$b\f$
in ``g[n]``.

The function returns ``n`` in case of success and a negative value
in case of error; e.g. if the array ``g`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_gen(uint32_t *a, uint32_t i, uint32_t *g, uint32_t l_g)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t *p_gen, len_aff;
    if (status < 0) return status;
    if (i >= 2 * s.n_g) return ERR_GEN_UFIND_IN_LARGE;
    p_gen = lin2_generator(&s, i);
    len_aff = s.n + (p_gen[s.n] != 0);
    if (check_out_buf32(g, l_g, len_aff)) return ERR_GEN_UFIND_OUT_SHORT;
    memcpy(g, p_gen, len_aff * sizeof(uint32_t));
    return s.n;
}









/************************************************************************
* Add a generator to the group stored in the structure
************************************************************************/




/**  @brief Add a generator of a group to an orbit array

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``.
Function ``gen_ufind_lin2_add`` extends the group stored in the
orbit array by adding a generator \f$g\f$ to the group.

Let \f$G\f$ be the group acting on a vector
space \f$V = \mbox{GF}_2^n\f$ stored in the orbit array ``a``. The
group is generated by generators \f$g_i, 0 \leq i < k\f$. We store
these generators in the array ``a`` that must have been initialized
with function  ``gen_ufind_lin2_init``.
Function ``gen_ufind_lin2_add`` adds a generator \f$g\f$ to the array.
Generator \f$g\f$ must given as an ``n`` times ``n`` bit
matrix \f$A\f$ acting on \f$V\f$ by right multiplication. Here
``n`` is given by ``n = gen_ufind_lin2_dim()``. Row ``j``
(with 0 <= j < n) of bit matrix \f$A\f$ must be encoded as a bit
vector in the entry ``g[j]`` of the array referred by parmameter ``g``
in the usual way. The length ``l_g`` of the array referred by ``g``
must be at least ``n``.

Groups acting on \f$V\f$ by an affine transformation are supported.
In case ``l_g > n`` the generator \f$g\f$ acts as the
transformation \f$v \mapsto v \cdot A + b\f$, where \f$A\f$ is as
above, and \f$b\f$ is the bit vector stored in ``g[n]``.

Caution: The case \f$b \neq 0\f$ has not yet been tested.

All generators should be added to the orbit array ``a`` immediately
after initialization. Any function retrieving orbit information
from that array may trigger a lengthy calculation that makes adding
more generators impossible.

The function returns 0 in case of success, and a negative value in
case of error. An error occurs e.g. if the generator is not invertible.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_add(uint32_t *a, uint32_t *g, uint32_t l_g)
{
    lin2_type s;
    int32_t status;
    uint32_t j, *p_gout, *p_gout_inv, mask, affine;
    status = load_lin2_info(a, &s);
    if (status != 0) return status < 0 ? status : ERR_GEN_UFIND_STATE;
    mask =   (1UL << s.n) - 1;
    status = check_out_buf32(g, l_g, s.n);
    affine = l_g > s.n; 
    if  (status < 0) goto done;
    status = ERR_GEN_UFIND_LIN2_GEN;
    if (s.n_g >= s.n_max_g) goto done;
    p_gout = lin2_generator(&s, 2 * s.n_g);
    for (j = 0; j < s.n; ++j) p_gout[j] = g[j] & mask;
    p_gout[s.n] = affine ? (g[s.n] & mask) : 0;
    status = ERR_GEN_UFIND_INVERSE;
    p_gout_inv = lin2_generator(&s, 2 * s.n_g + 1);
    if (mat_inverse_aff(p_gout, s.n, p_gout_inv)) goto done;
    s.n_g += 1;
    store_lin2_info(&s, a);
    return 0;

done:
    if (status < 0) a[0] = (uint32_t)status;
    return status;

}





/************************************************************************
* Transform a vector by a group element
************************************************************************/



/** @brief Transform a vector by a group element

Here ``a`` refers to an orbit array ``a`` encoding a group \f$G\f$
(given by generators) acting on a space of bit vectors. A group
element \f$g\f$ is stored as a word of generators of \f$G\f$
of length ``l_b`` in the array referred by ``b``. An entry ``i``
in the array ``b`` corresponds to the generator given
by ``gen_ufind_lin2_gen(a, i, ...)``.

The function returns the bit vector ``v`` transformed by the group
element \f$g\f$.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_transform_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
{
    lin2_type s;
    uint32_t i;
    int32_t status = load_lin2_info(a, &s);
    if (status < 0) return status;
    v &= (1UL << s.n) - 1;
    for (i = 0; i < l_b; ++i) {
        if (b[i] >= 2 * s.n_g) {
            if (b[i] == 0xfe) continue;
            return ERR_GEN_UFIND_INT_LIN2 - 36;
        }
        v = vmatmul_aff(v, lin2_generator(&s, b[i]), s.n);
    }
    return v;
}




/************************************************************************
*************************************************************************
*** Finalize the initialization of an orbit array
*************************************************************************
************************************************************************/





/************************************************************************
* Compute  Schreier vector
************************************************************************/


/// @cond DO_NOT_DOCUMENT

/** @brief Compute a Schreier vector

Let parameter ``p_s`` refer to an orbit array as descrbed in
file ``gen_ufind2_lin2_aux.h``. We assume that the orbit array has
status 0.
The this function computes a Scheier vector from the group \f$G\f$
encoded in that orbit array. It stores the Schreier vevtor in
the array of size ``1 << p_s->n`` referred by ``p_s->p_t``. The
data stored in that array will be as described in the header of
file ``gen_ufind2_lin2_aux.h`` for status 2.

Internally, the function uses a bitmap, where all ``1 << p_s->n``
bits are initially set. For computing the Schreier vector, it takes
a bit vector with its corresponding bit in the bit map still set,
and clears that bit. Let  \f$g\f$ be the set of the generators
of \f$G\f$ and their inverses. The function recursively computes
the tree of images of that vector under all elements of \f$g\f$ with
breadth first search. It clears the bits for these images in the
bitmap, and stores that tree in a queue. After computing the first
tree, we look for a new root element in the bit map; and we compute
the next tree from that root. So, eventually we will obtain the
set of all orbits as forest. From such a forest we can easily
compute a Schreier vector, encoded as in the description of
array ``p_s->p_t`` in file ``gen_ufind2_lin2_aux.h``.

The function returns the number of orbits found in case of success,
and a neagtive value in case of failure.
*/
static inline int32_t
compute_schreier_vector(lin2_type *p_s)
{
    uint_fast32_t n_size = 1UL << p_s->n;
    uint_fast32_t n_g = p_s->n_g;
    uint_fast32_t n_orbits = 0;
    uint_fast32_t current = 0;
    uint_fast32_t rep = 0;
    uint_fast32_t i;
    uint32_t *p_t = p_s->p_t;
    uint32_t *p_start = p_s->p_o;
    uint32_t *p_end = p_start;
    uint32_t *p_overflow = p_start + n_size;
    uint64_t *bitmap = (uint64_t*)(p_s->p_t);
    uint64_t *g = NULL;

    if (p_s->status != 0) return ERR_GEN_UFIND_STATE;
    memset(bitmap, 0xff, ((n_size >> 6) + 1)  * sizeof(uint64_t));
    g = malloc(n_g * 0x300 * sizeof(uint64_t));
    if (g == NULL) return ERR_GEN_UFIND_MEM;
    for (i = 0; i < n_g; ++i) {
        store64_gen(g + 0x300 * i, p_s->n, lin2_generator(p_s, 2 * i),
            lin2_generator(p_s, 2 * i + 1));
    }

    while ((current = find_next_bit_set(bitmap, current)) < n_size) {
        n_orbits += 1;
        if (p_start >= p_overflow) goto error_overflow;
        *p_start = current | 0xfe000000UL;
        p_end = p_start + 1;
        bitmap[current >> 6] ^= (uint64_t)1ULL << (current & 0x3f);
        current += 1;

        while (p_start < p_end) {
            uint_fast32_t data = *p_start++, d0, d1, d2;
            uint64_t *p_g = g, v64, mask0, mask1, img0, img1;
            d0 = data & 0xff;
            d1 = ((data >> 8) & 0xff) + 0x100;
            d2 = ((data >> 16) & 0xff) + 0x200;
            for (i = 0; i < n_g; ++i) {
                v64 = p_g[d0] ^ p_g[d1] ^ p_g[d2];
                img0 =  v64 & 0xffffffffUL;
                img1 =  v64 >> 32;
                mask0 = (uint64_t)1ULL << (img0 & 0x3f);
                mask1 = (uint64_t)1ULL << (img1 & 0x3f);
                p_g += 0x300;
                if (bitmap[img0 >> 6] & mask0) {
                    bitmap[img0 >> 6] ^= mask0;
                    if (p_end >= p_overflow) goto error_overflow;
                    *p_end++ = (uint32_t)img0 | (i << 25) | 0x01000000UL;
                }
                if (bitmap[img1 >> 6] & mask1) {
                    bitmap[img1 >> 6] ^= mask1;
                    if (p_end >= p_overflow) goto error_overflow;
                    *p_end++ = (uint32_t)img1 | (i << 25);
                }
            }
        }
    }

    if (g != NULL) free(g);
    p_start = p_s->p_o;
    for (i = 0; i < n_size; ++i) {
        uint_fast32_t v = p_start[i];
        uint_fast32_t rg = v & 0xff000000UL;
        uint_fast32_t ind = v & 0xffffffUL;
        if (rg == 0xfe000000UL) rep = ind;
        p_t[ind] = rg | rep;
    }    
    return n_orbits;

error_overflow:
    if (g != NULL) free(g);
    return ERR_GEN_UFIND_INT_LIN2 - 25;
}


/// @endcond




/************************************************************************
* Finalize the initalization of an orbit array
************************************************************************/


/// @cond DO_NOT_DOCUMENT


#define LIN2_MAGIC 0x1fecd173UL

#define LIN2_AMUL 0x5ac83257UL

static inline uint32_t magic_content(uint32_t *a)
// Return hash value over the header of the orbit array ``a``
{
    uint32_t s = LIN2_MAGIC, i;
    for (i = 0; i < LIN2_LEN_HEADER; ++i) s = s * LIN2_AMUL + a[i];
    return s;
}




static inline int32_t finalize_initalization(uint32_t *a, lin2_type *p_s)
// Upgrade the status of the orbit array ``a`` to 2; and
// store header information and pointers in structure ``p_s``.
// The function return the length of the updated array ``a``
{

    int32_t status;
    uint32_t a_length, a_sum = 0, i;
    status = load_lin2_info(a, p_s);
    if (status == 2 || status == LIN2_COMPRESSED || status < 0) 
         return status;
    if (status != 0) return ERR_GEN_UFIND_STATE;
    // Compute Scheier vector in p_s->p_t
    status = compute_schreier_vector(p_s);
    if (status < 0) return lin2_error(a, status);
    p_s->n_orbits = status;
    // Compute orbit partition  in p_s->p_o
    status = compute_partition(p_s->p_t, p_s->n, p_s->p_o, p_s->n_orbits);
    if (status < 0) return lin2_error(a, status);
    // Set status of orbit array
    p_s->status = 2;
    p_s->n_max_g = p_s->n_g;
    status = store_lin2_info(p_s, a);
    if (status < 0) lin2_error(a, status);
    // Compute checkum in orbit array
    a_length =  gen_ufind_lin2_size(p_s->n, p_s->n_g);
    a[a_length - 2] = magic_content(a);
    for (i = 0; i < a_length - 1; ++i) a_sum += a[i];
    a[a_length - 1] = 0 - a_sum;
    return status;
}





/// @endcond



/************************************************************************
*************************************************************************
*** Compress an orbit array
*************************************************************************
************************************************************************/


/** @brief Compute size of buffer for compressing an orbit array

We may compress an orbit array ``a`` to an orbit array ``c``
containing not all orbits of array ``a``, by calling
function ``gen_ufind_lin2_compress(a, o, l_o, c, l_c)``.
Hier ``o`` is a list of ``l_o`` bit vectors, such that the
orbits of these vectors will be added to the orbit
array ``c``.
Function ``gen_ufind_lin2_compress_size(a, o, l_o)``
returns the number ``l_c`` of entries required for the
array ``c``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_compressed_size(uint32_t *a, uint32_t *o, uint32_t l_o)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    uint64_t *bitmap = NULL;
    uint32_t bitmap_size;
    uint32_t n_entries = 0;
    uint32_t n_orbits = 0;
    uint32_t mask; 
    uint32_t i;

    if (status != 2) return status < 0 ? status : ERR_GEN_UFIND_STATE;
    bitmap_size = ((1UL << s.n) >> 6) + 1;
    bitmap = malloc(bitmap_size << 3);
    if (bitmap == NULL) return ERR_GEN_UFIND_MEM;
    memset(bitmap, 0, bitmap_size << 3);
    set_bitmap(1UL << s.n);
    mask = (1UL << s.n) - 1;

    for (i = 0; i < l_o; ++i) {
         uint32_t v = o[i] & mask, w, l_orbit;
         w = s.p_t[v];
         if ((w >> 24) != 0xfe) {
             v = s.p_t[v] & mask; w = s.p_t[v];
         }
         // v is represetative of the orbit of o[i]
         if (get_bitmap(v)) continue;
         set_bitmap(v); 
         w &= mask;  
         // w is index of v into table s.p_o
         l_orbit = status = read_length_info(s.p_o + w);
         if (status < 0) goto done;
         n_orbits += 1;
         n_entries += l_orbit;
    }

done:
    if (bitmap) free(bitmap);
    if (status < 0) return status;
    return  LIN2_LEN_HEADER + n_entries + 2 * n_orbits +
        lin2_generator_size(s.n, s.n_g) + 2;
}
     




/// @cond DO_NOT_DOCUMENT


static inline int32_t make_compressed(
uint32_t *a, uint64_t *bitmap, uint32_t n_entries, uint32_t n_orbits, uint32_t *c, uint32_t l_c)
// Auxiliary function for function ``gen_ufind_lin2_compress``
//
// As in that function, parameter ``a`` refers to an orbit array,
// and array ``c`` of length ``l_c```is a compressed orbit array
// to be computed. Before calling this function, the
// function  ``gen_ufind_lin2_compress`` computes a bitmap marking
// all bit vector to be stored in array ``c``. Parameter ``bitmap``
// must point to this bitmap. Paraeters ``n_entries`` and ``n_orbits``
// must be the numbers of bit vectors and orbits to be stored  in
// the orbit array ``c``.
//
// Return value is as in function ``gen_ufind_lin2_compress``
{
    lin2_type s, sc;
    int32_t status = load_lin2_info(a, &s);
    uint32_t v = 0, vmax = 1UL << s.n, c_size;
    uint32_t entries_found = 0, orbits_found = 0, i, c_sum = 0;
    uint32_t mask = vmax - 1;

    if (status != 2) return status < 0 ? status : ERR_GEN_UFIND_STATE;
    memcpy(&sc, &s, LIN2_LEN_HEADER * sizeof(uint32_t));
    sc.status = LIN2_COMPRESSED;
    sc.n_vectors = n_entries;
    sc.n_orbits = n_orbits;
    c_size = LIN2_LEN_HEADER + sc.n_vectors + 2 * sc.n_orbits +
        lin2_generator_size(sc.n, sc.n_g) + 2;
    if (l_c < c_size) return ERR_GEN_UFIND_OUT_SHORT;
    sc.p_t = c + LIN2_LEN_HEADER; 
    sc.p_o = sc.p_t + (size_t)sc.n_vectors;
    sc.p_g = sc.p_o + (size_t)(2 * sc.n_orbits);
    memcpy(sc.p_g, s.p_g, lin2_generator_size(s.n, s.n_g) * sizeof(uint32_t));

    while ((v = find_next_bit_set(bitmap, v)) < vmax) {
        uint32_t w = s.p_t[v];
        uint32_t g = w >> 24;  // Schreier vector entry for v
        if (g == 0xfe) {
            uint32_t len_o = read_length_info(s.p_o + (w & mask));
            sc.p_o[orbits_found] = v;
            sc.p_o[orbits_found + n_orbits] = len_o;
            ++orbits_found;
        }
        sc.p_t[entries_found++] = (v << 8) + g;
        ++v;
    }
    if (orbits_found != n_orbits) 
        return (int32_t)ERR_GEN_UFIND_INT_LIN2 - 64;
    if (entries_found != n_entries) 
        return (int32_t)ERR_GEN_UFIND_INT_LIN2 - 65;

    c[0] = 0;
    store_lin2_info(&sc, c);
    c[c_size - 2] = magic_content(c);
    for (i = 0; i < c_size - 1; ++i) c_sum += c[i];
    c[c_size - 1] = 0 - c_sum;
    return c_size;
}

/// @endcond


/** @brief Compress an orbit array.

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Here orbit
array ``a`` encodes a group \f$G\f$ acting on a space \f$V\f$ of
bit vectors. This function extracts a set of orbits of \f$G\f$
on \f$V\f$ and stores the orbit array containing these orbits in
the buffer ``c`` of length ``l_c``. Most of the functions in
this module can be applied to the orbit array ``c`` in the same
way as to orbit array ``a``. An error occurs if the buffer
is too short. The required buffer length can be computed with
function ``gen_ufind_lin2_compressed_size``. Array ``o`` of
length ``l_o`` is a list of vectors in \f$V\f$. The orbits
of the vectors in that list will be stored in the buffer ``c``.

A typical use case is the action of a group on the Leech lattice
mod 2. The functions in this module may compute orbits and
Schreier vectors for that group. If we are only interested in
the action of the group on short vectors only, then we might
restrict the orbit array of orbits  short vectors. This will
save space.

The function returns the actual length of the computed array ``c``
in case of success, and a negative value in case of an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_compress(uint32_t *a, uint32_t *o, uint32_t l_o, uint32_t *c, uint32_t l_c)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    uint64_t *bitmap = NULL;
    uint32_t bitmap_size;
    uint32_t n_entries = 0;
    uint32_t n_orbits = 0;
    uint32_t mask; 
    uint32_t i;
    if (status != 2) return status < 0 ? status : ERR_GEN_UFIND_STATE;
    if (c == NULL) return ERR_GEN_UFIND_OUT_SHORT;
    else *c = (uint32_t)(ERR_GEN_UFIND_INT_LIN2 - 61);
    bitmap_size = ((1UL << s.n) >> 6) + 1;
    bitmap = malloc(bitmap_size << 3);
    if (bitmap == NULL) return ERR_GEN_UFIND_MEM;
    memset(bitmap, 0, bitmap_size << 3);
    set_bitmap(1UL << s.n);
    mask = (1UL << s.n) - 1;

    // Next set all bits in the bitmap corresponding bit vectors in
    // the orbit array ``a`` that will be copied to orbit array ``c``.
    // Compute the number of orbits to be stored in ``c`` in
    // variable ``n_orbits``, and the number of bit vectors to be
    // stored in ``c`` in variable ``n_entries``.
    for (i = 0; i < l_o; ++i) {
         uint32_t v = o[i] & mask, w, l_orbit, j;
         w = s.p_t[v];
         if ((w >> 24) != 0xfe) {
             v = s.p_t[v] & mask; w = s.p_t[v];
             if ((w >> 24) != 0xfe) {
                 status = ERR_GEN_UFIND_INT_LIN2 - 62;
                 goto done;
             }
         }
         // v is represetative of the orbit of o[i]
         if (get_bitmap(v)) continue; 
         w &= mask;  
         // w is index of v into table s.p_o
         l_orbit = status = read_length_info(s.p_o + w);
         if (status < 0) goto done;
         n_orbits += 1;
         n_entries += l_orbit;
         if ((s.p_o[w] & mask) != v) {
             status = ERR_GEN_UFIND_INT_LIN2 - 63;
             goto done;
         }           
         for (j = w; j < w + l_orbit; ++j) {
             set_bitmap(s.p_o[j] & mask); 
         }
    }
    status = make_compressed(a, bitmap, n_entries, n_orbits, c, l_c);

done:
    if (bitmap) free(bitmap);
    if (c != NULL && status < 0)  *c = (uint32_t)status;
    return status;
}





/************************************************************************
*************************************************************************
***  Compute representatives of an orbit in a compressed orbit array
*************************************************************************
************************************************************************/


/// @cond DO_NOT_DOCUMENT



static inline int32_t
compute_group_orbit_new(lin2_type *p_s, uint32_t *a, uint32_t len_a)
// Compute the orbit of a[0] and store it in array a of length len_a
// This is a simplified version of function ``compute_schreier_vector``.
{
    uint_fast32_t n_size = 1UL << p_s->n;
    uint_fast32_t n_g = p_s->n_g;
    uint_fast32_t i;
    uint32_t bitmap_size = (n_size >> 6) + 1;
    uint32_t *p_start = a;
    uint32_t *p_end = a + 1;
    uint32_t *p_overflow = a + len_a;
    uint64_t *bitmap = NULL;
    uint64_t *g = NULL;

    if (p_s->status < 0) return ERR_GEN_UFIND_STATE;
    if (len_a == 0) return ERR_GEN_UFIND_INT_LIN2 - 25;
    bitmap = malloc((bitmap_size + n_g * 0x300) * sizeof(uint64_t));
    if (bitmap == NULL) return ERR_GEN_UFIND_MEM;
    memset(bitmap, 0xff, bitmap_size * sizeof(uint64_t));
    g = bitmap + bitmap_size;
    for (i = 0; i < n_g; ++i) {
        store64_gen(g + 0x300 * i, p_s->n, lin2_generator(p_s, 2 * i),
            lin2_generator(p_s, 2 * i + 1));
    }
    bitmap[a[0] >> 6] ^= (uint64_t)1ULL << (a[0] & 0x3f);

    while (p_start < p_end) {
        uint_fast32_t data = *p_start++, d0, d1, d2;
        uint64_t *p_g = g, v64, mask0, img0;
        d0 = data & 0xff;
        d1 = ((data >> 8) & 0xff) + 0x100;
        d2 = ((data >> 16) & 0xff) + 0x200;
        for (i = 0; i < n_g; ++i) {
            v64 = p_g[d0] ^ p_g[d1] ^ p_g[d2];
            img0 =  v64 & 0xffffffffUL;
            mask0 = (uint64_t)1ULL << (img0 & 0x3f);
            p_g += 0x300;
            if (bitmap[img0 >> 6] & mask0) {
                bitmap[img0 >> 6] ^= mask0;
                if (p_end >= p_overflow) goto error_overflow;
                *p_end++ = (uint32_t)img0 | (i << 25) | 0x01000000UL;
            }
        }
    }
    return (uint32_t)(p_end - p_start);

error_overflow:
    if (bitmap != NULL) free(bitmap);
    return ERR_GEN_UFIND_INT_LIN2 - 25;
}



/// @endcond






/************************************************************************
* Finding orbits of representatives via a Schreier vector
************************************************************************/

/// @cond DO_NOT_DOCUMENT





static int32_t
compressed_lin2_map_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
// This is equivalent to function ``gen_ufind_lin2_map_v``
// if ``a.status == LIN2_COMPRESSED``.
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t mask, x, g, l_b_start;

    if (status < 0) return status;
    if (status != LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    mask = (1UL << s.n) - 1;
    l_b_start = l_b;

    while (1) {
        v &= mask;
        x = s.p_t[bitvector32_bsearch(s.p_t, s.n_vectors, v << 8)];
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return ERR_GEN_UFIND_ENTRY_UF;
        if (g == 0xfe)  return l_b_start - l_b;
        if (l_b-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *b++ = (uint8_t)(g);
        v = vmatmul_aff(v, lin2_generator(&s, g), s.n);
    }
}

static int32_t
compressed_lin2_rep_v(uint32_t *a, uint32_t v)
// This is equivalent to function ``gen_ufind_lin2_rep_v``
// if ``a.status == LIN2_COMPRESSED``.
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t mask, x, g, l_b;

    if (status < 0) return status;
    if (status != LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    mask = (1UL << s.n) - 1;
    l_b = s.n_vectors;  // We don't want an infinite loop

    while (--l_b) {
        v &= mask;
        x = s.p_t[bitvector32_bsearch(s.p_t, s.n_vectors, v << 8)];
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return ERR_GEN_UFIND_ENTRY_UF;
        if (g == 0xfe)  return v;
        v = vmatmul_aff(v, lin2_generator(&s, g), s.n);
    }
    return ERR_GEN_UFIND_OUT_SHORT;
}





/// @endcond



/************************************************************************
*************************************************************************
*** Finding representatives of and sizes of an orbit
*************************************************************************
************************************************************************/



/************************************************************************
* Finding orbits and their representatives;
************************************************************************/



/** @brief Return number of orbits a group acting on ``GF(2)^n``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. The function returns the number
of orbits (on the vector space under the action of the group)
stored in that array.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_orbits(uint32_t *a)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    return status < 0 ? status : s.n_orbits;
}




/** @brief Return representative of orbit of bit vector ``v``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns a representative
of the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_rep_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, entry;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
         return compressed_lin2_rep_v(a, v);
    }
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    return (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
}


/** @brief Return length of orbit of bit vector ``v``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns the length of
the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_len_orbit_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, rep, index_o;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    mask = (1UL << s.n) - 1;
    v &= mask;    
    if (status == LIN2_COMPRESSED) {
        status = v = compressed_lin2_rep_v(a, v);
        if (status < 0) return status;
        index_o = bitvector32_bsearch(s.p_o, s.n_orbits, v);
        if (v != s.p_o[index_o]) return ERR_GEN_UFIND_INT_LIN2 - 35;
        return s.p_o[s.n_orbits + index_o];
    }
    rep = gen_ufind_lin2_rep_v(a, v);
    index_o = s.p_t[rep] & mask;
    return read_length_info(s.p_o + index_o);
}



/** @brief Return orbit of bit vector ``v`` as an array

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v`` be
a vector in that space. The function writes the orbit of ``v`` under
the action of the group into the array ``r`` of length ``l_r``.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

The function returns the length of the orbit in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_len_orbit_v``
for determining the length of the orbit in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbit_v(uint32_t *a, uint32_t v, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, rep, index_o, *p_o, i;
    int32_t length;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    mask = (1UL << s.n) - 1;
    if (status == LIN2_COMPRESSED) {
        if (l_r == 0) return  ERR_GEN_UFIND_OUT_SHORT;
        r[0] = v & mask;
        return compute_group_orbit_new(&s, r, l_r);
    }
    rep = status = gen_ufind_lin2_rep_v(a, v);
    if (status < 0) return status;
    index_o = s.p_t[rep] & mask;
    p_o = s.p_o + index_o;
    length = read_length_info(s.p_o + index_o);
    if (check_out_buf32(r, l_r, length)) return ERR_GEN_UFIND_OUT_SHORT;
    for (i = 0; i < (uint32_t)length; ++i) {
        r[i] = p_o[i] & mask;
    }
    return length;
}



/** @brief Return representatives of orbits under the action of a group

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. The function writes a list of
representatives of all orbits stored in ``a`` into the array ``r``
of length ``l_r``. Here vectors are encoded as integers as described
in function ``gen_ufind_lin2_init``.

The function returns the number of these orbits in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_n_orbits`` for
determining the number of orbits in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_representatives(uint32_t *a, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, index_o = 0, l_r1 = l_r, d;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        if (s.n_orbits >  l_r) return ERR_GEN_UFIND_OUT_SHORT;
        memcpy(r, s.p_o, s.n_orbits * sizeof(uint32_t));
        return s.n_orbits;
    }
    mask = (1UL << s.n) - 1;

    while (index_o < (1UL << s.n)) {
        d = status = read_length_info(s.p_o + index_o);
        if (status < 0) return -status;
        if (l_r1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *r++ = s.p_o[index_o] & mask;
        index_o += d;
    }
    return l_r - l_r1;
}




/** @brief Return lengths of orbits under the action of a group

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. Then
function ``gen_ufind_lin2_representatives`` computes a list of
representatives of all orbits under the action of the group. This
function computes the list of the lengths of all these orbits (in the
same order as in function ``gen_ufind_lin2_representatives``) and
writes that list into array ``r`` of length ``l_r``. Parameters and
return value are as in function ``gen_ufind_lin2_representatives``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbit_lengths(uint32_t *a, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t index_o = 0, l_r1 = l_r, d;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
         if (s.n_orbits >  l_r) return ERR_GEN_UFIND_OUT_SHORT;
         memcpy(r, s.p_o + s.n_orbits, s.n_orbits * sizeof(uint32_t));
         return s.n_orbits;
    }
    while (index_o < (1UL << s.n)) {
        d = status = read_length_info(s.p_o + index_o);
        if (status < 0) return -status;
        if (l_r1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *r++ = d;
        index_o += d;
    }
    return l_r - l_r1;
}





/************************************************************************
*************************************************************************
***  Use Schreier vectors to compute mappings between orbits
*************************************************************************
************************************************************************/



/** @brief Return entry of Schreier vector for bit vector ``v``

A Schreier vector is a (partial) mapping from a space \f$V\f$
of bit vectors associated with an orbit array ``a`` to the
set of generators stored in that array. The image of a bit
vector may also be ``NUL``, indicating that the bit vector is
the representative of its orbit. For background we refer to
[HEOBrien05], Section 4.1.1.

A return value ``i < 0xfe`` refers to the generator given by
``gen_ufind_lin2_gen(a, i, ...)``.

Return value ``0xfe`` means that ``NUL``, i.e. input ``v`` is
the representative of its orbit.

Return value ``0xff`` means that the Schreier vector for ``v``
has not been computed.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v_gen(uint32_t *a, uint32_t v)
{
    uint32_t mask, x, g;
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        x = bitvector32_bsearch(s.p_o, s.n_vectors, v << 8);
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return 0xff;
        return g;
    }
    mask = (1UL << s.n) - 1;
    return (s.p_t[v & mask] >> 24) & 0xff;
}




/** @brief Return group element mapping ``v`` to orbit representative

Here ``a`` refers to an orbit array ``a`` encoding a group \f$G\f$
(given by generators) acting on a space \f$V\f$ of bit vectors.
The function computes an element \f$g\f$ of \f$G\f$ that maps
the bit vector ``v`` to the representative of its orbit.

Element \f$g\f$ is computed as a word of generators of \f$G\f$
of length ``l_b`` and stored in the array referred by ``b``.
An entry ``i`` in the array ``b`` to the generator given by
``gen_ufind_lin2_gen(a, i, ...)``.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
{
    uint32_t mask, w, l_b1, entry;
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        return compressed_lin2_map_v(a, v, b, l_b);
    }
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    w = (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
    l_b1 = l_b;
    while (1) {
        uint32_t gen = (entry >> 24) & 0xff;
        if (gen == 0xfe) {
            return l_b - l_b1;
        }
        if ((entry & mask) != w) return ERR_GEN_UFIND_INT_LIN2 - 31;
        if (l_b1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *b++ = (uint8_t)gen;
        if (gen >= 2 * s.n_g) return ERR_GEN_UFIND_INT_LIN2 - 32;
        v = vmatmul_aff(v, lin2_generator(&s, gen), s.n);
        entry = s.p_t[v];
    }
    return ERR_GEN_UFIND_INT_LIN2 - 33;
}



/************************************************************************
*************************************************************************
***  Finalize the computation of all data in an array of orbits
*************************************************************************
************************************************************************/




/** @brief Compute all possible information about orbits

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Some information
to be stored in ``a`` is computed on demand only. Before writing the
array ``a`` to a file, it may be useful to store the maximum possible
amount of infomation in ``a``. This function performs that task.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_finalize(uint32_t *a)
{
    lin2_type s;
    return finalize_initalization(a, &s);

}





/************************************************************************
*************************************************************************
***  Check if an orbit array has been finalized
*************************************************************************
************************************************************************/


/// @cond DO_NOT_DOCUMENT

static int32_t lin2_check(uint32_t *a, uint32_t len_a, uint32_t chksum)
{
    lin2_type s;
    int32_t status;
    uint32_t a_sum = 0, gen_size;
    uint64_t i, a_size;
    if (len_a <= LIN2_LEN_HEADER) {
        return lin2_error(a, ERR_GEN_UFIND_INT_LIN2 - 13);
    }
    status = load_lin2_info(a, &s);
    if (status < 0) return status;
    if (s.n == 0 || s.n > LIN2_MAX_N) return ERR_GEN_UFIND_LIN2_DIM;
    if (s.n_g > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    gen_size = lin2_generator_size(s.n, s.n_g);
    if (status == LIN2_COMPRESSED) {
        a_size = LIN2_LEN_HEADER + 2 * s.n_orbits + s.n_vectors 
                   + gen_size + 2;
    } else {
        a_size = LIN2_LEN_HEADER + (2UL << s.n)  + gen_size + 2;
    }
    if (a_size > (uint64_t)len_a) {
        return lin2_error(a, ERR_GEN_UFIND_INT_LIN2 - 15);
    }
    if (chksum == 0) return (uint32_t)a_size;

    if (status < LIN2_MAX_STATUS) {
         return ERR_GEN_UFIND_INT_LIN2 - 43;
    }
    if (a[a_size - 2] != magic_content(a)) {
         return ERR_GEN_UFIND_INT_LIN2 - 45;
    }
    for (i = 0; i < a_size; ++i) a_sum += a[i];
    if (a_sum) return ERR_GEN_UFIND_INT_LIN2 - 46;
    return (uint32_t)a_size;
}


/// @endcond


/** @brief Check an array representing a group acting on ``GF(2)^n``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. This function
performs some checks on the array ``a``. It returns an nonnegative
value if the data in ``a`` appear to be consistent, and negative
value otherwise. In case of a negative return value the array ``a``
may not be used!
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check(uint32_t *a, uint32_t len_a)
{
    return lin2_check(a, len_a, 0);
}




/** @brief Check if an orbit array has been finalized

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. This function checks
if the array ``a`` of length ``len_a`` has been finalized by calling
function ``gen_ufind_lin2_finalize``. The function returns the
actual size of the array ``a`` if this is the case and a negative
otherwise. Note the a finalized array contains an internal checksum.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check_finalized(uint32_t *a, uint32_t len_a)
{
    return lin2_check(a, len_a, 1);
}



/************************************************************************
*************************************************************************
***  Compatibility to older versions
*************************************************************************
************************************************************************/




/** @brief Output mapping computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
``v`` over ``GF(2)`` as described in function ``gen_ufind_lin2_init``.
Let ``n`` be the dimension of that vector space as returned by
function ``gen_ufind_lin2_dim``. The function computes a mapping
from the vectors in ``V`` to a set of representatives of the orbits
on ``V`` under the action of the group. The function writes this
mapping into the array ``map`` of size ``l_map``.

Thus ``l_map >= 1 << n`` must hold. The function returns the actual
length ``1 << n`` of the array ``map``. It returns a negative value
in case of failure, e.g. if the array ``map`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_get_map(uint32_t *a, uint32_t *map, uint32_t l_map)
{
    lin2_type s;
    uint32_t i;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    load_lin2_info(a, &s);
    if (check_out_buf32(map, l_map, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = s.p_t[i];
        map[i] = ((v & 0xff000000UL) == 0xfe000000UL) ? i : v & 0xffffffUL;
    }
    return 1UL << s.n;
}


/** @brief Output main table computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
``v`` over ``GF(2)`` as described in function ``gen_ufind_lin2_init``.
Let ``n`` be the dimension of that vector space as returned by
function ``gen_ufind_lin2_dim``. The function copies the main table
from the array ``a`` to the array `t` of length ``l_t`` as is.
Here ``l_t >= 1 << n`` must hold. The function returns the actual
length ``1 << n`` of the array ``t``. It returns a negative value
in case of failure, e.g. if the array ``t`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_get_table(uint32_t *a, uint32_t *t, uint32_t l_t)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    if (check_out_buf32(t, l_t, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    memcpy(t, s.p_t, sizeof(uint32_t) << s.n);
    return 1UL << s.n;
}



/** @brief Output the partition computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Array ``a`` contains
the set of orbits in the vector space under the action of the group.

Alternatively, this set of orbits could be computed with the union-find
algorithm described in function ``gen_ufind_lin2_init``.
Assume that ``table`` is a table generated with the union-find algorithm
corresponding to the set of orbits in the array ``a`` generated by
function ``gen_ufind_lin2_init``.

Then ``gen_ufind_lin2_orbits(a, map, l_map, ind, l_ind)`` is equivalent
to ``gen_ufind_partition(table, l_t, map, ind, l_ind)``

Here the length of that table is ``l_t = 1 << gen_ufind_lin2_dim(a)``.
The length of the array ``map`` is  equal to ``l_map = l_t``.
The length of the array ``ind`` is  equal
to ``l_ind = gen_ufind_lin2_n_orbits(a) + 1``.

*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbits(uint32_t *a, uint32_t *t, uint32_t l_t, uint32_t *x, uint32_t l_x)
{
    lin2_type s;
    uint32_t i;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    if (check_out_buf32(t, l_t, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    if (check_out_buf32(x, l_x, s.n_orbits + 1)) return ERR_GEN_UFIND_OUT_SHORT;
    /* Ye olde waye to do the worke
    memcpy(t, s.p_t, sizeof(uint32_t) <<  s.n);
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = t[i];
        if ((v & 0xff000000UL) == 0xfe000000UL) v == 0x80000000UL;
        else v &= 0xffffffUL;
        t[i] = v;
    }
    return gen_ufind_partition(t, 1UL << s.n, t, x, s.n_orbits + 1);
    */
    for (i = 0; i < (1UL << s.n); ++i)  t[i] = s.p_o[i] & 0xffffff;
    x[0] = 0;
    for (i = 0; i < s.n_orbits; ++i) {
        int32_t d = read_length_info(s.p_o + x[i]);
        if (d < 0) return ERR_GEN_UFIND_INT_LIN2 - 51;
        x[i+1] = x[i] + d;
    }
    if (x[s.n_orbits] != (1UL << s.n)) return ERR_GEN_UFIND_INT_LIN2 - 52;
    return s.n_orbits;
}




/****************************************
// Deprecated benchmark, do not use!

uint64_t gen_ufind_lin2_find_next_bit_set(uint32_t n, uint64_t *bitmap, uint32_t start_index)
{
    uint64_t res = 0;
    volatile uint32_t i = start_index;  // trick the compiler optimization
    volatile uint64_t *b = bitmap; 
    while (n--) res += find_next_bit_set(b, i);
    return res;
}

***************************************/



//  %%GEN h
/// @endcond 
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




