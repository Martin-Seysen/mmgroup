/** @file gen_ufind_lin2.c
The functions in file ``gen_ufind_lin2.c`` deal with the operation of
a group \f$G\f$ as a permutation group on the vector
space \f$V = \mbox{GF}_2^n\f$ for \f$n \leq 24\f$. Such a group is
generated by a set  of  \f$n \times n\f$ bit matrices acting on \f$V\f$
by right multiplication. The functions in this module can compute
orbits on \f$V\f$ under the action of \f$G\f$, and representatives and
sizes of these orbits. They can also compute Schreier vectors for these
orbits, so that we can find an element of \f$G\f$ mapping a vector
in an orbit to any other vector in the same orbit.

Function ``gen_ufind_lin2_init`` creates an (opaque) array ``a``
that will be used for storing information about the action of a group
on a vector space  \f$V = \mbox{GF}_2^n\f$. Such an array will be
called an *orbit array*. If a function uses an orbit array, this will
always be the first parameter of the function; and that parameter
will have the name ``a``. The user may add generators of the
group \f$G\f$ to orbit array ``a`` by calling
function ``gen_ufind_lin2_add``.

Once all generators have been added, users may e.g. call
function ``gen_ufind_lin2_rep_v`` for finding the chosen
representative \f$w\f$ of the orbit of a vector \f$v \in V\f$. Then
they may then function  ``gen_ufind_lin2_map_v`` for finding
a \f$g \in G\f$ with \f$v g = w\f$.

The functions in this module may be used e.g. for computing the orbits
of the Leech lattice mod 2 under the action of (a subgroup of) the
Conway group \f$\mbox{Co}_1\f$.

The internal structure of the opaque array ``a`` is not described in
the public documentation. For details we refer to the explanations in
file ``gen_ufind_lin2_aux.h``.
*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT
#include <stdlib.h> 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#include "clifford12.h"
// The following file contains the stuctures for internal use by
// the functions in file(s) gen_ufind_lin2*.c  
#include "gen_ufind_lin2_aux.h"
/// @endcond 






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c





//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c

/************************************************************************
* Auxiliary functions
************************************************************************/



/** Transform a vector with an affine transformation

Let \f$V = GF_2^n\f$. We store an affine mapping \f$V \rightarrow V\f$
given by \f$v \mapsto v \cdot A + b, v, b \in V\f$, \f$A\f$
an \f$n \times n\f$ bit matrix, in an array ``m`` of \f$n + 1\f$
unsigned 32-bit integers as follows.
Row ``i``, ``0 <= i < n`` of matrix \f$A\f$ is stored in ``m[i]`` as
a bit vector; bit vector ``b`` is stored in  ``m[n]``.

The function returns the bit vector \f$v \cdot A + b\f$.
*/
// %%EXPORT px
uint32_t gen_ufind_lin2_mul_affine(uint32_t v, uint32_t *m, uint32_t n)
{
    return vmatmul_aff(v, m, n);
}



/************************************************************************
*************************************************************************
*** Compute orbits of a group acting on a vector space over GF(2)
*************************************************************************
************************************************************************/





/**  Size of a structure for finding orbits in ``GF(2)^n``.

For details we refer to function ``gen_ufind_lin2_init``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_size(uint32_t n, uint32_t k)
{
    if (n == 0 || n > LIN2_MAX_N) return ERR_GEN_UFIND_LIN2_DIM;
    if(k > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    return LIN2_LEN_HEADER + (2UL << n) +
         lin2_generator_size(n, k) + 2;
}





/************************************************************************
* Initialization of an orbit array 
************************************************************************/



/**  @brief Initialize orbit array for a group acting on ``GF(2)^n``

Let \f$G\f$ be a group acting on a vector
space \f$V = \mbox{GF}_2^n\f$. That group is generated by
generators \f$g_i, 0 \leq i < k\f$. We store the group (given by
its generators) in an opaque *orbit array* ``a``.
This module provides functions for computing orbits on \f$V\f$
under the action of the group \f$G\f$ from the information stored
in the orbit array ``a``. It also provides a function for finding an
element of \f$G\f$ that maps a vector in \f$V\f$ to a (chosen)
representative of its orbit.

You may use function ``gen_ufind_lin2_add`` to add
generators  ``g_i, 0 <= i < k`` to the arrray ``a``. These generators
are sored as ``n`` times ``n`` bit matrices acting on \f$V\f$ by right
multiplication. The maximum number of generators allowd is given by
parameter ``n_g``.

The required length of the orbit array ``a`` may be computed by calling
function ``gen_ufind_lin2_size(n, n_g)``. At present the length of
of ``a`` is approximately ``2 << n`` plus the space for storing
the generators of the group and their inverses. Limitations
are ``n <= 24`` and ``n_g <= 127``.

Note that \f$G\f$ acts on row vectors in \f$\mbox{GF}_2^n\f$. Such
a row vector is encoded in the same way as a row of a matrix ``g_i``.

The function returns 0 in case of success and a negative value
in case of error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_init(uint32_t *a, uint32_t l_a, uint32_t n, uint32_t n_g)
{
    int32_t l_a_expected, status;
    lin2_type s;

    status = l_a_expected = gen_ufind_lin2_size(n, n_g);
    if (status < 0) goto done;
    status = check_out_buf32(a, l_a, l_a_expected);
    if (status < 0)  goto done;
    s.status = 0;
    s.n = n;
    s.n_max_g = n_g;
    s.n_g = 0;
    s.n_orbits = 0;
    s.n_vectors = 1UL << n;

    if (status < 0) goto done;
    store_lin2_info(&s, a);
    status = load_lin2_info(a, &s);

    // intialize union-find algorithm on orbits in main table s.p_t
    status = gen_ufind_init(s.p_t, 1UL << n);

done:
    return lin2_error(a, status);
}



/************************************************************************
* Obtaining information from an orbit array
************************************************************************/



/** @brief Given a group acting on ``GF(2)^n`` the function returns ``n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the dimension of the vector space.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_dim(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n;
}


/** @brief Return number of generators of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the number of generators of the group.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_gen(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n_g;
}


/** @brief Return max number of generators of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
returns the maximum number of generators of the group that can be
stored in array ``a``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_max_gen(uint32_t *a)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    return status < 0 ? status : s.n_max_g;
}


/** @brief Increase max number of generators of a group acting on ``GF(2)^n``

The function tries to pad an orbit array ``a``  as described in
function ``gen_ufind_lin2_init``. Here ``len_a`` is the allocated
laength of the orbit array ``a``, and ``n_max_g`` is the requested
number of generators group generators to be stored in ``a``.

The function returns the new maximum allowed number of generators of
the group. It returns a negative value in case of a error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_pad(uint32_t *a, uint32_t len_a, uint32_t n_max_g)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    if (status < 0) return status;
    if (status >= 2) return ERR_GEN_UFIND_STATE;
    if (n_max_g > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    n_max_g = n_max_g < s.n_max_g ? s.n_max_g : n_max_g;
    if ((status = gen_ufind_lin2_size(s.n, n_max_g)) < 0) return status;
    if (len_a < (uint32_t)(status)) return ERR_GEN_UFIND_OUT_SHORT;
    s.n_max_g = n_max_g;
    store_lin2_info(&s, a);
    return  n_max_g;
}


/** @brief Return a generator of a group acting on ``GF(2)^n``

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``. The function
reads a (possibly inverted) generator of the group from ``a``
and writes it into the array ``g`` of length ``l_g``. On
input ``i = 2 * k`` it stores generator ``k``; and on
input ``i = 2 * k + 1`` it stores the inverted generator ``k``.
Here ``0 <= k < gen_ufind_lin2_n_gen(a)`` must hold.

The generator is returned as an integer array of length ``n``,
with ``n = gen_ufind_lin2_dim(a)``, encoded as an ``n`` times ``n``
bit matrix as \f$A\f$ specified in function ``gen_ufind_lin2_init``.
That function also supports generators \f$v \mapsto v \cdot A + b\f$.
In case \f$b \neq 0\f$ we require ``l_g > n`` and store \f$b\f$
in ``g[n]``.

The function returns ``n`` in case of success and a negative value
in case of error; e.g. if the array ``g`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_gen(uint32_t *a, uint32_t i, uint32_t *g, uint32_t l_g)
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t *p_gen, len_aff;
    if (status < 0) return status;
    if (i >= 2 * s.n_g) return ERR_GEN_UFIND_IN_LARGE;
    p_gen = lin2_generator(&s, i);
    len_aff = s.n + (p_gen[s.n] != 0);
    if (check_out_buf32(g, l_g, len_aff)) return ERR_GEN_UFIND_OUT_SHORT;
    memcpy(g, p_gen, len_aff * sizeof(uint32_t));
    return s.n;
}









/************************************************************************
* Add a generator to the group stored in the structure
************************************************************************/

/// @cond DO_NOT_DOCUMENT 



/// @endcond



/**  @brief Add a generator of a group to an orbit array

Let ``a`` be an orbit array that stores a group acting on a vector
space as described in function ``gen_ufind_lin2_init``.
Function ``gen_ufind_lin2_add`` extends the group stored in the
orbit array by adding a generator \f$g\f$ to the group.

Let \f$G\f$ be the group acting on a vector
space \f$V = \mbox{GF}_2^n\f$ stored in the orbit array ``a``. The
group is generated by generators \f$g_i, 0 \leq i < k\f$. We store
these generators in the array ``a`` that must have been initialized
with function  ``gen_ufind_lin2_init``.
Function ``gen_ufind_lin2_add`` adds a generator \f$g\f$ to the array.
Generator \f$g\f$ must given as an ``n`` times ``n`` bit
matrix \f$A\f$ acting on \f$V\f$ by right multiplication. Here
``n`` is given by ``n = gen_ufind_lin2_dim()``. Row ``j``
(with 0 <= j < n) of bit matrix \f$A\f$ must be encoded as a bit
vector in the entry ``g[j]`` of the array referred by parmameter ``g``
in the usual way. The length ``l_g`` of the array referred by ``g``
must be at least ``n``.

Groups acting on \f$V\f$ by an affine transformation are supported.
In case ``l_g > n`` the generator \f$g\f$ acts as the
transformation \f$v \mapsto v \cdot A + b\f$, where \f$A\f$ is as
above, and \f$b\f$ is the bit vector stored in ``g[n]``.

Caution: The case \f$b \neq 0\f$ has not yet been tested.

All generators should be added to the orbit array ``a`` immediately
after initialization. Any function retrieving orbit information
from that array may trigger a lengthy calculation that makes adding
more generators impossible.

Parameter ``use`` should usually be 1. In the special case ``use = 0``
we consider \f$g\f$ as a generator for the group when computing
orbits; but \f$g\f$ will be dropped from the list of generators stored
in the array ``a`` if it does not increase any orbit in the
space \f$V\f$.

The function returns 1 if generator \f$g\f$ is kept, 0 if \f$g\f$ is
dropped, and a negative value in case of error. An error occurs e.g.
if the generator is not invertible.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_add(uint32_t *a, uint32_t *g, uint32_t l_g, uint32_t use)
{
    lin2_type s;
    int32_t status;
    uint32_t j, *p_gout, *p_gout_inv, mask, affine;
    status = load_lin2_info(a, &s);
    if (status != 0) return status < 0 ? status : ERR_GEN_UFIND_STATE;
    mask =   (1UL << s.n) - 1;
    status = check_out_buf32(g, l_g, s.n);
    affine = l_g > s.n; 
    if  (status < 0) goto done;
    status = ERR_GEN_UFIND_LIN2_GEN;
    if (s.n_g >= s.n_max_g) goto done;
    p_gout = lin2_generator(&s, 2 * s.n_g);
    for (j = 0; j < s.n; ++j) p_gout[j] = g[j] & mask;
    p_gout[s.n] = affine ? (g[s.n] & mask) : 0;
    status = ERR_GEN_UFIND_INVERSE;
    p_gout_inv = lin2_generator(&s, 2 * s.n_g + 1);
    if (mat_inverse_aff(p_gout, s.n, p_gout_inv)) goto done;
    status = union_linear(s.p_t, s.n, p_gout);
    if (status < 0) goto done; 
    status =  (status | use) != 0;
    s.n_g += status;
    store_lin2_info(&s, a);

done:
    if (status < 0) a[0] = (uint32_t)status;
    return status;

}





/************************************************************************
* Transform a vector by a group element
************************************************************************/



/** @brief Transform a vector by a group element

Here ``a`` refers to an orbit array ``a`` encoding a group \f$G\f$
(given by generators) acting on a space of bit vectors. A group
element \f$g\f$ is stored as a word of generators of \f$G\f$
of length ``l_b`` in the array referred by ``b``. An entry ``i``
in the array ``b`` corresponds to the generator given
by ``gen_ufind_lin2_gen(a, i, ...)``.

The function returns the bit vector ``v`` transformed by the group
element \f$g\f$.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_transform_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
{
    lin2_type s;
    uint32_t i;
    int32_t status = load_lin2_info(a, &s);
    if (status < 0) return status;
    v &= (1UL << s.n) - 1;
    for (i = 0; i < l_b; ++i) {
        if (b[i] >= 2 * s.n_g) {
            if (b[i] == 0xfe) continue;
            return ERR_GEN_UFIND_INT_LIN2 - 32;
        }
        v = vmatmul_aff(v, lin2_generator(&s, b[i]), s.n);
    }
    return v;
}




/************************************************************************
* Finalize initialization of structure 
************************************************************************/




/// @cond DO_NOT_DOCUMENT






static inline 
int32_t finalize_initalization(uint32_t *a, lin2_type *ps)
// Upgrade the status of the orbit array ``a`` from 0 to 1.
// A status different from 0 is not changed. The function also loads
// the header and the pointers to the data in the upgraded array ``a``
// into the structure of type ``lin2_typ`` referred by ``ps``. Such
// a structure is described in file ``gen_ufind_lin2_aux.h``.
// The function returns the (upgraded) status.
{
    lin2_type s;
    int32_t status = load_lin2_info(a, ps);
    uint32_t i, mask, *p_ind = NULL;

    if (status != 0) return status;
    load_lin2_info(a, &s);
    s.n_max_g = s.n_g;

    // Finalize union-find algorithm on orbits in main table s.p_t
    status = gen_ufind_find_all_min(s.p_t, 1UL << s.n);
    if  (status < 1) {
        if (status == 0) status = ERR_GEN_UFIND_INT_LIN2 - 2;
        goto done;
    }
    s.n_orbits = status;
    mask =   (1UL << s.n) - 1;

    // Store orbit information in table s.p_o.
    // Allocate memory an compute teporary orbit index table
    p_ind = malloc((s.n_orbits + 1) * sizeof(uint32_t));
    status = ERR_GEN_UFIND_MEM;
    if (p_ind == NULL) goto done;
    status = gen_ufind_partition(s.p_t, 1UL << s.n, s.p_o, p_ind,
         s.n_orbits + 1);
    if (status < 0) goto done;

    // Complete map in main table
    for (i = 0; i < (1UL << s.n); ++i) { 
        uint32_t entry = s.p_t[i];
        if (entry & 0x80000000UL) {
            s.p_t[i] = 0xfe000000UL;
        } else {
            status = ERR_GEN_UFIND_INT_LIN2 - 3;
            if (entry >= i) goto done;
            status = ERR_GEN_UFIND_INT_LIN2 - 4;
            if (((s.p_t[entry] >> 24) & 0xffUL) != 0xfeUL) goto done;
            s.p_t[i] = entry | 0xff000000UL;
        }
    }

    // Copy length information from table in p_ind to orbit information
    // table s.p_o. Store pointers to table s.p_o in main table s.p_t.
    status = ERR_GEN_UFIND_INT_LIN2 - 5;
    for (i = 0; i < s.n_orbits; ++i) {
        uint32_t index = p_ind[i] & mask;
        uint32_t rep = s.p_o[index] & mask;
        if (((s.p_t[rep] >> 24) & 0xff) != 0xfe) goto done;
        s.p_t[rep] |= index;
        write_length_info(s.p_o + index, p_ind[i+1] - p_ind[i]);
    }
    status = 1;
    
done:
    s.status = status;
    if (p_ind) free(p_ind);
    ps->status = s.status = (uint32_t)(status);
    store_lin2_info(&s, a);
    load_lin2_info(a, ps);
    return status;
}


/// @endcond



/************************************************************************
*************************************************************************
*** Finding representatives of and sizes of an orbit
*************************************************************************
************************************************************************/



/************************************************************************
* Finding orbits of representatives via a Schreier vector
************************************************************************/

/// @cond DO_NOT_DOCUMENT





static int32_t
compressed_lin2_map_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
// This is equivalent to function ``gen_ufind_lin2_map_v``
// if ``a.status == LIN2_COMPRESSED``.
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t mask, x, g, l_b_start;

    if (status < 0) return status;
    if (status != LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    mask = (1UL << s.n) - 1;
    l_b_start = l_b;

    while (1) {
        v &= mask;
        x = s.p_o[bitvector32_bsearch(s.p_o, s.n_vectors, v << 8)];
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return ERR_GEN_UFIND_ENTRY_UF;
        if (g == 0xfe)  return l_b_start - l_b;
        if (l_b-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *b++ = (uint8_t)(g);
        v = vmatmul_aff(v, lin2_generator(&s, g), s.n);
    }
}

static int32_t
compressed_lin2_rep_v(uint32_t *a, uint32_t v)
// This is equivalent to function ``gen_ufind_lin2_rep_v``
// if ``a.status == LIN2_COMPRESSED``.
{
    lin2_type s;
    int32_t status = load_lin2_info(a, &s);
    uint32_t mask, x, g, l_b;

    if (status < 0) return status;
    if (status != LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    mask = (1UL << s.n) - 1;
    l_b = s.n_vectors;  // We don't want an infinite loop

    while (--l_b) {
        v &= mask;
        x = s.p_o[bitvector32_bsearch(s.p_o, s.n_vectors, v << 8)];
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return ERR_GEN_UFIND_ENTRY_UF;
        if (g == 0xfe)  return v;
        v = vmatmul_aff(v, lin2_generator(&s, g), s.n);
    }
    return ERR_GEN_UFIND_OUT_SHORT;
}





/// @endcond



/************************************************************************
* Finding orbits and their representatives;
************************************************************************/



/** @brief Return number of orbits a group acting on ``GF(2)^n``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. The function returns the number
of orbits (on the vector space under the action of the group)
stored in that array.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_orbits(uint32_t *a)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);
    return status < 0 ? status : s.n_orbits;
}




/** @brief Return representative of orbit of bit vector ``v``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns a representative
of the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_rep_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, entry;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
         return compressed_lin2_rep_v(a, v);
    }
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    return (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
}


/** @brief Return length of orbit of bit vector ``v``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns the length of
the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_len_orbit_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, rep, index_o;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    mask = (1UL << s.n) - 1;
    v &= mask;    
    if (status == LIN2_COMPRESSED) {
        status = v = compressed_lin2_rep_v(a, v);
        if (status < 0) return status;
        index_o = bitvector32_bsearch(s.p_t, s.n_orbits, v);
        if (v != s.p_t[index_o]) return ERR_GEN_UFIND_INT_LIN2 - 35;
        return s.p_t[s.n_orbits + index_o];
    }
    rep = gen_ufind_lin2_rep_v(a, v);
    index_o = s.p_t[rep] & mask;
    return read_length_info(s.p_o + index_o);
}


/// @cond DO_NOT_DOCUMENT

// forward declaration
static int32_t 
compute_orbit(uint32_t *a, uint32_t v, uint32_t *o, uint32_t l_o);
 
/// @endcond

/** @brief Return orbit of bit vector ``v`` as an array

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``, and let ``v`` be
a vector in that space. The function writes the orbit of ``v`` under
the action of the group into the array ``r`` of length ``l_r``.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

The function returns the length of the orbit in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_len_orbit_v``
for determining the length of the orbit in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbit_v(uint32_t *a, uint32_t v, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, rep, index_o, *p_o, i;
    int32_t length;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return compute_orbit(a, v, r, l_r);
    mask = (1UL << s.n) - 1;
    rep = status = gen_ufind_lin2_rep_v(a, v);
    if (status < 0) return status;
    index_o = s.p_t[rep] & mask;
    p_o = s.p_o + index_o;
    length = read_length_info(s.p_o + index_o);
    if (check_out_buf32(r, l_r, length)) return ERR_GEN_UFIND_OUT_SHORT;
    for (i = 0; i < (uint32_t)length; ++i) {
        r[i] = p_o[i] & mask;
    }
    return length;
}



/** @brief Return representatives of orbits under the action of a group

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. The function writes a list of
representatives of all orbits stored in ``a`` into the array ``r``
of length ``l_r``. Here vectors are encoded as integers as described
in function ``gen_ufind_lin2_init``.

The function returns the number of these orbits in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_n_orbits`` for
determining the number of orbits in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_representatives(uint32_t *a, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, index_o = 0, l_r1 = l_r, d;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        if (s.n_orbits >  l_r) return ERR_GEN_UFIND_OUT_SHORT;
        memcpy(r, s.p_t, s.n_orbits * sizeof(uint32_t));
        return s.n_orbits;
    }
    mask = (1UL << s.n) - 1;

    while (index_o < (1UL << s.n)) {
        d = status = read_length_info(s.p_o + index_o);
        if (status < 0) return -status;
        if (l_r1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *r++ = s.p_o[index_o] & mask;
        index_o += d;
    }
    return l_r - l_r1;
}




/** @brief Return lengths of orbits under the action of a group

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. Then
function ``gen_ufind_lin2_representatives`` computes a list of
representatives of all orbits under the action of the group. This
function computes the list of the lengths of all these orbits (in the
same order as in function ``gen_ufind_lin2_representatives``) and
writes that list into array ``r`` of length ``l_r``. Parameters and
return value are as in function ``gen_ufind_lin2_representatives``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbit_lengths(uint32_t *a, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t index_o = 0, l_r1 = l_r, d;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
         if (s.n_orbits >  l_r) return ERR_GEN_UFIND_OUT_SHORT;
         memcpy(r, s.p_t + s.n_orbits, s.n_orbits * sizeof(uint32_t));
         return s.n_orbits;
    }
    while (index_o < (1UL << s.n)) {
        d = status = read_length_info(s.p_o + index_o);
        if (status < 0) return -status;
        if (l_r1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *r++ = d;
        index_o += d;
    }
    return l_r - l_r1;
}




/************************************************************************
*************************************************************************
***  Computing Schreier vectors
*************************************************************************
************************************************************************/






/************************************************************************
* Compute a Schreier vector
************************************************************************/

/// @cond DO_NOT_DOCUMENT


// Store a Schreier vector for one or more orbits of a group acting on
// a vector space \f$V = \mbox{GF}_2^n\f$. Such a group is represented
// in a an (opaque) array as in function ``gen_ufind_lin2_init``.

// The following strcture is temporarily used for computing a
// Schreier vector.
typedef struct {
   uint32_t *p_alloc;    // pointer to allocated memory
   uint32_t *p_start;    // start of queue
   uint32_t *p_end;      // end of queue
   uint32_t *p_overflow; // physical end of queue
   uint32_t *p_g;        // pointer to (expanded) generators
   uint32_t *p_b;        // pointer to bitmap of vectors already done
   uint32_t n;           // dimension ``n`` of representation
   uint32_t n_g;         // number of generators
} schreierv_type;



static inline int32_t
schreier_vector_alloc(schreierv_type *p_s, uint32_t *a, uint32_t max_entries)
// Allocate space for a structure of type ``schreierv_type``
// The function stores a pointer to s structure of
// type ``schreierv_type`` in the pointer ``p_s`` that can be used
// for computing a Schreier vector in an orbit array ``a``.
// parameter ``max_entries`` is the number of bit vectors stored
// in array ``a``, which is usually ``1 << gen_ufind_lin2_dim(a)``.
{
    uint32_t buf_size, l_b, g_start, i;
    uint64_t *p64_g;
    int32_t status;
    lin2_type s;
    p_s->p_alloc = NULL;
    if ((status = load_lin2_info(a, &s)) < 0) return status;
    p_s->n = s.n;
    p_s->n_g = s.n_g;
    // Allocate work buffer and set pointers in structure
    l_b = (p_s->n > 6) ? (1UL << (p_s->n - 5)) : 2;
    g_start = (max_entries + 1) & 0xfffffffeUL;
    buf_size = g_start + p_s->n_g * 0x600 + l_b;
    p_s->p_alloc = malloc(buf_size * sizeof(uint32_t));
    if (p_s->p_alloc == NULL) return ERR_GEN_UFIND_MEM;
    p_s->p_end = p_s->p_start = p_s->p_alloc;
    p_s->p_overflow = p_s->p_alloc + max_entries;
    p_s->p_g = p_s->p_alloc + g_start;
    p_s->p_b = p_s->p_g + p_s->n_g * 0x600;

    // Load generator matrices
    p64_g = (uint64_t*) p_s->p_g;
    for (i = 0; i < p_s->n_g; ++i) {
        store64_gen(p64_g + 0x300 * i, p_s->n, lin2_generator(&s, 2 * i),
            lin2_generator(&s, 2 * i + 1));
    }

    // Initialize bitmap table
    memset(p_s->p_b, 0xff, l_b * sizeof(uint32_t));
    return 0;
}


static inline int32_t
schreier_vector_addv(schreierv_type *p_s, uint32_t *p_v, uint32_t n)
// Add list of start vectors to a structure of type ``schreierv_type``
// Let ``v_list`` be a list of bit vectors of length ``n`` referred
// by ``p_v``. The function marks all these vectors as start vectors
// in the structure of type ``schreierv_type`` referred by ``p_s``.
// See function ``gen_ufind_lin2_map_v_gen`` for background.
{
    uint32_t i, mask = (1UL << p_s->n) - 1, entry;
    uint32_t *p_0 = p_s->p_end, *p_b = p_s->p_b;
    if (n > p_s->p_overflow - p_0) return ERR_GEN_UFIND_IN_LARGE;
    for (i = 0; i < n; ++i) {
        entry = p_v[i] & mask;
        p_b[entry >> 5] &= ~(1UL << (entry & 0x1f));
        p_0[i] = entry | 0xfe000000UL;
   }
   p_s->p_end += n;
   return 0;
}


static inline int32_t
schreier_vector_compute(schreierv_type *p_s)
// Compute Schreier vector in a structure of type ``schreierv_type``
// After allcoating such a structure referred by ``p_s`` with
// function ``schreier_vector_alloc`` and setting the start vectors
// with function ``schreier_vector_addv`` the function computes a
// Schreier vector in that structure.
// The array referred by ``p_s->p_start`` of
// length ``p_s->p_end - p_s->p_start`` contains the mapping
// corresponding the Schreier vector as an unordered list.
// Bits 0,...,23 of an entry of that array contain the bit vector
// being mapped. Bits 24,...,31 contain the Schreier vector image
// as described in function ``gen_ufind_lin2_map_v_gen``.
{
    uint32_t n_g = p_s->n_g, *p_b = p_s->p_b, i;
    uint32_t *p_start = p_s->p_start, *p_end = p_s->p_end;
    uint32_t *p_overflow = p_s->p_overflow;

    while (p_start < p_end) {
        uint_fast32_t data = *p_start++, d0, d1, d2;
        uint64_t *p64_g1 = (uint64_t*)(p_s->p_g), v64;
        d0 = data & 0xff;
        d1 = ((data >> 8) & 0xff) + 0x100;
        d2 = ((data >> 16) & 0xff) + 0x200;
        for (i = 0; i < n_g; ++i) {
            uint_fast32_t img0, img1, mask0, mask1;
            v64 = p64_g1[d0] ^ p64_g1[d1] ^ p64_g1[d2];
            img0 =  (uint32_t)(v64 & 0xffffffffUL);
            img1 =  (uint32_t)(v64 >> 32);
            mask0 = 1UL << (img0 & 0x1f);
            mask1 = 1UL << (img1 & 0x1f);
            p64_g1 += 0x300;
            if (p_b[img0 >> 5] & mask0) {
                p_b[img0 >> 5] ^= mask0;
                if (p_end >= p_overflow) return ERR_GEN_UFIND_INT_LIN2 - 25;
                *p_end++ = img0 | (i << 25) | 0x01000000UL;
            }
            if (p_b[img1 >> 5] & mask1) {
                p_b[img1 >> 5] ^= mask1;
                if (p_end >= p_overflow) return ERR_GEN_UFIND_INT_LIN2 - 25;
                *p_end++ = img1 | (i << 25);
            }
        }
    }
    p_s->p_start = p_s->p_alloc;
    p_s->p_end = p_end;
    return (uint32_t)(p_end - p_s->p_start);
}



static inline int32_t
schreier_vector_orbit(schreierv_type *p_s, uint32_t v)
// Compute orbit of ``v`` in a structure of type ``schreierv_type``
// After allcoating such a structure referred by ``p_s`` with
// function ``schreier_vector_alloc``  the function computes the
// orbit of vector ``v`` in that structure. The array referred
// by ``p_s->p_start`` of length ``p_s->p_end - p_s->p_start``
// contains the orbit as an unordered list.
{
    uint32_t n_g = p_s->n_g, *p_b = p_s->p_b, i;
    uint32_t *p_start = p_s->p_alloc, *p_end = p_s->p_alloc + 1;
    uint32_t *p_overflow = p_s->p_overflow;
    
    *p_start = v & ((1UL << p_s->n) - 1);
    while (p_start < p_end) {
        uint_fast32_t data = *p_start++, d0, d1, d2;
        uint64_t *p64_g1 = (uint64_t*)(p_s->p_g), v64;
        d0 = data & 0xff;
        d1 = ((data >> 8) & 0xff) + 0x100;
        d2 = ((data >> 16) & 0xff) + 0x200;
        for (i = 0; i < n_g; ++i) {
            uint_fast32_t img0, mask0;
            v64 = p64_g1[d0] ^ p64_g1[d1] ^ p64_g1[d2];
            img0 =  (uint32_t)(v64 & 0xffffffffUL);
            mask0 = 1UL << (img0 & 0x1f);
            p64_g1 += 0x300;
            if (p_b[img0 >> 5] & mask0) {
                p_b[img0 >> 5] ^= mask0;
                if (p_end >= p_overflow) return ERR_GEN_UFIND_OUT_SHORT;
                *p_end++ = img0;
            }
        }
    }
    p_s->p_start = p_s->p_alloc;
    p_s->p_end = p_end;
    return (uint32_t)(p_end - p_s->p_start);
}




static inline void
schreier_vector_dealloc(schreierv_type *p_s)
// Deallocate the space for a structure of type ``schreierv_type``
// referred by ``p_s``. This reverser the effect of
// function ``schreier_vector_alloc``.
{
    if (p_s->p_alloc != NULL) free(p_s->p_alloc);
}


/// @endcond


/************************************************************************
* compute orbit of a vector
************************************************************************/

/// @cond DO_NOT_DOCUMENT

static int32_t 
compute_orbit(uint32_t *a, uint32_t v, uint32_t *o, uint32_t l_o)
// Compute the orbit of vector ``v`` using the group generators
// in the orbit array ``a`` only;
// and store the sorted orbit in the array ``o`` of length ``l_o``.
{
    schreierv_type sv;
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    status = schreier_vector_alloc(&sv, a, l_o);
    if (status < 0) goto done;
    // compute the orbit
    status = schreier_vector_orbit(&sv, v);
    if (status < 0)  goto done;
    if (check_out_buf32(o, l_o, (uint32_t)status)) {
        status = ERR_GEN_UFIND_OUT_SHORT;
        goto done;
    }
    // Copy orbit to destination and sort it
    l_o = (uint32_t)status;
    memcpy(o, sv.p_start, l_o * sizeof(uint32_t));
    bitvector32_sort(o, l_o);
done:
    schreier_vector_dealloc(&sv);
    return status;
}

/// @endcond


/************************************************************************
* Add orbit map and operation of generators to table
************************************************************************/


/// @cond DO_NOT_DOCUMENT



static inline int32_t add_generators(uint32_t *a, lin2_type *p_s)
// Upgrade the status of the orbit array ``a`` to 2; and
// store header information and pointers in structure ``p_s``.
{
    schreierv_type sv;
    lin2_type s;
    int32_t status = finalize_initalization(a, p_s);
    uint32_t i, mask;

    if (status < 0 || status >= 2) return status;
    load_lin2_info(a, &s);

    status = schreier_vector_alloc(&sv, a, 1UL << s.n);
    if (status < 0) goto done;

    // Load start vectors to queue and mark them in bitmap table
    status = gen_ufind_lin2_representatives(a, sv.p_start, 1UL << s.n);
    if (status != (int32_t)s.n_orbits) {
        status = status < 0 ? status : ERR_GEN_UFIND_INT_LIN2 - 23;
        goto done;
    }
    status = schreier_vector_addv(&sv, sv.p_start, s.n_orbits);
    if (status < 0) goto done;
    status = schreier_vector_compute(&sv);
    if (status != (int32_t)(1L << s.n)) {
        status = status < 0 ? status : ERR_GEN_UFIND_INT_LIN2 - 24;
        goto done;
    }
    mask = (1UL << s.n) - 1;
    for (i = 0; i < 1UL << s.n; ++i) {
        uint32_t entry = sv.p_start[i];
        s.p_t[entry & mask] &= mask;
        s.p_t[entry & mask] |= (entry & 0xff000000UL);
    }

    status = a[0] = 2;  // update main status
done:
    schreier_vector_dealloc(&sv);
    if (status < 0) return lin2_error(a, status);
    load_lin2_info(a, p_s);
    return status;
}




/// @endcond




/************************************************************************
*************************************************************************
***  Use Schreier vectors to compute mappings between orbits
*************************************************************************
************************************************************************/



/** @brief Return entry of Schreier vector for bit vector ``v``

A Schreier vector is a (partial) mapping from a space \f$V\f$
of bit vectors associated with an orbit array ``a`` to the
set of generators stored in that array. The image of a bit
vector may also be ``NUL``, indicating that the bit vector is
the representative of its orbit. For background we refer to
[HEOBrien05], Section 4.1.1.

A return value ``i < 0xfe`` refers to the generator given by
``gen_ufind_lin2_gen(a, i, ...)``.

Return value ``0xfe`` means that ``NUL``, i.e. input ``v`` is
the representative of its orbit.

Return value ``0xff`` means that the Schreier vector for ``v``
has not been computed.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v_gen(uint32_t *a, uint32_t v)
{
    uint32_t mask, x, g;
    lin2_type s;
    int32_t status = add_generators(a, &s);
    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        x = bitvector32_bsearch(s.p_o, s.n_vectors, v << 8);
        g = x & 0xff;
        x >>= 8;
        if (x ^ v || g > 0xfe) return 0xff;
        return g;
    }
    mask = (1UL << s.n) - 1;
    return (s.p_t[v & mask] >> 24) & 0xff;
}




/** @brief Return group element mapping ``v`` to orbit representative

Here ``a`` refers to an orbit array ``a`` encoding a group \f$G\f$
(given by generators) acting on a space \f$V\f$ of bit vectors.
The function computes an element \f$g\f$ of \f$G\f$ that maps
the bit vector ``v`` to the representative of its orbit.

Element \f$g\f$ is computed as a word of generators of \f$G\f$
of length ``l_b`` and stored in the array referred by ``b``.
An entry ``i`` in the array ``b`` to the generator given by
``gen_ufind_lin2_gen(a, i, ...)``.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
{
    uint32_t mask, w, l_b1, entry;
    lin2_type s;
    int32_t status = add_generators(a, &s);
    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) {
        return compressed_lin2_map_v(a, v, b, l_b);
    }
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    w = (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
    l_b1 = l_b;
    while (1) {
        uint32_t gen = (entry >> 24) & 0xff;
        if (gen == 0xfe) {
            return l_b - l_b1;
        }
        if ((entry & mask) != w) return ERR_GEN_UFIND_INT_LIN2 - 31;
        if (l_b1-- == 0) return ERR_GEN_UFIND_OUT_SHORT;
        *b++ = (uint8_t)gen;
        if (gen >= 2 * s.n_g) return ERR_GEN_UFIND_INT_LIN2 - 32;
        v = vmatmul_aff(v, lin2_generator(&s, gen), s.n);
        entry = s.p_t[v];
    }
    return ERR_GEN_UFIND_INT_LIN2 - 33;
}



/************************************************************************
*************************************************************************
***  Finalize the computation of all data in an array of orbits
*************************************************************************
************************************************************************/



/// @cond DO_NOT_DOCUMENT
#define LIN2_MAGIC 0x1fecd173UL

#define LIN2_AMUL 0x5ac83257UL

static inline uint32_t magic_content(uint32_t *a)
// Return hash value over the header of the orbit array ``a``
{
    uint32_t s = LIN2_MAGIC, i;
    for (i = 0; i < LIN2_LEN_HEADER; ++i) s = s * LIN2_AMUL + a[i];
    return s;
}



/// @endcond

/** @brief Compute all possible information about orbits

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Some information
to be stored in ``a`` is computed on demand only. Before writing the
array ``a`` to a file, it may be useful to store the maximum possible
amount of infomation in ``a``. This function performs that task.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_finalize(uint32_t *a)
{
    lin2_type s;
    int32_t status, a_length, i;
    uint32_t a_sum = 0;
    status = add_generators(a, &s);
    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return 0;
    s.n_max_g = s.n_g;
    store_lin2_info(&s, a);
    a_length =  gen_ufind_lin2_size(s.n, s.n_g);
    a[a_length - 2] = magic_content(a);
    for (i = 0; i < a_length - 1; ++i) a_sum += a[i];
    a[a_length -1] = 0 - a_sum;
    return a_length;
}




/************************************************************************
*************************************************************************
***  compress an orbit array
*************************************************************************
************************************************************************/

/// @cond DO_NOT_DOCUMENT

static inline uint32_t
sort_remove_duplicates(uint32_t *a, uint32_t  l_a)
// Sort an arbitrary array ``a`` of length ``l_a`` and remove
// duplicate entries. This is done in place. The function returns
// the length of ``a`` after removing duplicates.
{
    uint32_t *b = a, *p_b = a, i;
    if (l_a == 0) return 0;
    bitvector32_sort(a, l_a);
    *p_b++ = a[0];
    for (i = 1; i < l_a; ++i) {
        if (a[i] != a[i-1]) *p_b++ = a[i];
    }
    return (int32_t)(p_b - b);
}


static inline int32_t
sort_orbit_reps(uint32_t *a, uint32_t *o, uint32_t l_o, uint32_t *reps)
// Let ``o`` be an array of bit vectors of length ``l_o``.
// The function stores the of list of the representatives of these
// bit vectors in in the array ``reps``. The list of representatives
// is sorted and duplicates are removed. Orbit array ``a`` is used
// to find the representative of an orbit.
// The function returns the length of the array ``reps``.
{
    uint32_t i;
    int32_t status;
    for (i = 0; i < l_o; ++i) {
        reps[i] = status = gen_ufind_lin2_rep_v(a, o[i]);
        if (status < 0) return status;
    }
    return sort_remove_duplicates(reps, l_o);
}

/// @endcond



/** @brief Compute size of buffer for compressing an orbit array

We may compress an orbit array ``a`` to an orbit array ``c``
containing not all orbits of array ``a``, by calling
function ``gen_ufind_lin2_compress(a, o, l_o, c, l_c)``.
Hier ``o`` is a list of ``l_o`` bit vectors, such that the
orbits of these vectors will be added to the orbit
array ``c``.
Function ``gen_ufind_lin2_compress_size(a, o, l_o)``
returns the number ``l_c`` of entries required for the
array ``c``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_compressed_size(uint32_t *a, uint32_t *o, uint32_t l_o)
{
    lin2_type s;
    uint32_t i, *reps = NULL;
    uint64_t v_sum = 0, l_o0, l_o1, o_len;
    int32_t status = finalize_initalization(a, &s);
    l_o0 = LIN2_LEN_HEADER + (uint64_t)l_o;
    if (status < 0) return status;
    if (status > 2) return ERR_GEN_UFIND_STATE;
    reps = malloc(l_o * sizeof(uint32_t));
    if (reps == NULL) return ERR_GEN_UFIND_MEM;
    l_o1 = status = sort_orbit_reps(a, o, l_o, reps);
    if (status < 0) goto done;
    v_sum = 0;
    for (i = 0; i < l_o1; ++i) {
        v_sum += gen_ufind_lin2_len_orbit_v(a, reps[i]);
    }
    o_len = LIN2_LEN_HEADER + 2 * l_o1 + v_sum
             + lin2_generator_size(s.n, s.n_g) + 2;
    o_len = o_len > l_o0 ? o_len : l_o0;
    if (o_len > 0x7fffffffULL) return ERR_GEN_UFIND_OUT_SHORT;
    status = (int32_t)o_len;
  done:
    if (reps != NULL) free(reps);
    return status;
}



/** @brief Compress an orbit array.

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Here orbit
array ``a`` encodes a group \f$G\f$ acting on a space \f$V\f$ of
bit vectors. This function extracts a set of orbits of \f$G\f$
on \f$V\f$ and stores the orbit array containing these orbits in
the buffer ``c`` of length ``l_c``. Most of the functions in
this module can be applied to the orbit array ``c`` in the same
way as to orbit array ``a``. An error occurs if the buffer
is too short. The required buffer length can be computed with
function ``gen_ufind_lin2_compressed_size``. Array ``o`` of
length ``l_o`` is a list of vectors in \f$V\f$. The orbits
of the vectors in that list will be stored in the buffer ``c``.

A typical use case is the action of a group on the Leech lattice
mod 2. The functions in this module may compute orbits and
Schreier vectors for that group. If we are only interested in
the action of the group on short vectors only, then we might
restrict the orbit array of orbits  short vectors. This will
save space.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_compress(uint32_t *a, uint32_t *o, uint32_t l_o, uint32_t *c, uint32_t l_c)
{
    lin2_type s, sc;
    schreierv_type sv;
    uint32_t i, c_sum = 0, c_size_new;
    int32_t status = finalize_initalization(a, &s);
    if (c) c[0] = (uint32_t)ERR_GEN_UFIND_OUT_SHORT;
    sc.p_t = c + LIN2_LEN_HEADER; 
    l_o = status = sort_orbit_reps(a, o, l_o, sc.p_t);
    if (status < 0) return status;

    memcpy(&sc, &s, LIN2_LEN_HEADER * sizeof(uint32_t));
    sc.status = LIN2_COMPRESSED;
    sc.p_t = c + LIN2_LEN_HEADER;
    if (l_c < l_o + LIN2_LEN_HEADER) return ERR_GEN_UFIND_OUT_SHORT;
    sc.n_orbits = l_o = status = sort_orbit_reps(a, o, l_o, sc.p_t);
    if (status < 0) return status;
    c_size_new = LIN2_LEN_HEADER + 2 * sc.n_orbits;
    if (l_c < c_size_new) return ERR_GEN_UFIND_OUT_SHORT;
    sc.n_vectors = 0;
    for (i = 0; i < l_o; ++i) {
        sc.p_t[i + l_o] = gen_ufind_lin2_len_orbit_v(a, sc.p_t[i]);
        sc.n_vectors += sc.p_t[i + l_o];
    }
    c_size_new += sc.n_vectors + lin2_generator_size(sc.n, sc.n_g) + 2;
    if (l_c < c_size_new) return ERR_GEN_UFIND_OUT_SHORT;

    sc.p_o = sc.p_t + (size_t)(2 * l_o);
    sc.p_g = sc.p_o + (size_t)sc.n_vectors;
    status = schreier_vector_alloc(&sv, a, sc.n_vectors);
    if (status < 0) goto done;
    status = schreier_vector_addv(&sv, sc.p_t, l_o);
    if (status < 0) goto done;
    status = schreier_vector_compute(&sv);
    if (status < 0) goto done;
    for (i = 0; i < sc.n_vectors; ++i) {
        uint32_t entry = sv.p_start[i];
        sc.p_o[i] = (entry >> 24) | (entry << 8);
    }
    memcpy(sc.p_g, s.p_g, lin2_generator_size(s.n, s.n_g) * sizeof(uint32_t));
    bitvector32_sort(sc.p_o, sc.n_vectors);
  
    c[0] = 0;
    store_lin2_info(&sc, c);
    c[c_size_new - 2] = magic_content(c);
    for (i = 0; i < c_size_new - 1; ++i) c_sum += c[i];
    c[c_size_new - 1] = 0 - c_sum;
    status = c_size_new;
done:  
    schreier_vector_dealloc(&sv); 
    return status;   
}



/************************************************************************
*************************************************************************
***  Check if an orbit array has been finalized
*************************************************************************
************************************************************************/


/// @cond DO_NOT_DOCUMENT

static int32_t lin2_check(uint32_t *a, uint32_t len_a, uint32_t chksum)
{
    lin2_type s;
    int32_t status;
    uint32_t a_sum = 0, gen_size;
    uint64_t i, a_size;
    if (len_a <= LIN2_LEN_HEADER) {
        return lin2_error(a, ERR_GEN_UFIND_INT_LIN2 - 13);
    }
    status = load_lin2_info(a, &s);
    if (status < 0) return status;
    if (s.n == 0 || s.n > LIN2_MAX_N) return ERR_GEN_UFIND_LIN2_DIM;
    if (s.n_g > LIN2_MAX_N_G) return ERR_GEN_UFIND_LIN2_GEN;
    gen_size = lin2_generator_size(s.n, s.n_g);
    if (status == LIN2_COMPRESSED) {
        a_size = LIN2_LEN_HEADER + 2 * s.n_orbits + s.n_vectors 
                   + gen_size + 2;
    } else {
        a_size = LIN2_LEN_HEADER + (2UL << s.n)  + gen_size + 2;
    }
    if (a_size > (uint64_t)len_a) {
        return lin2_error(a, ERR_GEN_UFIND_INT_LIN2 - 15);
    }
    if (chksum == 0) return (uint32_t)a_size;

    if (status < LIN2_MAX_STATUS) {
         return ERR_GEN_UFIND_INT_LIN2 - 43;
    }
    if (a[a_size - 2] != magic_content(a)) {
         return ERR_GEN_UFIND_INT_LIN2 - 45;
    }
    for (i = 0; i < a_size; ++i) a_sum += a[i];
    if (a_sum) return ERR_GEN_UFIND_INT_LIN2 - 46;
    return (uint32_t)a_size;
}


/// @endcond


/** @brief Check an array representing a group acting on ``GF(2)^n``

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. This function
performs some checks on the array ``a``. It returns an nonnegative
value if the data in ``a`` appear to be consistent, and negative
value otherwise. In case of a negative return value the array ``a``
may not be used!
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check(uint32_t *a, uint32_t len_a)
{
    return lin2_check(a, len_a, 0);
}




/** @brief Check if an orbit array has been finalized

Let ``a`` be an orbit array as described in
function ``gen_ufind_lin2_init``. This function checks
if the array ``a`` of length ``len_a`` has been finalized by calling
function ``gen_ufind_lin2_finalize``. The function returns the
actual size of the array ``a`` if this is the case and a negative
otherwise. Note the a finalized array contains an internal checksum.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check_finalized(uint32_t *a, uint32_t len_a)
{
    return lin2_check(a, len_a, 1);
}



/************************************************************************
*************************************************************************
***  Compatibility to older versions
*************************************************************************
************************************************************************/




/** @brief Output mapping computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
``v`` over ``GF(2)`` as described in function ``gen_ufind_lin2_init``.
Let ``n`` be the dimension of that vector space as returned by
function ``gen_ufind_lin2_dim``. The function computes a mapping
from the vectors in ``V`` to a set of representatives of the orbits
on ``V`` under the action of the group. The function writes this
mapping into the array ``map`` of size ``l_map``.

Thus ``l_map >= 1 << n`` must hold. The function returns the actual
length ``1 << n`` of the array ``map``. It returns a negative value
in case of failure, e.g. if the array ``map`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_get_map(uint32_t *a, uint32_t *map, uint32_t l_map)
{
    lin2_type s;
    uint32_t i;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    load_lin2_info(a, &s);
    if (check_out_buf32(map, l_map, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = s.p_t[i];
        map[i] = ((v & 0xff000000UL) == 0xfe000000UL) ? i : v & 0xffffffUL;
    }
    return 1UL << s.n;
}


/** @brief Output main table computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
``v`` over ``GF(2)`` as described in function ``gen_ufind_lin2_init``.
Let ``n`` be the dimension of that vector space as returned by
function ``gen_ufind_lin2_dim``. The function copies the main table
from the array ``a`` to the array `t` of length ``l_t`` as is.
Here ``l_t >= 1 << n`` must hold. The function returns the actual
length ``1 << n`` of the array ``t``. It returns a negative value
in case of failure, e.g. if the array ``t`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_get_table(uint32_t *a, uint32_t *t, uint32_t l_t)
{
    lin2_type s;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    if (check_out_buf32(t, l_t, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    memcpy(t, s.p_t, sizeof(uint32_t) << s.n);
    return 1UL << s.n;
}



/** @brief Output the partition computed by the union-find algorithm

Let ``a`` be an orbit array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Array ``a`` contains
the set of orbits in the vector space under the action of the group.

Alternatively, this set of orbits could be computed with the union-find
algorithm described in function ``gen_ufind_lin2_init``.
Assume that ``table`` is a table generated with the union-find algorithm
corresponding to the set of orbits in the array ``a`` generated by
function ``gen_ufind_lin2_init``.

Then ``gen_ufind_lin2_orbits(a, map, l_map, ind, l_ind)`` is equivalent
to ``gen_ufind_partition(table, l_t, map, ind, l_ind)``

Here the length of that table is ``l_t = 1 << gen_ufind_lin2_dim(a)``.
The length of the array ``map`` is  equal to ``l_map = l_t``.
The length of the array ``ind`` is  equal
to ``l_ind = gen_ufind_lin2_n_orbits(a) + 1``.

*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbits(uint32_t *a, uint32_t *t, uint32_t l_t, uint32_t *x, uint32_t l_x)
{
    lin2_type s;
    uint32_t i;
    int32_t status = finalize_initalization(a, &s);

    if (status < 0) return status;
    if (status == LIN2_COMPRESSED) return ERR_GEN_UFIND_STATE;
    if (check_out_buf32(t, l_t, 1UL << s.n)) return ERR_GEN_UFIND_OUT_SHORT;
    if (check_out_buf32(x, l_x, s.n_orbits + 1)) return ERR_GEN_UFIND_OUT_SHORT;
    /* Ye olde waye to do the worke
    memcpy(t, s.p_t, sizeof(uint32_t) <<  s.n);
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = t[i];
        if ((v & 0xff000000UL) == 0xfe000000UL) v == 0x80000000UL;
        else v &= 0xffffffUL;
        t[i] = v;
    }
    return gen_ufind_partition(t, 1UL << s.n, t, x, s.n_orbits + 1);
    */
    for (i = 0; i < (1UL << s.n); ++i)  t[i] = s.p_o[i] & 0xffffff;
    x[0] = 0;
    for (i = 0; i < s.n_orbits; ++i) {
        int32_t d = read_length_info(s.p_o + x[i]);
        if (d < 0) return ERR_GEN_UFIND_INT_LIN2 - 51;
        x[i+1] = x[i] + d;
    }
    if (x[s.n_orbits] != (1UL << s.n)) return ERR_GEN_UFIND_INT_LIN2 - 52;
    return s.n_orbits;
}


//  %%GEN h
/// @endcond 
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




