/** @file gen_union_find.c
The functions in file ``gen_union_find.c`` implement a union-find
algorithm. This may be used e.g. for computing the orbits of  the Leech 
lattice mod 2 under the action of a group.


*/


/*************************************************************************
** External references 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT
#include <stdlib.h> 
#include <string.h>
#include "mat24_functions.h"
#define MMGROUP_GENERATORS_INTERN
#include "mmgroup_generators.h"
#include "clifford12.h"
/// @endcond 






// %%GEN ch
#ifdef __cplusplus
extern "C" {
#endif
// %%GEN c


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


/*************************************************************************
** Error codes 
*************************************************************************/

/// @cond DO_NOT_DOCUMENT


#define ERR_MEM        -1L   // out of memory
#define ERR_UF_LARGE   -2L   // Too many entries for union-find algorithm
#define ERR_IN_LARGE   -3L   // Input parameter to large
#define ERR_OUT_SHORT  -3L   // Output buffer too short
#define ERR_ENTRY_UF   -4L   // Entry not in union-find table
#define ERR_TABLE_UF   -5L   // Union-find table too large
#define ERR_LIN2_DIM   -6L   // Dimension n of GF(2)^n is 0 or too large
#define ERR_LIN2_GEN   -7L   // Too many generators for subgroup of SL_2(2)^n
#define ERR_INVERSE    -8L   // Generator matrix is not invertible

#define ERR_INT_TABLE -100L   // internal error in union-find table

#define ERR_INT_LIN2  -200L   // internal array for subgroup of SL_2(2)^n


static inline int32_t
check_out_buf32(uint32_t *p_buf, uint32_t len, uint32_t min_len)
{
     if (p_buf == NULL || min_len & 0x80000000UL || len < min_len)
        return ERR_OUT_SHORT;
     return 0;
}



/// @endcond 


/*************************************************************************
** The union-find algorithm 
*************************************************************************/





/** @brief Initialize table for union-find algorithm

The function initializes an array referred by parameter ``table``
for performing a union-find algorithm on the set ``S(length)`` of
integers ``i`` with ``0 <= i < length``. Array ``table`` must have
size ``length``. Here ``0 <= length <= 0x40000000``must hold.

Then ``table`` will store a partition of the set ``S(length)``
in an internal format. Initially, that partition consists of
singletons. One may use function ``gen_ufind_union`` for joining
two sets of that partition. Any set in the partition is
represented by an element of that set. The rules for computing
a representative of a set are not disclosed to the user.
You may use function ``gen_ufind_find`` for finding the
representative of a set. After calling
function ``gen_ufind_find_all_min`` each set is represented by
its smallest element. The representative of a set may change
after calling function ``gen_ufind_union``.

The function returns 0 in case of success, and a negative value
in case of failure (e.g. if ``length`` is too big.)
*/
// %%EXPORT px
int32_t gen_ufind_init(uint32_t * table, uint32_t length)
{
     uint32_t i;
     if (length > 0x40000000) return ERR_UF_LARGE;
     for (i = 0; i < length; ++i) table[i] = 0x80000000;
     return 0;
}







/** @brief The find function for the union-find algorithm

Let ``S(length)`` be the set of integers ``i`` with ``0 <= i < length``;
and let a partition of ``S(length)`` be stored in the array ``table``
(of size ``length``) as described in function ``gen_ufind_init``.

The function returns the representative of the set containing the
integer ``n``. It returns a negative number in case of failure,
e.g. if ``n >= length``.
*/
// %%EXPORT px
int32_t gen_ufind_find(uint32_t *table, uint32_t length, uint32_t n)
{
     uint32_t u = n, p, gp;
     if (length > 0x40000000UL) return ERR_TABLE_UF;
     if (n >= length) return ERR_ENTRY_UF;
 
     p = table[u];
     while ((p & 0x80000000UL) == 0) {
         if (p >= length) return ERR_INT_TABLE - 1;
         gp = table[p];
         if (gp & 0x80000000UL) return p;
         table[u] = gp;
         u = gp;
         if (u >= length) return ERR_INT_TABLE - 2;
         p = table[u];
     }
     return u;
}





/** @brief The union function for the union-find algorithm

Let ``S(length)`` be the set of integers ``i`` with ``0 <= i < length``;
and let a partition of ``S(length)`` be stored in the array ``table``
(of size ``length``) as described in function ``gen_ufind_init``.

The function joins the sets in the partition containg the
elements ``n1`` and ``n2``.
*/
// %%EXPORT px
void gen_ufind_union(uint32_t * table, uint32_t length, uint32_t n1, uint32_t n2)
{
     uint32_t u1 = n1, u2 = n2, p1, p2, gp1, gp2;
     if (length > 0x40000000UL || n1 >= length || n2 >= length) return;

     p1 = table[u1];
     while ((p1 & 0x80000000UL) == 0) {
         if (p1 >= length) return;
         gp1 = table[p1];
         if (gp1 & 0x80000000UL) {
             u1 = p1; p1 = gp1;
             break;
         }
         if (u1 >= length) return;
         table[u1] = gp1;
         u1 = gp1;
         p1 = table[u1];
     }
     // u1 = find(n1); p1 = rank(tree(n1)) + CONST

     p2 = table[u2];
     while ((p2 & 0x80000000UL) == 0) {
         if (p2 >= length) return;
         gp2 = table[p2];
         if (gp2 & 0x80000000UL) {
             u2 = p2; p2 = gp2;
             break;
         }
         if (u2 >= length) return;
         table[u2] = gp2;
         u2 = gp2;
         p2 = table[u2];
     }
     // u2 = find(n1); p2 = rank(tree(n1)) + CONST

     if (u1 == u2) return; // n1 and n2 are in the same set

     if (p1 <= p2) {
         table[u1] = u2;
         if (p1 == p2) ++table[u2];
     } else {
         table[u2] = u1;
     }
}




   
  


/** @brief Choose smallest representatives for sets in union-find algorithm

Let ``S(length)`` be the set of integers ``i`` with ``0 <= i < length``;
and let a partition of ``S(length)`` be stored in the array ``table``
(of size ``length``) as described in function ``gen_ufind_init``.

The function chooses the smallest element of a set in a partition
as the representative of the set. Thus a subsequent call to
function ``gen_ufind_find`` with parameter ``n`` returns the
smallest element of the set containg ``n``.

The function returns the number of the sets in the partition.
A negative return value indicates a error the array ``table``.
*/
// %%EXPORT px
int32_t gen_ufind_find_all_min(uint32_t *table, uint32_t length)
{
    uint32_t n, u, p, mu, u1, gp, res = 0;

    if (length > 0x40000000UL) return ERR_TABLE_UF;
     
    // Map all elements of a set S to the representative u(S) of S;
    // and map u(S) to 0xc0000000 + mu, where mu = min(S). Ignore
    // all singletons S = {u}. A singleton is  mapped to 0x80000000.
    for (n = 0; n < length; ++n) {
        u = mu = n; 
        p = table[u];
        res += p >> 31;
        if (p == 0x80000000UL) continue;
        while ((p & 0x80000000UL) == 0) {
            mu = mu < p ? mu : p;
            u = p;
            if (u >= length) {
                 u = 0x40000000UL;
                 goto table_stuck;
            }
            p = table[u];
        }
        if ((p & 0xc0000000UL) == 0xc0000000UL) {
            p &= 0x3fffffffUL;
            mu = mu < p ? mu : p;
        }
        table[u] = mu | 0xc0000000UL; 
 table_stuck:
        u1 = n;
        p = table[u1];
        while ((p & 0xc0000000UL) == 0) {
            table[u1] = u;
            u1 = p;
            p = table[u1];
        }
    }

    // Map all elements of a set S to min(S); and map min(S) to
    // 0x80000001. We have min(S) = table[u(s)] & 0x3fffffff.
    // Ignore all singletons S.
    for (n = 0; n < length; ++n) {
        u = n; 
        p = table[u];
        if (p & 0x80000000UL) {
            if ((p & 0x40000000UL) == 0) continue;
            p &= 0x3fffffffUL;
            if (p >= length) {
                table[u] = 0x40000000UL;
                continue;
            }
            table[u] = p;
            table[p] = 0x80000001;
            continue;
        }
        gp = table[p];
        if (gp & 0x80000000UL) {
            if ((gp & 0x40000000UL) == 0) continue;
            gp &= 0x3fffffffUL;
        }
        if (gp >= length) {
            table[p] = 0x40000000UL;
            continue;
        }
        table[u] = table[p] = gp;
        table[gp] = 0x80000001;
    }

    // Return number of sets in partition 
    return res;
}






/** @brief Map entries of the partition to their representatives

Let ``S(length)`` be the set of integers ``i`` with ``0 <= i < length``;
and let a partition of ``S(length)`` be stored in the array ``table``
(of size ``length``) as described in function ``gen_ufind_init``.

Function ``gen_ufind_find_all_min`` must be called before calling this
function. Then this function computes an array ``map`` of the same length
as array ``table`` that maps each entry of the set ``S(length)`` to the
smallest element  of the partition stored in the array ``table``.

Output array ``map`` for storing that mapping must have size ``length``.

The function returns 0 in case of success and a negative
value in case of failure.
*/
// %%EXPORT px
int32_t gen_ufind_make_map(uint32_t *table, uint32_t length, uint32_t *map)
{
    uint32_t p, n;

    if (length > 0x40000000UL) return ERR_TABLE_UF;

    for (n = 0; n < length; ++n) {            
        p = table[n];
        if (p & 0x80000000) {
            map[n] = n;
        } else if (p >= length) {
            // map[n] = 0xffffffffUL;
            return ERR_INT_TABLE - 11;
        } else { 
            if (p >= n) return ERR_INT_TABLE - 12;
            if ((table[p] & 0x80000000) == 0) ERR_INT_TABLE - 13;
            map[n] = p;
        }
    }
    return 0;
}






/** @brief Output the partition computed by the union-find algorithm

Let ``S(l_t)`` be the set of integers ``i`` with ``0 <= i < l_t``;
and let a partition of ``S(l_T)`` be stored in the array ``table``
(of size ``l_t``) as described in function ``gen_ufind_init``.

We assume that the partition stored in the array ``table``
contains ``n_sets`` sets. Then we store a list of lists in the
array ``map``, where each list corresponds to a set in
the partition. We write some index infomation for interpreting
these lists into the array ``ind`` of l ``l_ind``.

Array ``map`` will contain the ``l_t`` elements of the
set ``S(l_t)`` in such a way that for ``0 <= i < n_sets``
the ``i``-th set in the partition is equal to the set of
integers given by ``map[ind[i]], ...,  map[ind[i+1] - 1]``.

So the array ``ind`` must have size at least ``n_sets + 1``;
i.e. we must have ``l_ind > n_sets``. Array ``map`` must have
size ``l_t``; it may overlap with array ``table``.
Function ``gen_ufind_find_all_min`` must be called before calling
this function. Note that function ``gen_ufind_find_all_min``
returns ``n_sets`` in case of success.

The entries ``map[ind[i]], ...,  map[ind[i+1] - 1]``
corresponding to set in the partition are sorted. The sets of
the partition are sorted by their smallest elements.

The function returns ``n_set`` in case of success and a negative
value in case of failure.
*/
// %%EXPORT px
int32_t gen_ufind_partition(uint32_t *table, uint32_t l_t, uint32_t *map, uint32_t *ind, uint32_t l_ind)
{
    uint32_t *next, n, p, i=0, j, last, fst;
    int32_t status = -1;

    if (l_t > 0x40000000UL) return ERR_TABLE_UF;
    next = malloc(sizeof(uint32_t) * (l_t + l_ind));
    if (next == NULL) return ERR_MEM;

    // Here ``next`` is an array of l_t ``l_t + i.`` index ``i``
    // is incremented whenever we see a new set of the partition while
    // iterating though the ``table``. Eventually, ``i`` will be the
    // number of sets in the partition.

    // We will store the set {x_1, ..., x_m} with index ``j`` in the
    // arrays ``ind`` and ``next`` as shown in the following figure.
    // This peculiar scheme is dictated by the fact that array ``next``
    // is usually much larger than array ``ind``. Note that the original
    // information about the set is copied from ``table`` to ``ind``
    // and ``next``. In the ``table`` the enties ``x_i, i > 1`` contain
    // a pointer to ``x_1``; thus index ``j`` must be reachable from
    // the entry ``x_1`` stored in the array ``next``. Also we want 
    // the first entry ``x_1`` and the last entry ``x_m`` to be
    // reachable from the index ``j`` of the set  {x_1, ..., x_m}.
    
    //
    //  ind:     +--------------------j
    //           |                    ^
    //           |                    |
    //           v                    v
    //  next:   x_m  -->  x_1  -->  j + l_t  -->  x_2 --> x_3
    //           ^                                         |
    //           |____________ ............ _______________|

    for (n = 0; n < l_t; ++n) {
        p = table[n];                     // In case m = 1 we put:
        if (p & 0x80000000) {             //   ind:            +----i
            status = ERR_INT_TABLE - 21;  //                   |    |
            if (i >= l_ind) goto cleanup; //                   v    |
            ind[i] = next[n] = l_t + i;   //   next: x_1  -->  i + l_t
            next[l_t + i] = n;            //          ^             |
            ++i;                          //          |_____________|
        } else {
            if (p >= l_t) continue;
            // Now ``n`` is the entry to be appended to the set with 
            // index ``j``; and  ``p`` is the first element of that set
            // (corresponding to ``x_1`` in the figure above).
            status = ERR_INT_TABLE - 22;
            if (p >= n) goto cleanup;
            status = ERR_INT_TABLE - 23;
            if ((table[p] & 0x80000000) == 0) goto cleanup;
            j = next[p] - l_t; // index of the set
            status = ERR_INT_TABLE - 24;
            if (j >= i) goto cleanup;
            last = ind[j];        // old ``x_m`` in the figure above
            status =  ERR_INT_TABLE - 25;
            if (next[last] != p) goto cleanup;
            // append ``n`` to the list [x_1, ..., x_m]
            ind[j] = next[last] = n;   
            next[n] = p;          // let ``n`` point to the 1st element       
        }
    }

    // Store the number of the sets in ``l_ind``.
    status = ERR_INT_TABLE - 25;
    if (i >= l_ind) goto cleanup;
    l_ind = i;

    // Copy the elements of the sets from array ``next`` back to the
    // array ``map``, so the elements of the same set are adjacent.
    // Store index information for these sets in the array ``ind``.
    n = 0;
    for (i = 0; i < l_ind; ++i) {
        last = ind[i];        // Last element of the set
        ind[i] = n;           // Store index of the beginning of the set
        map[n++] = fst = next[last]; // store 1st element of the set
        p = next[l_t + i];    // 2nd element of the set or end marker
        while (p != fst) {    // Here  ``fst`` will be the end marker
            map[n++] = p;     // Fill ``map`` until end marker found
            p = next[p];
        } 
    }

    // Store total number of elements all sets in ``ind[l_ind]``.
    // Thus for ``0 <= j < l_ind``the j-th set contains the
    // elements ``map[k]``, for ``ind[j] <= k < ind[j+1].
    status = ERR_INT_TABLE - 26;
    if (n > l_t) goto cleanup;
    ind[l_ind] = n;
    status = l_ind;      // return the number of the sets
    
cleanup:
    free(next);
    return status;

}



/************************************************************************
*************************************************************************
*** Compute orbits of a group acting on a vector space over GF(2)
*************************************************************************
************************************************************************/


/************************************************************************
* Unite node i with node A * i, with A a matrix over GF(2)
************************************************************************/

/// @cond DO_NOT_DOCUMENT 
#define MAT_BLOCKSIZE 7

static inline uint32_t vmatmul(uint32_t v, uint32_t *m)
// Multiply 32-bit vector with 32 times 32 bit matrix v. You may zero
// high bits of v to multiply with matrix with less than 32 rows.
{
    uint32_t w = 0;
    while (v) {
       w ^= *m++ & (0UL - (v & 1UL));
       v >>= 1;
    }
    return w;
} 




/** @brief Perform union-find algorithm in ``GF(2)^n``

Let ``S(n)`` be the set of integers ``v`` with ``0 <= v < 1 << n``;
and let a partition of ``S(n)`` be stored in the array ``table``
(of size ``1 << n``) as described in function ``gen_ufind_init``.

In this function the entries of ``S(n)`` are interpreted as bit
vectors. The function joins the set containing ``v`` with the set
containing ``v * G[i]`` for all ``v`` in ``S(n)``, and
for  ``0 <= i < l_g``. Here ``G[i]`` is an ``n`` times ``n`` bit
matrix over GF(2) stored in the array referred by ``g``. Row ``j``
of bit matrix ``G[i]`` is stored in ``g[i * n + j]`` as an integer
encoding a bit vector. All bit vector arithmetic is done over GF(2).

Thus the array referred by ``table`` must have length ``1 << n``;
and the array referred by ``g`` must have length ``len_g * n``.

The function returns 0 in case of success and -1 in case of error.
*/
static inline int32_t
union_linear(uint32_t *table, uint32_t n, uint32_t *g, uint32_t l_g)
{
     uint32_t i, j0, j1, lg_bl, bl, w, a[1UL << MAT_BLOCKSIZE];
     uint32_t t_length = 1UL << n;
     uint32_t mask = t_length - 1;

     if (n > 30 || n == 0) return ERR_INT_TABLE - 31;
     lg_bl = (n + 1) >> 1;
     lg_bl = lg_bl < MAT_BLOCKSIZE ? lg_bl : MAT_BLOCKSIZE;
     bl = 1UL << lg_bl;
     for (i = 0; i < l_g; ++i) {
         for (j1 = 0; j1 < bl; ++j1) a[j1] = vmatmul(j1, g) & mask;
         for (j0 = 0; j0 < t_length; j0 += bl) {
             w = vmatmul(j0 >> lg_bl, g + lg_bl) & mask;
             for (j1 = 0; j1 < bl; ++j1) {
                 gen_ufind_union(table, t_length, j0 ^ j1, w ^ a[j1]);
             }
         }
         g += n;
     }
     return 0;

}



/// @endcond



/************************************************************************
* Initialize array dealing with a subgroup of SL_2(n) given by generators 
************************************************************************/

/// @cond DO_NOT_DOCUMENT 


// A structure for the data in the array ``a`` in function
// ``gen_ufind_lin2_init``
typedef struct {
   uint32_t status;    // Status of the array
   uint32_t n;         // dimenstion ``n`` of ``GF(2)^n``
   uint32_t n_g;       // Number of generators of the group ``G``
   uint32_t n_orbits;  // No of ``G`` orbits in ``GF(2)^n``
   uint32_t *p_t;      // Pointer to main table ``t`` inside ``a``
   uint32_t *p_o;      // Pointer to main table ``map`` inside ``a``
   uint32_t *p_g;      // Pointer to list of generators of group in ``a``
} lin2_type;

#define LIN2_MAX_STATUS  2UL  // Maximum good status
#define LIN2_MAX_N      24UL  // Maximum dimension n of GF(2)^n
#define LIN2_MAX_N_G   126UL  // Maximum No n_g of generators of group



static inline void load_lin2_info(uint32_t *a, lin2_type *ps)
{
    ps->status = a[0];
    ps->n = a[1];
    ps->n_g = a[2];
    ps->n_orbits = a[3];
    ps->p_t = a + 4;
    ps->p_o = ps->p_t + ((size_t)1UL << ps->n);
    ps->p_g = ps->p_o + ((size_t)1UL << ps->n);
}

static inline int32_t lin2_error(uint32_t *a, int32_t error)
{
    a[0] = (uint32_t)(error);
    return error;
}



/// @endcond

/**  Size of a structure for finding orbits in ``GF(2)^n``.

For details we refer to function ``gen_ufind_lin2_init``.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_size(uint32_t n, uint32_t k)
{
    if (n == 0 || n > LIN2_MAX_N) return ERR_LIN2_DIM;
    if(k > LIN2_MAX_N_G) return ERR_LIN2_GEN;
    return 4 + (2UL << n) + 2 * n * k + 2;
}



/// @cond DO_NOT_DOCUMENT


static inline int32_t 
mat_inverse(uint32_t *m, uint32_t n, uint32_t *m_inv)
// Store inverse of the ``n`` times ``n`` bit matrix ``m`` in the
// array ``m_inv``. Return 0 if inverse can be computed and -1 if not.
{
    uint64_t a[24];
    uint32_t i, mask = (1UL << n) - 1;
    if (n == 0 || n > sizeof(a) / sizeof(uint64_t)) return -1;
    for (i = 0; i < n; ++i) a[i] = m[i];
    if (bitmatrix64_inv(a, n)) return ERR_INVERSE;
    for (i = 0; i < n; ++i) m_inv[i] = (uint32_t)(a[i] & mask);
    return 0;
}




static inline void
write_length_info(uint32_t *a, uint32_t length)
{
    uint32_t x;
    x = 0x80 | ((length > 0x3f) << 6) | (length & 0x3f);
    *a++ = (*a & 0x00ffffffUL) | (x << 24);
    length >>= 6;
    while (length) {
        x = ((length > 0x3f) << 6) | (length & 0x3f);
        *a++ = (*a & 0x00ffffffUL) | (x << 24);
        length >>= 6;
    }
}


static inline int32_t
read_length_info(uint32_t *a)
{
    uint32_t x, length = 0, sh = 0;
    x = (*a++ >> 24) & 0xff;
    if ((x & 0x80) == 0) return -1;
    length = x & 0x3f;
    for (sh = 6; (sh < 24) && (x & 0x40); sh += 6) {
        x = (*a++ >> 24) & 0xff;
        if (x & 0x80) return ERR_INT_LIN2 - 1;
        length += (x & 0x3f) << sh;
    }
    return length;
}

/// @endcond



/**  @brief Compute orbits of a group acting on ``GF(2)^n``

Let \f$G\f$ be a group acting on a vector
space \f$V = \mbox{GF}_2^n\f$. That group is generated by
generators \f$g_i, 0 \leq i < k\f$. We store the group (given by
its generators) in an opaque array ``a``.
This module provides functions for computing orbits on \f$V\f$
under the action of the group \f$G\f$ from the information stored
in the array ``a``. It also provides a function for finding an
element of \f$G\f$ that maps a vector in \f$V\f$ to a (chosen)
representative of its orbit.

The ``k`` generators ``g_i, 0 <= i < k`` of the group must given
as ``n`` times ``n`` bit matrices acting on \f$V\f$ by right
multiplication. Here a row of a bit matrix must be encoded as a bit
vector in an integer in the usual way. The integer corresponding to
row ``j`` of matrix ``g_i`` must be stored in the entry ``i * n + j``
of the input array referred by parameter ``g``.

Thus the array referred by ``g`` must have length ``k * n``. The
internal structure of the output array ``a`` is undocumented.
The required length of the array ``a`` is computed by calling
function ``gen_ufind_lin2_size(n, k)``. At present the length of
of ``a`` is approximately ``2 << n`` plus the space for storing
the generators of the group and their inverses. Limitations
are ``n <= 24`` and ``k <= 126``.

Note that \f$G\f$ acts on row vectors in \f$\mbox{GF}_2^n\f$. Such
a row vector is encoded in the same way as a row of a matrix ``g_i``.

The function returns 0 in case of success and a negative value
in case of error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_init(uint32_t *a, uint32_t l_a, uint32_t n, uint32_t *g, uint32_t k)
{
    int32_t l_a_expected, status;
    uint32_t i, j, *p_gin, *p_gout, mask = (1UL << n) - 1;
    uint32_t *p_ind = NULL;
    lin2_type s;

    status = l_a_expected = gen_ufind_lin2_size(n, k);
    if (status < 0) goto done;
    status = check_out_buf32(a, l_a, l_a_expected);
    if (status < 0)  goto done;
    a[0] = 0;
    a[1] = n;
    a[2] = k;
    a[3] = 0;
    load_lin2_info(a, &s);

    // Perform union-find algorithm on orbits in main table s.p_t
    if (gen_ufind_init(s.p_t, 1UL << n) < 0) return lin2_error(a, -3);
    if (union_linear(s.p_t, n, g, k) < 0) return lin2_error(a, -4);
    status = gen_ufind_find_all_min(s.p_t, 1UL << n);
    if  (status < 1) {
        if (status == 0) status = ERR_INT_LIN2 - 2;
        goto done;
    }
    a[3] = s.n_orbits = status;

    // load bit matrices and their inverses to s.p_g
    p_gin = g;
    p_gout = s.p_g;
    for (i = 0; i < k; ++i) {
        for (j = 0; j < n; ++j) p_gout[j] = p_gin[j] & mask;
        if (mat_inverse(p_gin, n, p_gout + n)) return lin2_error(a, -5);
        p_gin += n;
        p_gout += 2 * n;
    }

    // Store orbit information in table s.p_o.
    // Allocate memory an compute teporary orbit index table
    p_ind = malloc((s.n_orbits + 1) * sizeof(uint32_t));
    if (p_ind == NULL) {
        status = ERR_MEM;
        goto done;
    }
    status = gen_ufind_partition(s.p_t, 1UL << s.n, s.p_o, p_ind,
         s.n_orbits + 1);
    if (status < 0) goto done;

    // Complete map in main table
    for (i = 0; i < (1UL << n); ++i) { 
        uint32_t entry = s.p_t[i];
        if (entry & 0x80000000UL) {
            s.p_t[i] = 0xfe000000UL;
        } else {
            status = ERR_INT_LIN2 - 3;
            if (entry >= i) goto done;
            status = ERR_INT_LIN2 - 4;
            if (((s.p_t[entry] >> 24) & 0xffUL) != 0xfeUL) goto done;
            s.p_t[i] = entry | 0xff000000UL;
        }
    }

    // Copy length information from table in p_ind to orbit information
    // table s.p_o. Store pointers to table s.p_o in main table s.p_t.
    status = ERR_INT_LIN2 - 5;
    for (i = 0; i < s.n_orbits; ++i) {
        uint32_t index = p_ind[i] & mask;
        uint32_t rep = s.p_o[index] & mask;
        if (((s.p_t[rep] >> 24) & 0xff) != 0xfe) goto done;
        s.p_t[rep] |= index;
        write_length_info(s.p_o + index, p_ind[i+1] - p_ind[i]);
    }
    status = 1;

done:
    if (p_ind) free(p_ind);
    a[0] = (uint32_t)(status);
    return (status < 0) ? status : 0;
}



/************************************************************************
* Obtaining information from array dealing with a subgroup of SL_2(n)
************************************************************************/

static inline int32_t
check_a_fast(uint32_t *a)
{
    if (a == NULL) return  ERR_INT_LIN2 - 11;
    if (a[0] > LIN2_MAX_STATUS || a[0] == 0) {
        if ((int32_t)a[0] < 0) return (int32_t)a[0];
        a[0] = (uint32_t)(ERR_INT_LIN2 - 12);
        return (int32_t)a[0];
    }
    return 0;
}


/** @brief Given a group acting on ``GF(2)^n`` the function returns ``n``

Let ``a`` be an array that stores a group acting on vector space
as described in function ``gen_ufind_lin2_init``. The function
returns the dimension of the vector space.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_dim(uint32_t *a)
{
    int32_t status = check_a_fast(a);
    return status < 0 ? status : a[1];
}


/** @brief Return number of generators of a group acting on ``GF(2)^n``

Let ``a`` be an array that stores a group acting on vector space
as described in function ``gen_ufind_lin2_init``. The function
returns the number of generators of the group.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_gen(uint32_t *a)
{
    int32_t status = check_a_fast(a);
    return status < 0 ? status : a[2];
}


/** @brief Return number of orbits a group acting on ``GF(2)^n``

Let ``a`` be an array that stores a group acting on vector space
as described in function ``gen_ufind_lin2_init``. The function
returns the number of orbits of the vector space under the action
of the group.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_n_orbits(uint32_t *a)
{
    int32_t status = check_a_fast(a);
    return status < 0 ? status : a[3];
}


/** @brief Return a generator of a group acting on ``GF(2)^n``

Let ``a`` be an array that stores a group acting on a vector space as
described in function ``gen_ufind_lin2_init``. The function stores a
(possibly inverted) generator of the group into the array ``g`` of
length ``l_g``. On input ``i = 2 * k`` it stores generator ``k``; on
input ``i = 2 * k + 1`` it stores the inverted generator ``k``.
Here ``0 <= k < gen_ufind_lin2_n_gen(a)`` must hold.

The generator is returned as an integer array of length ``n``,
with ``n = gen_ufind_lin2_dim(a)``, encoded as an ``n`` times ``n``
bit matrix as specified in function ``gen_ufind_lin2_init``.

The function returns ``n`` in case of success and a negative value
in case of error; e.g. if the array ``g`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_gen(uint32_t *a, uint32_t i, uint32_t *g, uint32_t l_g)
{
    lin2_type s;
    int32_t status = check_a_fast(a);
    if (status < 0) return status;
    load_lin2_info(a, &s);
    if (i >= 2 * s.n_g) return ERR_IN_LARGE;
    if (check_out_buf32(g, l_g, s.n)) return ERR_OUT_SHORT;
    memcpy(g, s.p_g + i * s.n, s.n * sizeof(uint32_t));
    return s.n;
}



/** @brief Check an array representing a group acting on ``GF(2)^n``

Let ``a`` be an array that stores a group acting on vector space
as described in function ``gen_ufind_lin2_init``. The function
performs some checks on the array ``a``. It returns an nonnegative
value (indicating the amount of information present in ``a``)
if the data in ``a`` appear to be consistent, and negative value
otherwise. In case of a negative return value the array ``a``
may not be used!
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check(uint32_t *a, uint32_t len_a)
{
    lin2_type s;
    int32_t a_size, status = check_a_fast(a);
    if (status < 0) return status;
    if (len_a < 6) return lin2_error(a, ERR_INT_LIN2 - 13);
    load_lin2_info(a, &s);
    a_size = status = gen_ufind_lin2_size(s.n, s.n_g);
    if (status < 0) return lin2_error(a, status);
    if ((uint32_t)a_size > len_a) return lin2_error(a, ERR_INT_LIN2 - 14);
    return a[0];
}




/************************************************************************
* Finding orbits and their representatives;
************************************************************************/


/** @brief Return representative of orbit of bit vector ``v``

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns a representative
of the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_rep_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, entry;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    return (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
}


/** @brief Return length of orbit of bit vector ``v``

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``, and let ``v``
be a vector in that space. The function returns the length of
the orbit of ``v`` under the action of the group.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``

A negative return value indicates an error.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_len_orbit_v(uint32_t *a, uint32_t v)
{
    lin2_type s;
    uint32_t mask, rep, index_o;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;
    rep = gen_ufind_lin2_rep_v(a, v);
    index_o = s.p_t[rep] & mask;
    return read_length_info(s.p_o + index_o);
}


/** @brief Return orbit of bit vector ``v`` as an array

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``, and let ``v`` be
a vector in that space. The function writes the orbit of ``v`` under
the action of the group into the array ``r`` of length ``l_r``.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

The function returns the length of the orbit in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_len_orbit_v``
for determining the length of the orbit in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbit_v(uint32_t *a, uint32_t v, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, rep, index_o, *p_o;
    int32_t length, i;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;
    rep = status = gen_ufind_lin2_rep_v(a, v);
    if (status < 0) return status;
    index_o = s.p_t[rep] & mask;
    p_o = s.p_o + index_o;
    length = read_length_info(s.p_o + index_o);
    if (check_out_buf32(r, l_r, length)) return ERR_OUT_SHORT;
    for (i = 0; i < length; ++i) {
        r[i] = p_o[i] & mask;
    }
    return length;
}



/** @brief Return representatives of orbits under the action of a group

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. The function writes
a list of representatives of all orbits under the action of the group
into the array ``r`` of length ``l_r``.
Here vectors are encoded as integers as described in
function ``gen_ufind_lin2_init``.

The function returns the number of orbit in case of success. It
returns a negative value in case of failure, e.g. if the array ``r``
is too short. One may use function ``gen_ufind_lin2_n_orbits`` for
determining the number of orbits in advance.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_representatives(uint32_t *a, uint32_t *r, uint32_t l_r)
{
    lin2_type s;
    uint32_t mask, index_o = 0, l_r1 = l_r, d;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;

    while (index_o < (1UL << s.n)) {
        d = status = read_length_info(s.p_o + index_o);
        if (status < 0) return -status;
        if (l_r1-- == 0) return ERR_OUT_SHORT;
        *r++ = s.p_o[index_o] & mask;
        index_o += d;
    }
    return l_r - l_r1;
}










/************************************************************************
* Add orbit map and operation of geneators to table
************************************************************************/

/// @cond DO_NOT_DOCUMENT 


static inline void
store_gen(uint32_t *g, uint32_t n, uint32_t start, uint32_t maxlen, uint32_t *a)
{
    uint32_t i, mask;
    if (start >= n) start = n;
    if (start + maxlen > n) maxlen = n - start;
    mask = (1UL << n) - 1;
    g += start;
    a[0] = 0;
    for (i = 1; i < 1UL << maxlen; ++i) a[i] = vmatmul(i, g) & mask;
}


/** @brief Yet to be tested and documented!

*/
static inline int32_t add_generators(uint32_t *a)
{
    uint32_t *p_alloc = NULL;
    uint32_t *p_start, *p_end, *p_overflow, *p_g, *p_s_g, *p_g1, *p_b;
    uint32_t i, j, l_b;
    int32_t status = gen_ufind_lin2_check(a, 0x7ffffffUL);
    lin2_type s;

    if (status < 0) return status;
    if (a[0] >= 2) return 0;
    load_lin2_info(a, &s);

    // Allocate work buffer and set pointer to queue in work buffer
    l_b = (s.n > 5) ? (1UL << (s.n - 5)) : 1;
    p_alloc = malloc(((1UL << s.n) + s.n_g*2*3*256 + l_b) * sizeof(uint32_t));
    if (p_alloc == NULL) return lin2_error(a, ERR_MEM);
    p_end = p_start = p_alloc;
    p_g = p_overflow = p_start + ((size_t)1UL << s.n);
    p_b = p_g + s.n_g*2*3*256;

    // Load generator matrices
    memset(p_g, 0, s.n_g*2*3*256 * sizeof(uint32_t));
    p_g1 = p_g;
    p_s_g = s.p_g;
    for (i = 0; i < 2 * s.n_g; ++i) {
        for (j = 0; j < 24; j += 8) {
            store_gen(p_s_g, s.n, j, 8, p_g1);
            p_g1 += 256;
        }
        p_s_g += s.n;
    }
    status = ERR_INT_LIN2 - 21;
    if (p_g1 != p_b) goto done;
    status = ERR_INT_LIN2 - 22;
    if (p_s_g != s.p_g + 2 * s.n_g * s.n) goto done;

    // Initialize bitmap table
    memset(p_b, 0, l_b * sizeof(uint32_t));

    // Load start vectors to queue and mark them in bitmap table
    status = gen_ufind_lin2_representatives(a, p_start, 1UL << s.n);
    if (status != (int32_t)s.n_orbits) {
        status = status < 0 ? status : ERR_INT_LIN2 - 23;
        goto done;
    }
    p_end = p_start + s.n_orbits;
    for (i = 0; i < s.n_orbits; ++i) {
        uint32_t data = p_start[i];
        p_b[data >> 5] |= 1UL << (data & 31);
    }

    // Compute and store generators
    status = ERR_INT_LIN2 - 25;
    while (p_start < p_end) {
        uint32_t data = *p_start++;
        p_g1 = p_g;
        for (i = 0; i < 2 * s.n_g; ++i) {
            uint32_t img = p_g1[data & 0xff]
                         ^ p_g1[256 + ((data >> 8) & 0xff)]
                         ^ p_g1[512 + ((data >> 16) & 0xff)];
            img &= (0x1UL << s.n) - 1;
            p_g1 += 3*256;
            if (p_b[img >> 5] & (1UL << (img & 31))) continue;

            p_b[img >> 5] |= 1UL << (img & 31);
            s.p_t[img] &= ((i ^ 1) << 24) | 0xffffffUL;
            if (p_end >= p_overflow) goto done;
            *p_end++ = img;
        }
    }
    a[0] = 2;  // update main status
    status = 0;
done:
    if (p_alloc) free(p_alloc);
    if (status < 0) return lin2_error(a, status);
    return 0;
}




/// @endcond



/** @brief Return group element mapping ``v`` to orbit representative

Thus fuction is yet under construction. Do not use!

Details are yet to be documented!
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v_gen(uint32_t *a, uint32_t v)
{
    uint32_t mask;
    int32_t status = add_generators(a);
    lin2_type s;
    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;
    return (s.p_t[v & mask] >> 24) & 0xff;
}




/** @brief Return group element mapping ``v`` to orbit representative

Thus fuction is yet under construction. Do not use!

Details are yet to be documented! 
*/
// %%EXPORT px
int32_t gen_ufind_lin2_map_v(uint32_t *a, uint32_t v, uint8_t *b, uint32_t l_b)
{
    lin2_type s;
    uint32_t mask, w, l_b1, entry;
    int32_t status = add_generators(a);
    if (status < 0) return status;
    load_lin2_info(a, &s);
    mask = (1UL << s.n) - 1;
    v &= mask;
    entry = s.p_t[v];
    w = (((entry >> 24) & 0xff) == 0xfe) ? v : entry & mask;
    l_b1 = l_b;
    while (1) {
        uint32_t gen = (entry >> 24) & 0xff;
        if (gen == 0xfe) {
            return l_b - l_b1;
        }
        if ((entry & mask) != w) return ERR_INT_LIN2 - 31;
        if (l_b1-- == 0) return ERR_OUT_SHORT;
        *b++ = (uint8_t)gen;
        if (gen >= 2 * s.n_g) return ERR_INT_LIN2 - 32;
        v = vmatmul(v, s.p_g + (size_t)(gen * s.n));
        entry = s.p_t[v];
    }
    return ERR_INT_LIN2 - 33;
}





/************************************************************************
* Flinalize the computation of all data in an array of orbits
************************************************************************/

/// @cond DO_NOT_DOCUMENT
#define LIN2_MAGIC 0x1fecd173UL

#define LIN2_AMUL 0x5ac83257UL

static inline uint32_t magic_content(lin2_type * p_s)
{
    return (uint32_t)(LIN2_MAGIC + p_s->n_orbits +
            ((p_s->n * LIN2_AMUL) + p_s->n_g) * LIN2_AMUL);
}



// @endcond

/** @brief Compute all possible information about orbits

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Some information
to be stored in ``a`` is computed on demand only. Before writing the
array ``a`` to a file, it may be useful to store the maximum possible
amount of infomation in ``a``. This function perform that task.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_finalize(uint32_t *a)
{
    lin2_type s;
    int32_t status, a_length, i;
    uint32_t a_sum = 0;
    if ((status = add_generators(a)) != 0) return status;
    load_lin2_info(a, &s);
    if (s.status != LIN2_MAX_STATUS) 
        return status < 0 ? status :  ERR_INT_LIN2 - 41;
    a_length =  gen_ufind_lin2_size(s.n, s.n_g);
    a[a_length - 2] = magic_content(&s);
    for (i = 0; i < a_length - 1; ++i) a_sum += a[i];
    a[a_length -1] = 0 - a_sum;
    return a_length;
}

/** @brief Check if an orbit array has been finalized

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. The function checks
if the array ``a`` of length ``len_a`` has been finalized by calling
function ``gen_ufind_lin2_finalize``. The function returns the
actual size of the array ``a`` if this is the case and a negative
otherwise. Note the a finalized array contains an internal checksum.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_check_finalized(uint32_t *a, uint32_t len_a)
{
    lin2_type s;
    int32_t status, a_length, i;
    uint32_t a_sum = 0;
    if ((status = gen_ufind_lin2_check(a, len_a)) < 0) return status;
    load_lin2_info(a, &s);
    if (s.status != LIN2_MAX_STATUS)
        return status < 0 ? status : ERR_INT_LIN2 - 43;
    a_length =  gen_ufind_lin2_size(s.n, s.n_g);
    if (a_length <= 0) return ERR_INT_LIN2 - 44;;
    if (a[a_length - 2] != magic_content(&s)) return ERR_INT_LIN2 - 45;
    for (i = 0; i < a_length; ++i) a_sum += a[i];
    if (a_sum) return ERR_INT_LIN2 - 46;
    return a_length;
}





/************************************************************************
* Compatibility to older versions
************************************************************************/


/** @brief Output mapping computed by the union-find algorithm

Let ``a`` be an array that stores a group acting on a vector space
``v`` over ``GF(2)`` as described in function ``gen_ufind_lin2_init``.
Let ``n`` be the dimension of that vector space as returned by
function ``gen_ufind_lin2_dim``. The function computes a mapping
from the vectors in ``V`` to a set of representatives of the orbits
on ``V`` under the action of the group. The function writes this
mapping into the array ``map`` of size ``l_map``.

Thus ``l_map >= 1 << n`` must hold. The function returns the actual
length ``1 << n`` of the array ``map``. It returns a negative value
in case of failure, e.g. if the array ``map`` is too short.
*/
// %%EXPORT px
int32_t gen_ufind_lin2_get_map(uint32_t *a, uint32_t *map, uint32_t l_map)
{
    lin2_type s;
    uint32_t i;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    if (check_out_buf32(map, l_map, 1UL << s.n)) return ERR_OUT_SHORT;
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = s.p_t[i];
        map[i] = ((v & 0xff000000UL) == 0xfe000000UL) ? i : v & 0xffffffUL;
    }
    return 1UL << s.n;
}



/** @brief Output the partition computed by the union-find algorithm

Let ``a`` be an array that stores a group acting on a vector space
as described in function ``gen_ufind_lin2_init``. Array ``a`` contains
the set of orbits in the vector space under the action of the group.

Alternatively, this set of orbits could be computed with the union-find
algorithm described in function ``gen_ufind_lin2_init``.
Assume that ``table`` is a table generated with the union-find algorithm
corresponding to the set of orbits in the array ``a`` generated by
function ``gen_ufind_lin2_init``.

Then ``gen_ufind_lin2_orbits(a, map, l_map, ind, l_ind)`` is equivalent
to ``gen_ufind_partition(table, l_t, map, ind, l_ind)``

Here the length of that table is ``l_t = 1 << gen_ufind_lin2_dim(a)``.
The length of the array ``map`` is  equal to ``l_map = l_t``.
The length of the array ``ind`` is  equal
to ``l_ind = gen_ufind_lin2_n_orbits(a) + 1``.

*/
// %%EXPORT px
int32_t gen_ufind_lin2_orbits(uint32_t *a, uint32_t *t, uint32_t l_t, uint32_t *x, uint32_t l_x)
{
    lin2_type s;
    uint32_t i;
    int32_t status = check_a_fast(a);

    if (status < 0) return status;
    load_lin2_info(a, &s);
    if (check_out_buf32(t, l_t, 1UL << s.n)) return ERR_OUT_SHORT;
    if (check_out_buf32(x, l_x, s.n_orbits + 1)) return ERR_OUT_SHORT;
    /* Ye olde waye to do the worke
    memcpy(t, s.p_t, sizeof(uint32_t) <<  s.n);
    for (i = 0; i < (1UL << s.n); ++i) {
        uint32_t v = t[i];
        if ((v & 0xff000000UL) == 0xfe000000UL) v == 0x80000000UL;
        else v &= 0xffffffUL;
        t[i] = v;
    }
    return gen_ufind_partition(t, 1UL << s.n, t, x, s.n_orbits + 1);
    */
    for (i = 0; i < (1UL << s.n); ++i)  t[i] = s.p_o[i] & 0xffffff;
    x[0] = 0;
    for (i = 0; i < s.n_orbits; ++i) {
        int32_t d = read_length_info(s.p_o + x[i]);
        if (d < 0) return ERR_INT_LIN2 - 51;
        x[i+1] = x[i] + d;
    }
    if (x[s.n_orbits] != (1UL << s.n)) return ERR_INT_LIN2 - 52;
    return s.n_orbits;
}


//  %%GEN h
/// @endcond 
//  %%GEN c



// %%GEN ch
#ifdef __cplusplus
}
#endif




