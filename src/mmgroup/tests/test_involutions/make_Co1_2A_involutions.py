import sys
import os
import time
from math import floor
from random import randint, shuffle, sample
from collections import defaultdict
import numpy as np

if __name__ == "__main__":
    path = ['..'] * 4 + ['src']
    print(path)
    sys.path.append(os.path.join(*path))
    print(sys.path[-1])

from mmgroup import MM, AutPL, PLoop, Cocode, Xsp2_Co1
from mmgroup.generators import gen_leech2_type


_DIR = os.path.split(__file__)[0]
PY_FILENAME = os.path.join(_DIR, "Co1_2A_involutions.py")



for i in range(24):
    assert gen_leech2_type(1 << i) & 0x10 == 0

 
G = MM


y8 = G(("y", PLoop(range(8))))


def cocode_orthgonal_E8():
    o = [0]
    for i in range(1,7):
        cc = Cocode([0,i]).ord
        o = o + ([cc ^ x for x in o])
    return o

def transversal_cocode_orthgonal_E8():
    o = cocode_orthgonal_E8() 
    t = []
    for i in range(4096):
        cc = min([ i ^ x for x in o])
        if not cc in t:
            t.append(cc)
    assert len(t) == 2**6
    return t



def iter_E8_x():
    t = transversal_cocode_orthgonal_E8()
    for g in range(4096):
        xd =  y8 * G( ("x", g) )
        for c in t:
             yield xd * G( ("d", c) )

characters = []



def invariant_count_type2(iv):
    v0, v1 =  (int(iv[0]) >> 24) & 7, (int(iv[1]) >> 24) & 7
    if (v0 != 4):
        return 0
    data = [int(iv[0]) & 0xffffff]
    for i in range(1,9):
        if (int(iv[i]) >> 24) & 1 == 0:
            x = int(iv[i]) & 0xffffff
            data += [x ^ y for y in data]
    s = sum((gen_leech2_type(x) & 0x20 for x in data))
    return s >> 5
    

def invariant_type(g):
    iv, _1, ortho = Xsp2_Co1(g)._involution_invariants()
    v0, v1 =  (int(iv[0]) >> 24) & 7, (int(iv[1]) >> 24) & 7
    ct2 = invariant_count_type2(iv)
    return v0, v1, gen_leech2_type(ortho) >> 4, ct2


def display_involution_invariants(g):
    iv, v1, v0 = Xsp2_Co1(g)._involution_invariants()
    print("Involution invariants of", MM(g), ":")
    for i in range(12):
        v = int(iv[i])
        if i and v == 0:
            break
        print("0x%06x 0x%01x 0x%06x" % 
            ((v >> 32) & 0xffffff, (v >> 24) & 0xf, v & 0xffffff)
       )
    print("Orthogonal: 0x%06x, 0x%06x\n" % (v1, v0))



F_START_TEXT = """This file has been created automatically, do not change

This file has been generated by 'make_Co1_2A_involution.py'

It (hopefully) contains a representatives of all classes in G_x0 
which map to class 2A in Co_1.

Note that this file uses functions from module 'involutions.c'.
So when testing that module, it is useful to have such a transversal.
But the tests for that module which use these representatives
should be preceded by independent tests.
"""

def write_samples():
    f = open(PY_FILENAME, "wt")
    for line in F_START_TEXT.split("\n"):
        f.write("# " + line + "\n")
    f.write("\n\nCo1_class_2A_samples = [\n")
    for nn, g in enumerate(iter_E8_x()):
        o_chi =  g.order(), g.chi_G_x0(), invariant_type(g)
        if not o_chi in characters:
            characters.append(o_chi)
            chi = o_chi[1] 
            x = chi[0] - chi[1] - chi[2] * chi[3]
            print('"' + str(g) +  '",', file = f)
            print([list(o_chi), x, g], ",")
            if o_chi[2][:3] == (4,1,4):
                display_involution_invariants(g)
                pass
        if nn & 0xffff == 0: print(".")
    f.write("]\n")
    f.close()

if __name__ == "__main__":
    write_samples()








"""Screen Output:
Possible orders, characters, and involution invariants
of cosets Q_x0 * e_8 in G_x0, 
where  e_8 is a 2A-involution in Co_1. 


[[2, (4371, 43, 8,  256), (0, 0, 0,  0)], 2280,  M<y_80fh>] ,
[[4, (275,  43, 8,    0), (4, 1, 4, 16)],  232,  M<y_80fh*d_1h>] ,
[[2, (275,  43, 8,    0), (4, 0, 0, 16)],  232,  M<y_80fh*d_3h>] ,
[[4, (51,   43, 8,    0), (4, 1, 2,  2)],    8,  M<y_80fh*d_801h>] ,
[[4, (19,   43, 8,    0), (4, 1, 4,  0)],  -24,  M<y_80fh*d_803h>] ,
[[4, (19,   43, 8,    0), (5, 0, 0,  0)],  -24,  M<y_0fh*x_1003h*d_5h>] ,
[[2, (275,  43, 8, -256), (0, 0, 0,  0)], 2280,  M<y_100fh>] ,
"""